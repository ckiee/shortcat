#!/usr/bin/env bun
// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/y18n/build/index.cjs
var require_build = __commonJS((exports, module) => {
  var fs = import.meta.require("fs");
  var util = import.meta.require("util");
  var path = import.meta.require("path");
  var shim;

  class Y18N {
    constructor(opts) {
      opts = opts || {};
      this.directory = opts.directory || "./locales";
      this.updateFiles = typeof opts.updateFiles === "boolean" ? opts.updateFiles : true;
      this.locale = opts.locale || "en";
      this.fallbackToLanguage = typeof opts.fallbackToLanguage === "boolean" ? opts.fallbackToLanguage : true;
      this.cache = Object.create(null);
      this.writeQueue = [];
    }
    __(...args) {
      if (typeof arguments[0] !== "string") {
        return this._taggedLiteral(arguments[0], ...arguments);
      }
      const str = args.shift();
      let cb = function() {
      };
      if (typeof args[args.length - 1] === "function")
        cb = args.pop();
      cb = cb || function() {
      };
      if (!this.cache[this.locale])
        this._readLocaleFile();
      if (!this.cache[this.locale][str] && this.updateFiles) {
        this.cache[this.locale][str] = str;
        this._enqueueWrite({
          directory: this.directory,
          locale: this.locale,
          cb
        });
      } else {
        cb();
      }
      return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));
    }
    __n() {
      const args = Array.prototype.slice.call(arguments);
      const singular = args.shift();
      const plural = args.shift();
      const quantity = args.shift();
      let cb = function() {
      };
      if (typeof args[args.length - 1] === "function")
        cb = args.pop();
      if (!this.cache[this.locale])
        this._readLocaleFile();
      let str = quantity === 1 ? singular : plural;
      if (this.cache[this.locale][singular]) {
        const entry = this.cache[this.locale][singular];
        str = entry[quantity === 1 ? "one" : "other"];
      }
      if (!this.cache[this.locale][singular] && this.updateFiles) {
        this.cache[this.locale][singular] = {
          one: singular,
          other: plural
        };
        this._enqueueWrite({
          directory: this.directory,
          locale: this.locale,
          cb
        });
      } else {
        cb();
      }
      const values = [str];
      if (~str.indexOf("%d"))
        values.push(quantity);
      return shim.format.apply(shim.format, values.concat(args));
    }
    setLocale(locale) {
      this.locale = locale;
    }
    getLocale() {
      return this.locale;
    }
    updateLocale(obj) {
      if (!this.cache[this.locale])
        this._readLocaleFile();
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          this.cache[this.locale][key] = obj[key];
        }
      }
    }
    _taggedLiteral(parts, ...args) {
      let str = "";
      parts.forEach(function(part, i) {
        const arg = args[i + 1];
        str += part;
        if (typeof arg !== "undefined") {
          str += "%s";
        }
      });
      return this.__.apply(this, [str].concat([].slice.call(args, 1)));
    }
    _enqueueWrite(work) {
      this.writeQueue.push(work);
      if (this.writeQueue.length === 1)
        this._processWriteQueue();
    }
    _processWriteQueue() {
      const _this = this;
      const work = this.writeQueue[0];
      const directory = work.directory;
      const locale = work.locale;
      const cb = work.cb;
      const languageFile = this._resolveLocaleFile(directory, locale);
      const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
      shim.fs.writeFile(languageFile, serializedLocale, "utf-8", function(err) {
        _this.writeQueue.shift();
        if (_this.writeQueue.length > 0)
          _this._processWriteQueue();
        cb(err);
      });
    }
    _readLocaleFile() {
      let localeLookup = {};
      const languageFile = this._resolveLocaleFile(this.directory, this.locale);
      try {
        if (shim.fs.readFileSync) {
          localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, "utf-8"));
        }
      } catch (err) {
        if (err instanceof SyntaxError) {
          err.message = "syntax error in " + languageFile;
        }
        if (err.code === "ENOENT")
          localeLookup = {};
        else
          throw err;
      }
      this.cache[this.locale] = localeLookup;
    }
    _resolveLocaleFile(directory, locale) {
      let file = shim.resolve(directory, "./", locale + ".json");
      if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf("_")) {
        const languageFile = shim.resolve(directory, "./", locale.split("_")[0] + ".json");
        if (this._fileExistsSync(languageFile))
          file = languageFile;
      }
      return file;
    }
    _fileExistsSync(file) {
      return shim.exists(file);
    }
  }
  function y18n$1(opts, _shim) {
    shim = _shim;
    const y18n2 = new Y18N(opts);
    return {
      __: y18n2.__.bind(y18n2),
      __n: y18n2.__n.bind(y18n2),
      setLocale: y18n2.setLocale.bind(y18n2),
      getLocale: y18n2.getLocale.bind(y18n2),
      updateLocale: y18n2.updateLocale.bind(y18n2),
      locale: y18n2.locale
    };
  }
  var nodePlatformShim = {
    fs: {
      readFileSync: fs.readFileSync,
      writeFile: fs.writeFile
    },
    format: util.format,
    resolve: path.resolve,
    exists: (file) => {
      try {
        return fs.statSync(file).isFile();
      } catch (err) {
        return false;
      }
    }
  };
  var y18n = (opts) => {
    return y18n$1(opts, nodePlatformShim);
  };
  module.exports = y18n;
});

// node_modules/yargs-parser/build/index.cjs
var require_build2 = __commonJS((exports, module) => {
  var util = import.meta.require("util");
  var path = import.meta.require("path");
  var fs = import.meta.require("fs");
  function camelCase(str) {
    const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
    if (!isCamelCase) {
      str = str.toLowerCase();
    }
    if (str.indexOf("-") === -1 && str.indexOf("_") === -1) {
      return str;
    } else {
      let camelcase = "";
      let nextChrUpper = false;
      const leadingHyphens = str.match(/^-+/);
      for (let i = leadingHyphens ? leadingHyphens[0].length : 0;i < str.length; i++) {
        let chr = str.charAt(i);
        if (nextChrUpper) {
          nextChrUpper = false;
          chr = chr.toUpperCase();
        }
        if (i !== 0 && (chr === "-" || chr === "_")) {
          nextChrUpper = true;
        } else if (chr !== "-" && chr !== "_") {
          camelcase += chr;
        }
      }
      return camelcase;
    }
  }
  function decamelize(str, joinString) {
    const lowercase = str.toLowerCase();
    joinString = joinString || "-";
    let notCamelcase = "";
    for (let i = 0;i < str.length; i++) {
      const chrLower = lowercase.charAt(i);
      const chrString = str.charAt(i);
      if (chrLower !== chrString && i > 0) {
        notCamelcase += `${joinString}${lowercase.charAt(i)}`;
      } else {
        notCamelcase += chrString;
      }
    }
    return notCamelcase;
  }
  function looksLikeNumber(x) {
    if (x === null || x === undefined)
      return false;
    if (typeof x === "number")
      return true;
    if (/^0x[0-9a-f]+$/i.test(x))
      return true;
    if (/^0[^.]/.test(x))
      return false;
    return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
  }
  function tokenizeArgString(argString) {
    if (Array.isArray(argString)) {
      return argString.map((e) => typeof e !== "string" ? e + "" : e);
    }
    argString = argString.trim();
    let i = 0;
    let prevC = null;
    let c = null;
    let opening = null;
    const args = [];
    for (let ii = 0;ii < argString.length; ii++) {
      prevC = c;
      c = argString.charAt(ii);
      if (c === " " && !opening) {
        if (!(prevC === " ")) {
          i++;
        }
        continue;
      }
      if (c === opening) {
        opening = null;
      } else if ((c === "'" || c === '"') && !opening) {
        opening = c;
      }
      if (!args[i])
        args[i] = "";
      args[i] += c;
    }
    return args;
  }
  var DefaultValuesForTypeKey;
  (function(DefaultValuesForTypeKey2) {
    DefaultValuesForTypeKey2["BOOLEAN"] = "boolean";
    DefaultValuesForTypeKey2["STRING"] = "string";
    DefaultValuesForTypeKey2["NUMBER"] = "number";
    DefaultValuesForTypeKey2["ARRAY"] = "array";
  })(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));
  var mixin;

  class YargsParser {
    constructor(_mixin) {
      mixin = _mixin;
    }
    parse(argsInput, options) {
      const opts = Object.assign({
        alias: undefined,
        array: undefined,
        boolean: undefined,
        config: undefined,
        configObjects: undefined,
        configuration: undefined,
        coerce: undefined,
        count: undefined,
        default: undefined,
        envPrefix: undefined,
        narg: undefined,
        normalize: undefined,
        string: undefined,
        number: undefined,
        __: undefined,
        key: undefined
      }, options);
      const args = tokenizeArgString(argsInput);
      const inputIsString = typeof argsInput === "string";
      const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
      const configuration = Object.assign({
        "boolean-negation": true,
        "camel-case-expansion": true,
        "combine-arrays": false,
        "dot-notation": true,
        "duplicate-arguments-array": true,
        "flatten-duplicate-arrays": true,
        "greedy-arrays": true,
        "halt-at-non-option": false,
        "nargs-eats-options": false,
        "negation-prefix": "no-",
        "parse-numbers": true,
        "parse-positional-numbers": true,
        "populate--": false,
        "set-placeholder-key": false,
        "short-option-groups": true,
        "strip-aliased": false,
        "strip-dashed": false,
        "unknown-options-as-args": false
      }, opts.configuration);
      const defaults = Object.assign(Object.create(null), opts.default);
      const configObjects = opts.configObjects || [];
      const envPrefix = opts.envPrefix;
      const notFlagsOption = configuration["populate--"];
      const notFlagsArgv = notFlagsOption ? "--" : "_";
      const newAliases = Object.create(null);
      const defaulted = Object.create(null);
      const __ = opts.__ || mixin.format;
      const flags = {
        aliases: Object.create(null),
        arrays: Object.create(null),
        bools: Object.create(null),
        strings: Object.create(null),
        numbers: Object.create(null),
        counts: Object.create(null),
        normalize: Object.create(null),
        configs: Object.create(null),
        nargs: Object.create(null),
        coercions: Object.create(null),
        keys: []
      };
      const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
      const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
      [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
        const key = typeof opt === "object" ? opt.key : opt;
        const assignment = Object.keys(opt).map(function(key2) {
          const arrayFlagKeys = {
            boolean: "bools",
            string: "strings",
            number: "numbers"
          };
          return arrayFlagKeys[key2];
        }).filter(Boolean).pop();
        if (assignment) {
          flags[assignment][key] = true;
        }
        flags.arrays[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
        flags.bools[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
        flags.strings[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
        flags.numbers[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
        flags.counts[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
        flags.normalize[key] = true;
        flags.keys.push(key);
      });
      if (typeof opts.narg === "object") {
        Object.entries(opts.narg).forEach(([key, value]) => {
          if (typeof value === "number") {
            flags.nargs[key] = value;
            flags.keys.push(key);
          }
        });
      }
      if (typeof opts.coerce === "object") {
        Object.entries(opts.coerce).forEach(([key, value]) => {
          if (typeof value === "function") {
            flags.coercions[key] = value;
            flags.keys.push(key);
          }
        });
      }
      if (typeof opts.config !== "undefined") {
        if (Array.isArray(opts.config) || typeof opts.config === "string") {
          [].concat(opts.config).filter(Boolean).forEach(function(key) {
            flags.configs[key] = true;
          });
        } else if (typeof opts.config === "object") {
          Object.entries(opts.config).forEach(([key, value]) => {
            if (typeof value === "boolean" || typeof value === "function") {
              flags.configs[key] = value;
            }
          });
        }
      }
      extendAliases(opts.key, aliases, opts.default, flags.arrays);
      Object.keys(defaults).forEach(function(key) {
        (flags.aliases[key] || []).forEach(function(alias) {
          defaults[alias] = defaults[key];
        });
      });
      let error = null;
      checkConfiguration();
      let notFlags = [];
      const argv = Object.assign(Object.create(null), { _: [] });
      const argvReturn = {};
      for (let i = 0;i < args.length; i++) {
        const arg = args[i];
        const truncatedArg = arg.replace(/^-{3,}/, "---");
        let broken;
        let key;
        let letters;
        let m;
        let next;
        let value;
        if (arg !== "--" && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
          pushPositional(arg);
        } else if (truncatedArg.match(/^---+(=|$)/)) {
          pushPositional(arg);
          continue;
        } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
          m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
          if (m !== null && Array.isArray(m) && m.length >= 3) {
            if (checkAllAliases(m[1], flags.arrays)) {
              i = eatArray(i, m[1], args, m[2]);
            } else if (checkAllAliases(m[1], flags.nargs) !== false) {
              i = eatNargs(i, m[1], args, m[2]);
            } else {
              setArg(m[1], m[2], true);
            }
          }
        } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
          m = arg.match(negatedBoolean);
          if (m !== null && Array.isArray(m) && m.length >= 2) {
            key = m[1];
            setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
          }
        } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
          m = arg.match(/^--?(.+)/);
          if (m !== null && Array.isArray(m) && m.length >= 2) {
            key = m[1];
            if (checkAllAliases(key, flags.arrays)) {
              i = eatArray(i, key, args);
            } else if (checkAllAliases(key, flags.nargs) !== false) {
              i = eatNargs(i, key, args);
            } else {
              next = args[i + 1];
              if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                setArg(key, next);
                i++;
              } else if (/^(true|false)$/.test(next)) {
                setArg(key, next);
                i++;
              } else {
                setArg(key, defaultValue(key));
              }
            }
          }
        } else if (arg.match(/^-.\..+=/)) {
          m = arg.match(/^-([^=]+)=([\s\S]*)$/);
          if (m !== null && Array.isArray(m) && m.length >= 3) {
            setArg(m[1], m[2]);
          }
        } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
          next = args[i + 1];
          m = arg.match(/^-(.\..+)/);
          if (m !== null && Array.isArray(m) && m.length >= 2) {
            key = m[1];
            if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
          letters = arg.slice(1, -1).split("");
          broken = false;
          for (let j = 0;j < letters.length; j++) {
            next = arg.slice(j + 2);
            if (letters[j + 1] && letters[j + 1] === "=") {
              value = arg.slice(j + 3);
              key = letters[j];
              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args, value);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args, value);
              } else {
                setArg(key, value);
              }
              broken = true;
              break;
            }
            if (next === "-") {
              setArg(letters[j], next);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
              setArg(letters[j], next);
              broken = true;
              break;
            }
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], next);
              broken = true;
              break;
            } else {
              setArg(letters[j], defaultValue(letters[j]));
            }
          }
          key = arg.slice(-1)[0];
          if (!broken && key !== "-") {
            if (checkAllAliases(key, flags.arrays)) {
              i = eatArray(i, key, args);
            } else if (checkAllAliases(key, flags.nargs) !== false) {
              i = eatNargs(i, key, args);
            } else {
              next = args[i + 1];
              if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                setArg(key, next);
                i++;
              } else if (/^(true|false)$/.test(next)) {
                setArg(key, next);
                i++;
              } else {
                setArg(key, defaultValue(key));
              }
            }
          }
        } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
          key = arg.slice(1);
          setArg(key, defaultValue(key));
        } else if (arg === "--") {
          notFlags = args.slice(i + 1);
          break;
        } else if (configuration["halt-at-non-option"]) {
          notFlags = args.slice(i);
          break;
        } else {
          pushPositional(arg);
        }
      }
      applyEnvVars(argv, true);
      applyEnvVars(argv, false);
      setConfig(argv);
      setConfigObjects();
      applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
      applyCoercions(argv);
      if (configuration["set-placeholder-key"])
        setPlaceholderKeys(argv);
      Object.keys(flags.counts).forEach(function(key) {
        if (!hasKey(argv, key.split(".")))
          setArg(key, 0);
      });
      if (notFlagsOption && notFlags.length)
        argv[notFlagsArgv] = [];
      notFlags.forEach(function(key) {
        argv[notFlagsArgv].push(key);
      });
      if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
        Object.keys(argv).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
          delete argv[key];
        });
      }
      if (configuration["strip-aliased"]) {
        [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
          if (configuration["camel-case-expansion"] && alias.includes("-")) {
            delete argv[alias.split(".").map((prop) => camelCase(prop)).join(".")];
          }
          delete argv[alias];
        });
      }
      function pushPositional(arg) {
        const maybeCoercedNumber = maybeCoerceNumber("_", arg);
        if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") {
          argv._.push(maybeCoercedNumber);
        }
      }
      function eatNargs(i, key, args2, argAfterEqualSign) {
        let ii;
        let toEat = checkAllAliases(key, flags.nargs);
        toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
        if (toEat === 0) {
          if (!isUndefined(argAfterEqualSign)) {
            error = Error(__("Argument unexpected for: %s", key));
          }
          setArg(key, defaultValue(key));
          return i;
        }
        let available = isUndefined(argAfterEqualSign) ? 0 : 1;
        if (configuration["nargs-eats-options"]) {
          if (args2.length - (i + 1) + available < toEat) {
            error = Error(__("Not enough arguments following: %s", key));
          }
          available = toEat;
        } else {
          for (ii = i + 1;ii < args2.length; ii++) {
            if (!args2[ii].match(/^-[^0-9]/) || args2[ii].match(negative) || isUnknownOptionAsArg(args2[ii]))
              available++;
            else
              break;
          }
          if (available < toEat)
            error = Error(__("Not enough arguments following: %s", key));
        }
        let consumed = Math.min(available, toEat);
        if (!isUndefined(argAfterEqualSign) && consumed > 0) {
          setArg(key, argAfterEqualSign);
          consumed--;
        }
        for (ii = i + 1;ii < consumed + i + 1; ii++) {
          setArg(key, args2[ii]);
        }
        return i + consumed;
      }
      function eatArray(i, key, args2, argAfterEqualSign) {
        let argsToSet = [];
        let next = argAfterEqualSign || args2[i + 1];
        const nargsCount = checkAllAliases(key, flags.nargs);
        if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
          argsToSet.push(true);
        } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
          if (defaults[key] !== undefined) {
            const defVal = defaults[key];
            argsToSet = Array.isArray(defVal) ? defVal : [defVal];
          }
        } else {
          if (!isUndefined(argAfterEqualSign)) {
            argsToSet.push(processValue(key, argAfterEqualSign, true));
          }
          for (let ii = i + 1;ii < args2.length; ii++) {
            if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount)
              break;
            next = args2[ii];
            if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
              break;
            i = ii;
            argsToSet.push(processValue(key, next, inputIsString));
          }
        }
        if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
          error = Error(__("Not enough arguments following: %s", key));
        }
        setArg(key, argsToSet);
        return i;
      }
      function setArg(key, val, shouldStripQuotes = inputIsString) {
        if (/-/.test(key) && configuration["camel-case-expansion"]) {
          const alias = key.split(".").map(function(prop) {
            return camelCase(prop);
          }).join(".");
          addNewAlias(key, alias);
        }
        const value = processValue(key, val, shouldStripQuotes);
        const splitKey = key.split(".");
        setKey(argv, splitKey, value);
        if (flags.aliases[key]) {
          flags.aliases[key].forEach(function(x) {
            const keyProperties = x.split(".");
            setKey(argv, keyProperties, value);
          });
        }
        if (splitKey.length > 1 && configuration["dot-notation"]) {
          (flags.aliases[splitKey[0]] || []).forEach(function(x) {
            let keyProperties = x.split(".");
            const a = [].concat(splitKey);
            a.shift();
            keyProperties = keyProperties.concat(a);
            if (!(flags.aliases[key] || []).includes(keyProperties.join("."))) {
              setKey(argv, keyProperties, value);
            }
          });
        }
        if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
          const keys = [key].concat(flags.aliases[key] || []);
          keys.forEach(function(key2) {
            Object.defineProperty(argvReturn, key2, {
              enumerable: true,
              get() {
                return val;
              },
              set(value2) {
                val = typeof value2 === "string" ? mixin.normalize(value2) : value2;
              }
            });
          });
        }
      }
      function addNewAlias(key, alias) {
        if (!(flags.aliases[key] && flags.aliases[key].length)) {
          flags.aliases[key] = [alias];
          newAliases[alias] = true;
        }
        if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
          addNewAlias(alias, key);
        }
      }
      function processValue(key, val, shouldStripQuotes) {
        if (shouldStripQuotes) {
          val = stripQuotes(val);
        }
        if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
          if (typeof val === "string")
            val = val === "true";
        }
        let value = Array.isArray(val) ? val.map(function(v) {
          return maybeCoerceNumber(key, v);
        }) : maybeCoerceNumber(key, val);
        if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === "boolean")) {
          value = increment();
        }
        if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
          if (Array.isArray(val))
            value = val.map((val2) => {
              return mixin.normalize(val2);
            });
          else
            value = mixin.normalize(val);
        }
        return value;
      }
      function maybeCoerceNumber(key, value) {
        if (!configuration["parse-positional-numbers"] && key === "_")
          return value;
        if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
          const shouldCoerceNumber = looksLikeNumber(value) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));
          if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {
            value = Number(value);
          }
        }
        return value;
      }
      function setConfig(argv2) {
        const configLookup = Object.create(null);
        applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
        Object.keys(flags.configs).forEach(function(configKey) {
          const configPath = argv2[configKey] || configLookup[configKey];
          if (configPath) {
            try {
              let config = null;
              const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
              const resolveConfig = flags.configs[configKey];
              if (typeof resolveConfig === "function") {
                try {
                  config = resolveConfig(resolvedConfigPath);
                } catch (e) {
                  config = e;
                }
                if (config instanceof Error) {
                  error = config;
                  return;
                }
              } else {
                config = mixin.require(resolvedConfigPath);
              }
              setConfigObject(config);
            } catch (ex) {
              if (ex.name === "PermissionDenied")
                error = ex;
              else if (argv2[configKey])
                error = Error(__("Invalid JSON config file: %s", configPath));
            }
          }
        });
      }
      function setConfigObject(config, prev) {
        Object.keys(config).forEach(function(key) {
          const value = config[key];
          const fullKey = prev ? prev + "." + key : key;
          if (typeof value === "object" && value !== null && !Array.isArray(value) && configuration["dot-notation"]) {
            setConfigObject(value, fullKey);
          } else {
            if (!hasKey(argv, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
              setArg(fullKey, value);
            }
          }
        });
      }
      function setConfigObjects() {
        if (typeof configObjects !== "undefined") {
          configObjects.forEach(function(configObject) {
            setConfigObject(configObject);
          });
        }
      }
      function applyEnvVars(argv2, configOnly) {
        if (typeof envPrefix === "undefined")
          return;
        const prefix = typeof envPrefix === "string" ? envPrefix : "";
        const env2 = mixin.env();
        Object.keys(env2).forEach(function(envVar) {
          if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
            const keys = envVar.split("__").map(function(key, i) {
              if (i === 0) {
                key = key.substring(prefix.length);
              }
              return camelCase(key);
            });
            if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv2, keys)) {
              setArg(keys.join("."), env2[envVar]);
            }
          }
        });
      }
      function applyCoercions(argv2) {
        let coerce;
        const applied = new Set;
        Object.keys(argv2).forEach(function(key) {
          if (!applied.has(key)) {
            coerce = checkAllAliases(key, flags.coercions);
            if (typeof coerce === "function") {
              try {
                const value = maybeCoerceNumber(key, coerce(argv2[key]));
                [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                  applied.add(ali);
                  argv2[ali] = value;
                });
              } catch (err) {
                error = err;
              }
            }
          }
        });
      }
      function setPlaceholderKeys(argv2) {
        flags.keys.forEach((key) => {
          if (~key.indexOf("."))
            return;
          if (typeof argv2[key] === "undefined")
            argv2[key] = undefined;
        });
        return argv2;
      }
      function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
        Object.keys(defaults2).forEach(function(key) {
          if (!hasKey(obj, key.split("."))) {
            setKey(obj, key.split("."), defaults2[key]);
            if (canLog)
              defaulted[key] = true;
            (aliases2[key] || []).forEach(function(x) {
              if (hasKey(obj, x.split(".")))
                return;
              setKey(obj, x.split("."), defaults2[key]);
            });
          }
        });
      }
      function hasKey(obj, keys) {
        let o = obj;
        if (!configuration["dot-notation"])
          keys = [keys.join(".")];
        keys.slice(0, -1).forEach(function(key2) {
          o = o[key2] || {};
        });
        const key = keys[keys.length - 1];
        if (typeof o !== "object")
          return false;
        else
          return key in o;
      }
      function setKey(obj, keys, value) {
        let o = obj;
        if (!configuration["dot-notation"])
          keys = [keys.join(".")];
        keys.slice(0, -1).forEach(function(key2) {
          key2 = sanitizeKey(key2);
          if (typeof o === "object" && o[key2] === undefined) {
            o[key2] = {};
          }
          if (typeof o[key2] !== "object" || Array.isArray(o[key2])) {
            if (Array.isArray(o[key2])) {
              o[key2].push({});
            } else {
              o[key2] = [o[key2], {}];
            }
            o = o[key2][o[key2].length - 1];
          } else {
            o = o[key2];
          }
        });
        const key = sanitizeKey(keys[keys.length - 1]);
        const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
        const isValueArray = Array.isArray(value);
        let duplicate = configuration["duplicate-arguments-array"];
        if (!duplicate && checkAllAliases(key, flags.nargs)) {
          duplicate = true;
          if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
            o[key] = undefined;
          }
        }
        if (value === increment()) {
          o[key] = increment(o[key]);
        } else if (Array.isArray(o[key])) {
          if (duplicate && isTypeArray && isValueArray) {
            o[key] = configuration["flatten-duplicate-arrays"] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
          } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
            o[key] = value;
          } else {
            o[key] = o[key].concat([value]);
          }
        } else if (o[key] === undefined && isTypeArray) {
          o[key] = isValueArray ? value : [value];
        } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
          o[key] = [o[key], value];
        } else {
          o[key] = value;
        }
      }
      function extendAliases(...args2) {
        args2.forEach(function(obj) {
          Object.keys(obj || {}).forEach(function(key) {
            if (flags.aliases[key])
              return;
            flags.aliases[key] = [].concat(aliases[key] || []);
            flags.aliases[key].concat(key).forEach(function(x) {
              if (/-/.test(x) && configuration["camel-case-expansion"]) {
                const c = camelCase(x);
                if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                  flags.aliases[key].push(c);
                  newAliases[c] = true;
                }
              }
            });
            flags.aliases[key].concat(key).forEach(function(x) {
              if (x.length > 1 && /[A-Z]/.test(x) && configuration["camel-case-expansion"]) {
                const c = decamelize(x, "-");
                if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                  flags.aliases[key].push(c);
                  newAliases[c] = true;
                }
              }
            });
            flags.aliases[key].forEach(function(x) {
              flags.aliases[x] = [key].concat(flags.aliases[key].filter(function(y) {
                return x !== y;
              }));
            });
          });
        });
      }
      function checkAllAliases(key, flag) {
        const toCheck = [].concat(flags.aliases[key] || [], key);
        const keys = Object.keys(flag);
        const setAlias = toCheck.find((key2) => keys.includes(key2));
        return setAlias ? flag[setAlias] : false;
      }
      function hasAnyFlag(key) {
        const flagsKeys = Object.keys(flags);
        const toCheck = [].concat(flagsKeys.map((k) => flags[k]));
        return toCheck.some(function(flag) {
          return Array.isArray(flag) ? flag.includes(key) : flag[key];
        });
      }
      function hasFlagsMatching(arg, ...patterns) {
        const toCheck = [].concat(...patterns);
        return toCheck.some(function(pattern) {
          const match = arg.match(pattern);
          return match && hasAnyFlag(match[1]);
        });
      }
      function hasAllShortFlags(arg) {
        if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
          return false;
        }
        let hasAllFlags = true;
        let next;
        const letters = arg.slice(1).split("");
        for (let j = 0;j < letters.length; j++) {
          next = arg.slice(j + 2);
          if (!hasAnyFlag(letters[j])) {
            hasAllFlags = false;
            break;
          }
          if (letters[j + 1] && letters[j + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
            break;
          }
        }
        return hasAllFlags;
      }
      function isUnknownOptionAsArg(arg) {
        return configuration["unknown-options-as-args"] && isUnknownOption(arg);
      }
      function isUnknownOption(arg) {
        arg = arg.replace(/^-{3,}/, "--");
        if (arg.match(negative)) {
          return false;
        }
        if (hasAllShortFlags(arg)) {
          return false;
        }
        const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
        const normalFlag = /^-+([^=]+?)$/;
        const flagEndingInHyphen = /^-+([^=]+?)-$/;
        const flagEndingInDigits = /^-+([^=]+?\d+)$/;
        const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
        return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
      }
      function defaultValue(key) {
        if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
          return defaults[key];
        } else {
          return defaultForType(guessType(key));
        }
      }
      function defaultForType(type) {
        const def = {
          [DefaultValuesForTypeKey.BOOLEAN]: true,
          [DefaultValuesForTypeKey.STRING]: "",
          [DefaultValuesForTypeKey.NUMBER]: undefined,
          [DefaultValuesForTypeKey.ARRAY]: []
        };
        return def[type];
      }
      function guessType(key) {
        let type = DefaultValuesForTypeKey.BOOLEAN;
        if (checkAllAliases(key, flags.strings))
          type = DefaultValuesForTypeKey.STRING;
        else if (checkAllAliases(key, flags.numbers))
          type = DefaultValuesForTypeKey.NUMBER;
        else if (checkAllAliases(key, flags.bools))
          type = DefaultValuesForTypeKey.BOOLEAN;
        else if (checkAllAliases(key, flags.arrays))
          type = DefaultValuesForTypeKey.ARRAY;
        return type;
      }
      function isUndefined(num) {
        return num === undefined;
      }
      function checkConfiguration() {
        Object.keys(flags.counts).find((key) => {
          if (checkAllAliases(key, flags.arrays)) {
            error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
            return true;
          } else if (checkAllAliases(key, flags.nargs)) {
            error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
            return true;
          }
          return false;
        });
      }
      return {
        aliases: Object.assign({}, flags.aliases),
        argv: Object.assign(argvReturn, argv),
        configuration,
        defaulted: Object.assign({}, defaulted),
        error,
        newAliases: Object.assign({}, newAliases)
      };
    }
  }
  function combineAliases(aliases) {
    const aliasArrays = [];
    const combined = Object.create(null);
    let change = true;
    Object.keys(aliases).forEach(function(key) {
      aliasArrays.push([].concat(aliases[key], key));
    });
    while (change) {
      change = false;
      for (let i = 0;i < aliasArrays.length; i++) {
        for (let ii = i + 1;ii < aliasArrays.length; ii++) {
          const intersect = aliasArrays[i].filter(function(v) {
            return aliasArrays[ii].indexOf(v) !== -1;
          });
          if (intersect.length) {
            aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
            aliasArrays.splice(ii, 1);
            change = true;
            break;
          }
        }
      }
    }
    aliasArrays.forEach(function(aliasArray) {
      aliasArray = aliasArray.filter(function(v, i, self) {
        return self.indexOf(v) === i;
      });
      const lastAlias = aliasArray.pop();
      if (lastAlias !== undefined && typeof lastAlias === "string") {
        combined[lastAlias] = aliasArray;
      }
    });
    return combined;
  }
  function increment(orig) {
    return orig !== undefined ? orig + 1 : 1;
  }
  function sanitizeKey(key) {
    if (key === "__proto__")
      return "___proto___";
    return key;
  }
  function stripQuotes(val) {
    return typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;
  }
  var _a;
  var _b;
  var _c;
  var minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
  var nodeVersion = (_b = (_a = process === null || process === undefined ? undefined : process.versions) === null || _a === undefined ? undefined : _a.node) !== null && _b !== undefined ? _b : (_c = process === null || process === undefined ? undefined : process.version) === null || _c === undefined ? undefined : _c.slice(1);
  if (nodeVersion) {
    const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
    if (major < minNodeVersion) {
      throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
    }
  }
  var env = process ? process.env : {};
  var parser = new YargsParser({
    cwd: process.cwd,
    env: () => {
      return env;
    },
    format: util.format,
    normalize: path.normalize,
    resolve: path.resolve,
    require: (path2) => {
      if (true) {
        return import.meta.require(path2);
      } else
        ;
    }
  });
  var yargsParser = function Parser(args, opts) {
    const result = parser.parse(args.slice(), opts);
    return result.argv;
  };
  yargsParser.detailed = function(args, opts) {
    return parser.parse(args.slice(), opts);
  };
  yargsParser.camelCase = camelCase;
  yargsParser.decamelize = decamelize;
  yargsParser.looksLikeNumber = looksLikeNumber;
  module.exports = yargsParser;
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
  };
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex();
  module.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
});

// node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS((exports, module) => {
  var isFullwidthCodePoint = (codePoint) => {
    if (Number.isNaN(codePoint)) {
      return false;
    }
    if (codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141)) {
      return true;
    }
    return false;
  };
  module.exports = isFullwidthCodePoint;
  module.exports.default = isFullwidthCodePoint;
});

// node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS((exports, module) => {
  module.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// node_modules/string-width/index.js
var require_string_width = __commonJS((exports, module) => {
  var stripAnsi = require_strip_ansi();
  var isFullwidthCodePoint = require_is_fullwidth_code_point();
  var emojiRegex = require_emoji_regex();
  var stringWidth = (string) => {
    if (typeof string !== "string" || string.length === 0) {
      return 0;
    }
    string = stripAnsi(string);
    if (string.length === 0) {
      return 0;
    }
    string = string.replace(emojiRegex(), "  ");
    let width = 0;
    for (let i = 0;i < string.length; i++) {
      const code = string.codePointAt(i);
      if (code <= 31 || code >= 127 && code <= 159) {
        continue;
      }
      if (code >= 768 && code <= 879) {
        continue;
      }
      if (code > 65535) {
        i++;
      }
      width += isFullwidthCodePoint(code) ? 2 : 1;
    }
    return width;
  };
  module.exports = stringWidth;
  module.exports.default = stringWidth;
});

// node_modules/color-name/index.js
var require_color_name = __commonJS((exports, module) => {
  module.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports, module) => {
  var cssKeywords = require_color_name();
  var reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  var convert = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  module.exports = convert;
  for (const model of Object.keys(convert)) {
    if (!("channels" in convert[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels, labels } = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], "channels", { value: channels });
    Object.defineProperty(convert[model], "labels", { value: labels });
  }
  convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  }
  convert.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0;i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 0.0031308 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// node_modules/color-convert/route.js
var require_route = __commonJS((exports, module) => {
  var conversions = require_conversions();
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions);
    for (let len = models.length, i = 0;i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions[current]);
      for (let len = adjacents.length, i = 0;i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path = [graph[toModel].parent, toModel];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  }
  module.exports = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0;i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports, module) => {
  var conversions = require_conversions();
  var route = require_route();
  var convert = {};
  var models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i = 0;i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
    Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module.exports = convert;
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS((exports, module) => {
  var wrapAnsi16 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `\x1B[${code + offset}m`;
  };
  var wrapAnsi256 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `\x1B[${38 + offset};5;${code}m`;
  };
  var wrapAnsi16m = (fn, offset) => (...args) => {
    const rgb = fn(...args);
    return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  var ansi2ansi = (n) => n;
  var rgb2rgb = (r, g, b) => [r, g, b];
  var setLazyProperty = (object, property, get) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value = get();
        Object.defineProperty(object, property, {
          value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
  };
  var colorConvert;
  var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
    if (colorConvert === undefined) {
      colorConvert = require_color_convert();
    }
    const offset = isBackground ? 10 : 0;
    const styles = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
      const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
      if (sourceSpace === targetSpace) {
        styles[name] = wrap(identity, offset);
      } else if (typeof suite === "object") {
        styles[name] = wrap(suite[targetSpace], offset);
      }
    }
    return styles;
  };
  function assembleStyles() {
    const codes = new Map;
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles, "codes", {
      value: codes,
      enumerable: false
    });
    styles.color.close = "\x1B[39m";
    styles.bgColor.close = "\x1B[49m";
    setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
    setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
    return styles;
  }
  Object.defineProperty(module, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// node_modules/wrap-ansi/index.js
var require_wrap_ansi = __commonJS((exports, module) => {
  var stringWidth = require_string_width();
  var stripAnsi = require_strip_ansi();
  var ansiStyles = require_ansi_styles();
  var ESCAPES = new Set([
    "\x1B",
    "\x9B"
  ]);
  var END_CODE = 39;
  var ANSI_ESCAPE_BELL = "\x07";
  var ANSI_CSI = "[";
  var ANSI_OSC = "]";
  var ANSI_SGR_TERMINATOR = "m";
  var ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;
  var wrapAnsi = (code) => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
  var wrapAnsiHyperlink = (uri) => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;
  var wordLengths = (string) => string.split(" ").map((character) => stringWidth(character));
  var wrapWord = (rows, word, columns) => {
    const characters = [...word];
    let isInsideEscape = false;
    let isInsideLinkEscape = false;
    let visible = stringWidth(stripAnsi(rows[rows.length - 1]));
    for (const [index, character] of characters.entries()) {
      const characterLength = stringWidth(character);
      if (visible + characterLength <= columns) {
        rows[rows.length - 1] += character;
      } else {
        rows.push(character);
        visible = 0;
      }
      if (ESCAPES.has(character)) {
        isInsideEscape = true;
        isInsideLinkEscape = characters.slice(index + 1).join("").startsWith(ANSI_ESCAPE_LINK);
      }
      if (isInsideEscape) {
        if (isInsideLinkEscape) {
          if (character === ANSI_ESCAPE_BELL) {
            isInsideEscape = false;
            isInsideLinkEscape = false;
          }
        } else if (character === ANSI_SGR_TERMINATOR) {
          isInsideEscape = false;
        }
        continue;
      }
      visible += characterLength;
      if (visible === columns && index < characters.length - 1) {
        rows.push("");
        visible = 0;
      }
    }
    if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
      rows[rows.length - 2] += rows.pop();
    }
  };
  var stringVisibleTrimSpacesRight = (string) => {
    const words = string.split(" ");
    let last = words.length;
    while (last > 0) {
      if (stringWidth(words[last - 1]) > 0) {
        break;
      }
      last--;
    }
    if (last === words.length) {
      return string;
    }
    return words.slice(0, last).join(" ") + words.slice(last).join("");
  };
  var exec = (string, columns, options = {}) => {
    if (options.trim !== false && string.trim() === "") {
      return "";
    }
    let returnValue = "";
    let escapeCode;
    let escapeUrl;
    const lengths = wordLengths(string);
    let rows = [""];
    for (const [index, word] of string.split(" ").entries()) {
      if (options.trim !== false) {
        rows[rows.length - 1] = rows[rows.length - 1].trimStart();
      }
      let rowLength = stringWidth(rows[rows.length - 1]);
      if (index !== 0) {
        if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
          rows.push("");
          rowLength = 0;
        }
        if (rowLength > 0 || options.trim === false) {
          rows[rows.length - 1] += " ";
          rowLength++;
        }
      }
      if (options.hard && lengths[index] > columns) {
        const remainingColumns = columns - rowLength;
        const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
        const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
        if (breaksStartingNextLine < breaksStartingThisLine) {
          rows.push("");
        }
        wrapWord(rows, word, columns);
        continue;
      }
      if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
        if (options.wordWrap === false && rowLength < columns) {
          wrapWord(rows, word, columns);
          continue;
        }
        rows.push("");
      }
      if (rowLength + lengths[index] > columns && options.wordWrap === false) {
        wrapWord(rows, word, columns);
        continue;
      }
      rows[rows.length - 1] += word;
    }
    if (options.trim !== false) {
      rows = rows.map(stringVisibleTrimSpacesRight);
    }
    const pre = [...rows.join(`
`)];
    for (const [index, character] of pre.entries()) {
      returnValue += character;
      if (ESCAPES.has(character)) {
        const { groups } = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(pre.slice(index).join("")) || { groups: {} };
        if (groups.code !== undefined) {
          const code2 = Number.parseFloat(groups.code);
          escapeCode = code2 === END_CODE ? undefined : code2;
        } else if (groups.uri !== undefined) {
          escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;
        }
      }
      const code = ansiStyles.codes.get(Number(escapeCode));
      if (pre[index + 1] === `
`) {
        if (escapeUrl) {
          returnValue += wrapAnsiHyperlink("");
        }
        if (escapeCode && code) {
          returnValue += wrapAnsi(code);
        }
      } else if (character === `
`) {
        if (escapeCode && code) {
          returnValue += wrapAnsi(escapeCode);
        }
        if (escapeUrl) {
          returnValue += wrapAnsiHyperlink(escapeUrl);
        }
      }
    }
    return returnValue;
  };
  module.exports = (string, columns, options) => {
    return String(string).normalize().replace(/\r\n/g, `
`).split(`
`).map((line) => exec(line, columns, options)).join(`
`);
  };
});

// node_modules/cliui/build/index.cjs
var require_build3 = __commonJS((exports, module) => {
  var align = {
    right: alignRight,
    center: alignCenter
  };
  var top = 0;
  var right = 1;
  var bottom = 2;
  var left = 3;

  class UI {
    constructor(opts) {
      var _a;
      this.width = opts.width;
      this.wrap = (_a = opts.wrap) !== null && _a !== undefined ? _a : true;
      this.rows = [];
    }
    span(...args) {
      const cols = this.div(...args);
      cols.span = true;
    }
    resetOutput() {
      this.rows = [];
    }
    div(...args) {
      if (args.length === 0) {
        this.div("");
      }
      if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === "string") {
        return this.applyLayoutDSL(args[0]);
      }
      const cols = args.map((arg) => {
        if (typeof arg === "string") {
          return this.colFromString(arg);
        }
        return arg;
      });
      this.rows.push(cols);
      return cols;
    }
    shouldApplyLayoutDSL(...args) {
      return args.length === 1 && typeof args[0] === "string" && /[\t\n]/.test(args[0]);
    }
    applyLayoutDSL(str) {
      const rows = str.split(`
`).map((row) => row.split("\t"));
      let leftColumnWidth = 0;
      rows.forEach((columns) => {
        if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
          leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
        }
      });
      rows.forEach((columns) => {
        this.div(...columns.map((r, i) => {
          return {
            text: r.trim(),
            padding: this.measurePadding(r),
            width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined
          };
        }));
      });
      return this.rows[this.rows.length - 1];
    }
    colFromString(text) {
      return {
        text,
        padding: this.measurePadding(text)
      };
    }
    measurePadding(str) {
      const noAnsi = mixin.stripAnsi(str);
      return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
    }
    toString() {
      const lines = [];
      this.rows.forEach((row) => {
        this.rowToString(row, lines);
      });
      return lines.filter((line) => !line.hidden).map((line) => line.text).join(`
`);
    }
    rowToString(row, lines) {
      this.rasterize(row).forEach((rrow, r) => {
        let str = "";
        rrow.forEach((col, c) => {
          const { width } = row[c];
          const wrapWidth = this.negatePadding(row[c]);
          let ts = col;
          if (wrapWidth > mixin.stringWidth(col)) {
            ts += " ".repeat(wrapWidth - mixin.stringWidth(col));
          }
          if (row[c].align && row[c].align !== "left" && this.wrap) {
            const fn = align[row[c].align];
            ts = fn(ts, wrapWidth);
            if (mixin.stringWidth(ts) < wrapWidth) {
              ts += " ".repeat((width || 0) - mixin.stringWidth(ts) - 1);
            }
          }
          const padding = row[c].padding || [0, 0, 0, 0];
          if (padding[left]) {
            str += " ".repeat(padding[left]);
          }
          str += addBorder(row[c], ts, "| ");
          str += ts;
          str += addBorder(row[c], ts, " |");
          if (padding[right]) {
            str += " ".repeat(padding[right]);
          }
          if (r === 0 && lines.length > 0) {
            str = this.renderInline(str, lines[lines.length - 1]);
          }
        });
        lines.push({
          text: str.replace(/ +$/, ""),
          span: row.span
        });
      });
      return lines;
    }
    renderInline(source, previousLine) {
      const match = source.match(/^ */);
      const leadingWhitespace = match ? match[0].length : 0;
      const target = previousLine.text;
      const targetTextWidth = mixin.stringWidth(target.trimRight());
      if (!previousLine.span) {
        return source;
      }
      if (!this.wrap) {
        previousLine.hidden = true;
        return target + source;
      }
      if (leadingWhitespace < targetTextWidth) {
        return source;
      }
      previousLine.hidden = true;
      return target.trimRight() + " ".repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
    }
    rasterize(row) {
      const rrows = [];
      const widths = this.columnWidths(row);
      let wrapped;
      row.forEach((col, c) => {
        col.width = widths[c];
        if (this.wrap) {
          wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split(`
`);
        } else {
          wrapped = col.text.split(`
`);
        }
        if (col.border) {
          wrapped.unshift("." + "-".repeat(this.negatePadding(col) + 2) + ".");
          wrapped.push("'" + "-".repeat(this.negatePadding(col) + 2) + "'");
        }
        if (col.padding) {
          wrapped.unshift(...new Array(col.padding[top] || 0).fill(""));
          wrapped.push(...new Array(col.padding[bottom] || 0).fill(""));
        }
        wrapped.forEach((str, r) => {
          if (!rrows[r]) {
            rrows.push([]);
          }
          const rrow = rrows[r];
          for (let i = 0;i < c; i++) {
            if (rrow[i] === undefined) {
              rrow.push("");
            }
          }
          rrow.push(str);
        });
      });
      return rrows;
    }
    negatePadding(col) {
      let wrapWidth = col.width || 0;
      if (col.padding) {
        wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
      }
      if (col.border) {
        wrapWidth -= 4;
      }
      return wrapWidth;
    }
    columnWidths(row) {
      if (!this.wrap) {
        return row.map((col) => {
          return col.width || mixin.stringWidth(col.text);
        });
      }
      let unset = row.length;
      let remainingWidth = this.width;
      const widths = row.map((col) => {
        if (col.width) {
          unset--;
          remainingWidth -= col.width;
          return col.width;
        }
        return;
      });
      const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
      return widths.map((w, i) => {
        if (w === undefined) {
          return Math.max(unsetWidth, _minWidth(row[i]));
        }
        return w;
      });
    }
  }
  function addBorder(col, ts, style) {
    if (col.border) {
      if (/[.']-+[.']/.test(ts)) {
        return "";
      }
      if (ts.trim().length !== 0) {
        return style;
      }
      return "  ";
    }
    return "";
  }
  function _minWidth(col) {
    const padding = col.padding || [];
    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
    if (col.border) {
      return minWidth + 4;
    }
    return minWidth;
  }
  function getWindowWidth() {
    if (typeof process === "object" && process.stdout && process.stdout.columns) {
      return process.stdout.columns;
    }
    return 80;
  }
  function alignRight(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    if (strWidth < width) {
      return " ".repeat(width - strWidth) + str;
    }
    return str;
  }
  function alignCenter(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    if (strWidth >= width) {
      return str;
    }
    return " ".repeat(width - strWidth >> 1) + str;
  }
  var mixin;
  function cliui(opts, _mixin) {
    mixin = _mixin;
    return new UI({
      width: (opts === null || opts === undefined ? undefined : opts.width) || getWindowWidth(),
      wrap: opts === null || opts === undefined ? undefined : opts.wrap
    });
  }
  var stringWidth = require_string_width();
  var stripAnsi = require_strip_ansi();
  var wrap = require_wrap_ansi();
  function ui(opts) {
    return cliui(opts, {
      stringWidth,
      stripAnsi,
      wrap
    });
  }
  module.exports = ui;
});

// node_modules/escalade/sync/index.js
var require_sync = __commonJS((exports, module) => {
  var { dirname, resolve } = import.meta.require("path");
  var { readdirSync, statSync } = import.meta.require("fs");
  module.exports = function(start, callback) {
    let dir = resolve(".", start);
    let tmp, stats = statSync(dir);
    if (!stats.isDirectory()) {
      dir = dirname(dir);
    }
    while (true) {
      tmp = callback(dir, readdirSync(dir));
      if (tmp)
        return resolve(dir, tmp);
      dir = dirname(tmp = dir);
      if (tmp === dir)
        break;
    }
  };
});

// node_modules/get-caller-file/index.js
var require_get_caller_file = __commonJS((exports, module) => {
  module.exports = function getCallerFile(position) {
    if (position === undefined) {
      position = 2;
    }
    if (position >= Error.stackTraceLimit) {
      throw new TypeError("getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `" + position + "` and Error.stackTraceLimit was: `" + Error.stackTraceLimit + "`");
    }
    var oldPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function(_, stack2) {
      return stack2;
    };
    var stack = new Error().stack;
    Error.prepareStackTrace = oldPrepareStackTrace;
    if (stack !== null && typeof stack === "object") {
      return stack[position] ? stack[position].getFileName() : undefined;
    }
  };
});

// node_modules/require-directory/index.js
var require_require_directory = __commonJS((exports, module) => {
  var fs = import.meta.require("fs");
  var join = import.meta.require("path").join;
  var resolve = import.meta.require("path").resolve;
  var dirname = import.meta.require("path").dirname;
  var defaultOptions = {
    extensions: ["js", "json", "coffee"],
    recurse: true,
    rename: function(name) {
      return name;
    },
    visit: function(obj) {
      return obj;
    }
  };
  function checkFileInclusion(path, filename, options) {
    return new RegExp("\\.(" + options.extensions.join("|") + ")$", "i").test(filename) && !(options.include && options.include instanceof RegExp && !options.include.test(path)) && !(options.include && typeof options.include === "function" && !options.include(path, filename)) && !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) && !(options.exclude && typeof options.exclude === "function" && options.exclude(path, filename));
  }
  function requireDirectory(m, path, options) {
    var retval = {};
    if (path && !options && typeof path !== "string") {
      options = path;
      path = null;
    }
    options = options || {};
    for (var prop in defaultOptions) {
      if (typeof options[prop] === "undefined") {
        options[prop] = defaultOptions[prop];
      }
    }
    path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);
    fs.readdirSync(path).forEach(function(filename) {
      var joined = join(path, filename), files, key, obj;
      if (fs.statSync(joined).isDirectory() && options.recurse) {
        files = requireDirectory(m, joined, options);
        if (Object.keys(files).length) {
          retval[options.rename(filename, joined, filename)] = files;
        }
      } else {
        if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {
          key = filename.substring(0, filename.lastIndexOf("."));
          obj = m.require(joined);
          retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;
        }
      }
    });
    return retval;
  }
  module.exports = requireDirectory;
  module.exports.defaults = defaultOptions;
});

// node_modules/yargs/build/index.cjs
var require_build4 = __commonJS((exports, module) => {
  var __dirname = "yargs/build"
  var t = import.meta.require("assert");

  class e extends Error {
    constructor(t2) {
      super(t2 || "yargs error"), this.name = "YError", Error.captureStackTrace && Error.captureStackTrace(this, e);
    }
  }
  var s;
  var i = [];
  function n(t2, o2, a2, h2) {
    s = h2;
    let l2 = {};
    if (Object.prototype.hasOwnProperty.call(t2, "extends")) {
      if (typeof t2.extends != "string")
        return l2;
      const r2 = /\.json|\..*rc$/.test(t2.extends);
      let h3 = null;
      if (r2)
        h3 = function(t3, e2) {
          return s.path.resolve(t3, e2);
        }(o2, t2.extends);
      else
        try {
          h3 = import.meta.require.resolve(t2.extends);
        } catch (e2) {
          return t2;
        }
      (function(t3) {
        if (i.indexOf(t3) > -1)
          throw new e(`Circular extended configurations: '${t3}'.`);
      })(h3), i.push(h3), l2 = r2 ? JSON.parse(s.readFileSync(h3, "utf8")) : import.meta.require(t2.extends), delete t2.extends, l2 = n(l2, s.path.dirname(h3), a2, s);
    }
    return i = [], a2 ? r(l2, t2) : Object.assign({}, l2, t2);
  }
  function r(t2, e2) {
    const s2 = {};
    function i2(t3) {
      return t3 && typeof t3 == "object" && !Array.isArray(t3);
    }
    Object.assign(s2, t2);
    for (const n2 of Object.keys(e2))
      i2(e2[n2]) && i2(s2[n2]) ? s2[n2] = r(t2[n2], e2[n2]) : s2[n2] = e2[n2];
    return s2;
  }
  function o(t2) {
    const e2 = t2.replace(/\s{2,}/g, " ").split(/\s+(?![^[]*]|[^<]*>)/), s2 = /\.*[\][<>]/g, i2 = e2.shift();
    if (!i2)
      throw new Error(`No command found in: ${t2}`);
    const n2 = { cmd: i2.replace(s2, ""), demanded: [], optional: [] };
    return e2.forEach((t3, i3) => {
      let r2 = false;
      t3 = t3.replace(/\s/g, ""), /\.+[\]>]/.test(t3) && i3 === e2.length - 1 && (r2 = true), /^\[/.test(t3) ? n2.optional.push({ cmd: t3.replace(s2, "").split("|"), variadic: r2 }) : n2.demanded.push({ cmd: t3.replace(s2, "").split("|"), variadic: r2 });
    }), n2;
  }
  var a = ["first", "second", "third", "fourth", "fifth", "sixth"];
  function h(t2, s2, i2) {
    try {
      let n2 = 0;
      const [r2, a2, h2] = typeof t2 == "object" ? [{ demanded: [], optional: [] }, t2, s2] : [o(`cmd ${t2}`), s2, i2], f2 = [].slice.call(a2);
      for (;f2.length && f2[f2.length - 1] === undefined; )
        f2.pop();
      const d2 = h2 || f2.length;
      if (d2 < r2.demanded.length)
        throw new e(`Not enough arguments provided. Expected ${r2.demanded.length} but received ${f2.length}.`);
      const u2 = r2.demanded.length + r2.optional.length;
      if (d2 > u2)
        throw new e(`Too many arguments provided. Expected max ${u2} but received ${d2}.`);
      r2.demanded.forEach((t3) => {
        const e2 = l(f2.shift());
        t3.cmd.filter((t4) => t4 === e2 || t4 === "*").length === 0 && c(e2, t3.cmd, n2), n2 += 1;
      }), r2.optional.forEach((t3) => {
        if (f2.length === 0)
          return;
        const e2 = l(f2.shift());
        t3.cmd.filter((t4) => t4 === e2 || t4 === "*").length === 0 && c(e2, t3.cmd, n2), n2 += 1;
      });
    } catch (t3) {
      console.warn(t3.stack);
    }
  }
  function l(t2) {
    return Array.isArray(t2) ? "array" : t2 === null ? "null" : typeof t2;
  }
  function c(t2, s2, i2) {
    throw new e(`Invalid ${a[i2] || "manyith"} argument. Expected ${s2.join(" or ")} but received ${t2}.`);
  }
  function f(t2) {
    return !!t2 && !!t2.then && typeof t2.then == "function";
  }
  function d(t2, e2, s2, i2) {
    s2.assert.notStrictEqual(t2, e2, i2);
  }
  function u(t2, e2) {
    e2.assert.strictEqual(typeof t2, "string");
  }
  function p(t2) {
    return Object.keys(t2);
  }
  function g(t2 = {}, e2 = () => true) {
    const s2 = {};
    return p(t2).forEach((i2) => {
      e2(i2, t2[i2]) && (s2[i2] = t2[i2]);
    }), s2;
  }
  function m() {
    return process.versions.electron && !process.defaultApp ? 0 : 1;
  }
  function y() {
    return process.argv[m()];
  }
  var b = Object.freeze({ __proto__: null, hideBin: function(t2) {
    return t2.slice(m() + 1);
  }, getProcessArgvBin: y });
  function v(t2, e2, s2, i2) {
    if (s2 === "a" && !i2)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof e2 == "function" ? t2 !== e2 || !i2 : !e2.has(t2))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return s2 === "m" ? i2 : s2 === "a" ? i2.call(t2) : i2 ? i2.value : e2.get(t2);
  }
  function O(t2, e2, s2, i2, n2) {
    if (i2 === "m")
      throw new TypeError("Private method is not writable");
    if (i2 === "a" && !n2)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof e2 == "function" ? t2 !== e2 || !n2 : !e2.has(t2))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return i2 === "a" ? n2.call(t2, s2) : n2 ? n2.value = s2 : e2.set(t2, s2), s2;
  }

  class w {
    constructor(t2) {
      this.globalMiddleware = [], this.frozens = [], this.yargs = t2;
    }
    addMiddleware(t2, e2, s2 = true, i2 = false) {
      if (h("<array|function> [boolean] [boolean] [boolean]", [t2, e2, s2], arguments.length), Array.isArray(t2)) {
        for (let i3 = 0;i3 < t2.length; i3++) {
          if (typeof t2[i3] != "function")
            throw Error("middleware must be a function");
          const n2 = t2[i3];
          n2.applyBeforeValidation = e2, n2.global = s2;
        }
        Array.prototype.push.apply(this.globalMiddleware, t2);
      } else if (typeof t2 == "function") {
        const n2 = t2;
        n2.applyBeforeValidation = e2, n2.global = s2, n2.mutates = i2, this.globalMiddleware.push(t2);
      }
      return this.yargs;
    }
    addCoerceMiddleware(t2, e2) {
      const s2 = this.yargs.getAliases();
      return this.globalMiddleware = this.globalMiddleware.filter((t3) => {
        const i2 = [...s2[e2] || [], e2];
        return !t3.option || !i2.includes(t3.option);
      }), t2.option = e2, this.addMiddleware(t2, true, true, true);
    }
    getMiddleware() {
      return this.globalMiddleware;
    }
    freeze() {
      this.frozens.push([...this.globalMiddleware]);
    }
    unfreeze() {
      const t2 = this.frozens.pop();
      t2 !== undefined && (this.globalMiddleware = t2);
    }
    reset() {
      this.globalMiddleware = this.globalMiddleware.filter((t2) => t2.global);
    }
  }
  function C(t2, e2, s2, i2) {
    return s2.reduce((t3, s3) => {
      if (s3.applyBeforeValidation !== i2)
        return t3;
      if (s3.mutates) {
        if (s3.applied)
          return t3;
        s3.applied = true;
      }
      if (f(t3))
        return t3.then((t4) => Promise.all([t4, s3(t4, e2)])).then(([t4, e3]) => Object.assign(t4, e3));
      {
        const i3 = s3(t3, e2);
        return f(i3) ? i3.then((e3) => Object.assign(t3, e3)) : Object.assign(t3, i3);
      }
    }, t2);
  }
  function j(t2, e2, s2 = (t3) => {
    throw t3;
  }) {
    try {
      const s3 = typeof t2 == "function" ? t2() : t2;
      return f(s3) ? s3.then((t3) => e2(t3)) : e2(s3);
    } catch (t3) {
      return s2(t3);
    }
  }
  var M = /(^\*)|(^\$0)/;

  class _ {
    constructor(t2, e2, s2, i2) {
      this.requireCache = new Set, this.handlers = {}, this.aliasMap = {}, this.frozens = [], this.shim = i2, this.usage = t2, this.globalMiddleware = s2, this.validation = e2;
    }
    addDirectory(t2, e2, s2, i2) {
      typeof (i2 = i2 || {}).recurse != "boolean" && (i2.recurse = false), Array.isArray(i2.extensions) || (i2.extensions = ["js"]);
      const n2 = typeof i2.visit == "function" ? i2.visit : (t3) => t3;
      i2.visit = (t3, e3, s3) => {
        const i3 = n2(t3, e3, s3);
        if (i3) {
          if (this.requireCache.has(e3))
            return i3;
          this.requireCache.add(e3), this.addHandler(i3);
        }
        return i3;
      }, this.shim.requireDirectory({ require: e2, filename: s2 }, t2, i2);
    }
    addHandler(t2, e2, s2, i2, n2, r2) {
      let a2 = [];
      const h2 = function(t3) {
        return t3 ? t3.map((t4) => (t4.applyBeforeValidation = false, t4)) : [];
      }(n2);
      if (i2 = i2 || (() => {
      }), Array.isArray(t2))
        if (function(t3) {
          return t3.every((t4) => typeof t4 == "string");
        }(t2))
          [t2, ...a2] = t2;
        else
          for (const e3 of t2)
            this.addHandler(e3);
      else {
        if (function(t3) {
          return typeof t3 == "object" && !Array.isArray(t3);
        }(t2)) {
          let e3 = Array.isArray(t2.command) || typeof t2.command == "string" ? t2.command : this.moduleName(t2);
          return t2.aliases && (e3 = [].concat(e3).concat(t2.aliases)), void this.addHandler(e3, this.extractDesc(t2), t2.builder, t2.handler, t2.middlewares, t2.deprecated);
        }
        if (k(s2))
          return void this.addHandler([t2].concat(a2), e2, s2.builder, s2.handler, s2.middlewares, s2.deprecated);
      }
      if (typeof t2 == "string") {
        const n3 = o(t2);
        a2 = a2.map((t3) => o(t3).cmd);
        let l2 = false;
        const c2 = [n3.cmd].concat(a2).filter((t3) => !M.test(t3) || (l2 = true, false));
        c2.length === 0 && l2 && c2.push("$0"), l2 && (n3.cmd = c2[0], a2 = c2.slice(1), t2 = t2.replace(M, n3.cmd)), a2.forEach((t3) => {
          this.aliasMap[t3] = n3.cmd;
        }), e2 !== false && this.usage.command(t2, e2, l2, a2, r2), this.handlers[n3.cmd] = { original: t2, description: e2, handler: i2, builder: s2 || {}, middlewares: h2, deprecated: r2, demanded: n3.demanded, optional: n3.optional }, l2 && (this.defaultCommand = this.handlers[n3.cmd]);
      }
    }
    getCommandHandlers() {
      return this.handlers;
    }
    getCommands() {
      return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
    }
    hasDefaultCommand() {
      return !!this.defaultCommand;
    }
    runCommand(t2, e2, s2, i2, n2, r2) {
      const o2 = this.handlers[t2] || this.handlers[this.aliasMap[t2]] || this.defaultCommand, a2 = e2.getInternalMethods().getContext(), h2 = a2.commands.slice(), l2 = !t2;
      t2 && (a2.commands.push(t2), a2.fullCommands.push(o2.original));
      const c2 = this.applyBuilderUpdateUsageAndParse(l2, o2, e2, s2.aliases, h2, i2, n2, r2);
      return f(c2) ? c2.then((t3) => this.applyMiddlewareAndGetResult(l2, o2, t3.innerArgv, a2, n2, t3.aliases, e2)) : this.applyMiddlewareAndGetResult(l2, o2, c2.innerArgv, a2, n2, c2.aliases, e2);
    }
    applyBuilderUpdateUsageAndParse(t2, e2, s2, i2, n2, r2, o2, a2) {
      const h2 = e2.builder;
      let l2 = s2;
      if (x(h2)) {
        s2.getInternalMethods().getUsageInstance().freeze();
        const c2 = h2(s2.getInternalMethods().reset(i2), a2);
        if (f(c2))
          return c2.then((i3) => {
            var a3;
            return l2 = (a3 = i3) && typeof a3.getInternalMethods == "function" ? i3 : s2, this.parseAndUpdateUsage(t2, e2, l2, n2, r2, o2);
          });
      } else
        (function(t3) {
          return typeof t3 == "object";
        })(h2) && (s2.getInternalMethods().getUsageInstance().freeze(), l2 = s2.getInternalMethods().reset(i2), Object.keys(e2.builder).forEach((t3) => {
          l2.option(t3, h2[t3]);
        }));
      return this.parseAndUpdateUsage(t2, e2, l2, n2, r2, o2);
    }
    parseAndUpdateUsage(t2, e2, s2, i2, n2, r2) {
      t2 && s2.getInternalMethods().getUsageInstance().unfreeze(true), this.shouldUpdateUsage(s2) && s2.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(i2, e2), e2.description);
      const o2 = s2.getInternalMethods().runYargsParserAndExecuteCommands(null, undefined, true, n2, r2);
      return f(o2) ? o2.then((t3) => ({ aliases: s2.parsed.aliases, innerArgv: t3 })) : { aliases: s2.parsed.aliases, innerArgv: o2 };
    }
    shouldUpdateUsage(t2) {
      return !t2.getInternalMethods().getUsageInstance().getUsageDisabled() && t2.getInternalMethods().getUsageInstance().getUsage().length === 0;
    }
    usageFromParentCommandsCommandHandler(t2, e2) {
      const s2 = M.test(e2.original) ? e2.original.replace(M, "").trim() : e2.original, i2 = t2.filter((t3) => !M.test(t3));
      return i2.push(s2), `$0 ${i2.join(" ")}`;
    }
    handleValidationAndGetResult(t2, e2, s2, i2, n2, r2, o2, a2) {
      if (!r2.getInternalMethods().getHasOutput()) {
        const e3 = r2.getInternalMethods().runValidation(n2, a2, r2.parsed.error, t2);
        s2 = j(s2, (t3) => (e3(t3), t3));
      }
      if (e2.handler && !r2.getInternalMethods().getHasOutput()) {
        r2.getInternalMethods().setHasOutput();
        const i3 = !!r2.getOptions().configuration["populate--"];
        r2.getInternalMethods().postProcess(s2, i3, false, false), s2 = j(s2 = C(s2, r2, o2, false), (t3) => {
          const s3 = e2.handler(t3);
          return f(s3) ? s3.then(() => t3) : t3;
        }), t2 || r2.getInternalMethods().getUsageInstance().cacheHelpMessage(), f(s2) && !r2.getInternalMethods().hasParseCallback() && s2.catch((t3) => {
          try {
            r2.getInternalMethods().getUsageInstance().fail(null, t3);
          } catch (t4) {
          }
        });
      }
      return t2 || (i2.commands.pop(), i2.fullCommands.pop()), s2;
    }
    applyMiddlewareAndGetResult(t2, e2, s2, i2, n2, r2, o2) {
      let a2 = {};
      if (n2)
        return s2;
      o2.getInternalMethods().getHasOutput() || (a2 = this.populatePositionals(e2, s2, i2, o2));
      const h2 = this.globalMiddleware.getMiddleware().slice(0).concat(e2.middlewares), l2 = C(s2, o2, h2, true);
      return f(l2) ? l2.then((s3) => this.handleValidationAndGetResult(t2, e2, s3, i2, r2, o2, h2, a2)) : this.handleValidationAndGetResult(t2, e2, l2, i2, r2, o2, h2, a2);
    }
    populatePositionals(t2, e2, s2, i2) {
      e2._ = e2._.slice(s2.commands.length);
      const n2 = t2.demanded.slice(0), r2 = t2.optional.slice(0), o2 = {};
      for (this.validation.positionalCount(n2.length, e2._.length);n2.length; ) {
        const t3 = n2.shift();
        this.populatePositional(t3, e2, o2);
      }
      for (;r2.length; ) {
        const t3 = r2.shift();
        this.populatePositional(t3, e2, o2);
      }
      return e2._ = s2.commands.concat(e2._.map((t3) => "" + t3)), this.postProcessPositionals(e2, o2, this.cmdToParseOptions(t2.original), i2), o2;
    }
    populatePositional(t2, e2, s2) {
      const i2 = t2.cmd[0];
      t2.variadic ? s2[i2] = e2._.splice(0).map(String) : e2._.length && (s2[i2] = [String(e2._.shift())]);
    }
    cmdToParseOptions(t2) {
      const e2 = { array: [], default: {}, alias: {}, demand: {} }, s2 = o(t2);
      return s2.demanded.forEach((t3) => {
        const [s3, ...i2] = t3.cmd;
        t3.variadic && (e2.array.push(s3), e2.default[s3] = []), e2.alias[s3] = i2, e2.demand[s3] = true;
      }), s2.optional.forEach((t3) => {
        const [s3, ...i2] = t3.cmd;
        t3.variadic && (e2.array.push(s3), e2.default[s3] = []), e2.alias[s3] = i2;
      }), e2;
    }
    postProcessPositionals(t2, e2, s2, i2) {
      const n2 = Object.assign({}, i2.getOptions());
      n2.default = Object.assign(s2.default, n2.default);
      for (const t3 of Object.keys(s2.alias))
        n2.alias[t3] = (n2.alias[t3] || []).concat(s2.alias[t3]);
      n2.array = n2.array.concat(s2.array), n2.config = {};
      const r2 = [];
      if (Object.keys(e2).forEach((t3) => {
        e2[t3].map((e3) => {
          n2.configuration["unknown-options-as-args"] && (n2.key[t3] = true), r2.push(`--${t3}`), r2.push(e3);
        });
      }), !r2.length)
        return;
      const o2 = Object.assign({}, n2.configuration, { "populate--": false }), a2 = this.shim.Parser.detailed(r2, Object.assign({}, n2, { configuration: o2 }));
      if (a2.error)
        i2.getInternalMethods().getUsageInstance().fail(a2.error.message, a2.error);
      else {
        const s3 = Object.keys(e2);
        Object.keys(e2).forEach((t3) => {
          s3.push(...a2.aliases[t3]);
        }), Object.keys(a2.argv).forEach((n3) => {
          s3.includes(n3) && (e2[n3] || (e2[n3] = a2.argv[n3]), !this.isInConfigs(i2, n3) && !this.isDefaulted(i2, n3) && Object.prototype.hasOwnProperty.call(t2, n3) && Object.prototype.hasOwnProperty.call(a2.argv, n3) && (Array.isArray(t2[n3]) || Array.isArray(a2.argv[n3])) ? t2[n3] = [].concat(t2[n3], a2.argv[n3]) : t2[n3] = a2.argv[n3]);
        });
      }
    }
    isDefaulted(t2, e2) {
      const { default: s2 } = t2.getOptions();
      return Object.prototype.hasOwnProperty.call(s2, e2) || Object.prototype.hasOwnProperty.call(s2, this.shim.Parser.camelCase(e2));
    }
    isInConfigs(t2, e2) {
      const { configObjects: s2 } = t2.getOptions();
      return s2.some((t3) => Object.prototype.hasOwnProperty.call(t3, e2)) || s2.some((t3) => Object.prototype.hasOwnProperty.call(t3, this.shim.Parser.camelCase(e2)));
    }
    runDefaultBuilderOn(t2) {
      if (!this.defaultCommand)
        return;
      if (this.shouldUpdateUsage(t2)) {
        const e3 = M.test(this.defaultCommand.original) ? this.defaultCommand.original : this.defaultCommand.original.replace(/^[^[\]<>]*/, "$0 ");
        t2.getInternalMethods().getUsageInstance().usage(e3, this.defaultCommand.description);
      }
      const e2 = this.defaultCommand.builder;
      if (x(e2))
        return e2(t2, true);
      k(e2) || Object.keys(e2).forEach((s2) => {
        t2.option(s2, e2[s2]);
      });
    }
    moduleName(t2) {
      const e2 = function(t3) {
        if (false)
          ;
        for (let e3, s2 = 0, i2 = Object.keys(import.meta.require.cache);s2 < i2.length; s2++)
          if (e3 = import.meta.require.cache[i2[s2]], e3.exports === t3)
            return e3;
        return null;
      }(t2);
      if (!e2)
        throw new Error(`No command name given for module: ${this.shim.inspect(t2)}`);
      return this.commandFromFilename(e2.filename);
    }
    commandFromFilename(t2) {
      return this.shim.path.basename(t2, this.shim.path.extname(t2));
    }
    extractDesc({ describe: t2, description: e2, desc: s2 }) {
      for (const i2 of [t2, e2, s2]) {
        if (typeof i2 == "string" || i2 === false)
          return i2;
        d(i2, true, this.shim);
      }
      return false;
    }
    freeze() {
      this.frozens.push({ handlers: this.handlers, aliasMap: this.aliasMap, defaultCommand: this.defaultCommand });
    }
    unfreeze() {
      const t2 = this.frozens.pop();
      d(t2, undefined, this.shim), { handlers: this.handlers, aliasMap: this.aliasMap, defaultCommand: this.defaultCommand } = t2;
    }
    reset() {
      return this.handlers = {}, this.aliasMap = {}, this.defaultCommand = undefined, this.requireCache = new Set, this;
    }
  }
  function k(t2) {
    return typeof t2 == "object" && !!t2.builder && typeof t2.handler == "function";
  }
  function x(t2) {
    return typeof t2 == "function";
  }
  function E(t2) {
    typeof process != "undefined" && [process.stdout, process.stderr].forEach((e2) => {
      const s2 = e2;
      s2._handle && s2.isTTY && typeof s2._handle.setBlocking == "function" && s2._handle.setBlocking(t2);
    });
  }
  function A(t2) {
    return typeof t2 == "boolean";
  }
  function P(t2, s2) {
    const i2 = s2.y18n.__, n2 = {}, r2 = [];
    n2.failFn = function(t3) {
      r2.push(t3);
    };
    let o2 = null, a2 = null, h2 = true;
    n2.showHelpOnFail = function(e2 = true, s3) {
      const [i3, r3] = typeof e2 == "string" ? [true, e2] : [e2, s3];
      return t2.getInternalMethods().isGlobalContext() && (a2 = r3), o2 = r3, h2 = i3, n2;
    };
    let l2 = false;
    n2.fail = function(s3, i3) {
      const c3 = t2.getInternalMethods().getLoggerInstance();
      if (!r2.length) {
        if (t2.getExitProcess() && E(true), !l2) {
          l2 = true, h2 && (t2.showHelp("error"), c3.error()), (s3 || i3) && c3.error(s3 || i3);
          const e2 = o2 || a2;
          e2 && ((s3 || i3) && c3.error(""), c3.error(e2));
        }
        if (i3 = i3 || new e(s3), t2.getExitProcess())
          return t2.exit(1);
        if (t2.getInternalMethods().hasParseCallback())
          return t2.exit(1, i3);
        throw i3;
      }
      for (let t3 = r2.length - 1;t3 >= 0; --t3) {
        const e2 = r2[t3];
        if (A(e2)) {
          if (i3)
            throw i3;
          if (s3)
            throw Error(s3);
        } else
          e2(s3, i3, n2);
      }
    };
    let c2 = [], f2 = false;
    n2.usage = (t3, e2) => t3 === null ? (f2 = true, c2 = [], n2) : (f2 = false, c2.push([t3, e2 || ""]), n2), n2.getUsage = () => c2, n2.getUsageDisabled = () => f2, n2.getPositionalGroupName = () => i2("Positionals:");
    let d2 = [];
    n2.example = (t3, e2) => {
      d2.push([t3, e2 || ""]);
    };
    let u2 = [];
    n2.command = function(t3, e2, s3, i3, n3 = false) {
      s3 && (u2 = u2.map((t4) => (t4[2] = false, t4))), u2.push([t3, e2 || "", s3, i3, n3]);
    }, n2.getCommands = () => u2;
    let p2 = {};
    n2.describe = function(t3, e2) {
      Array.isArray(t3) ? t3.forEach((t4) => {
        n2.describe(t4, e2);
      }) : typeof t3 == "object" ? Object.keys(t3).forEach((e3) => {
        n2.describe(e3, t3[e3]);
      }) : p2[t3] = e2;
    }, n2.getDescriptions = () => p2;
    let m2 = [];
    n2.epilog = (t3) => {
      m2.push(t3);
    };
    let y2, b2 = false;
    n2.wrap = (t3) => {
      b2 = true, y2 = t3;
    }, n2.getWrap = () => s2.getEnv("YARGS_DISABLE_WRAP") ? null : (b2 || (y2 = function() {
      const t3 = 80;
      return s2.process.stdColumns ? Math.min(t3, s2.process.stdColumns) : t3;
    }(), b2 = true), y2);
    const v2 = "__yargsString__:";
    function O2(t3, e2, i3) {
      let n3 = 0;
      return Array.isArray(t3) || (t3 = Object.values(t3).map((t4) => [t4])), t3.forEach((t4) => {
        n3 = Math.max(s2.stringWidth(i3 ? `${i3} ${I(t4[0])}` : I(t4[0])) + $(t4[0]), n3);
      }), e2 && (n3 = Math.min(n3, parseInt((0.5 * e2).toString(), 10))), n3;
    }
    let w2;
    function C2(e2) {
      return t2.getOptions().hiddenOptions.indexOf(e2) < 0 || t2.parsed.argv[t2.getOptions().showHiddenOpt];
    }
    function j2(t3, e2) {
      let s3 = `[${i2("default:")} `;
      if (t3 === undefined && !e2)
        return null;
      if (e2)
        s3 += e2;
      else
        switch (typeof t3) {
          case "string":
            s3 += `"${t3}"`;
            break;
          case "object":
            s3 += JSON.stringify(t3);
            break;
          default:
            s3 += t3;
        }
      return `${s3}]`;
    }
    n2.deferY18nLookup = (t3) => v2 + t3, n2.help = function() {
      if (w2)
        return w2;
      (function() {
        const e3 = t2.getDemandedOptions(), s3 = t2.getOptions();
        (Object.keys(s3.alias) || []).forEach((i3) => {
          s3.alias[i3].forEach((r4) => {
            p2[r4] && n2.describe(i3, p2[r4]), r4 in e3 && t2.demandOption(i3, e3[r4]), s3.boolean.includes(r4) && t2.boolean(i3), s3.count.includes(r4) && t2.count(i3), s3.string.includes(r4) && t2.string(i3), s3.normalize.includes(r4) && t2.normalize(i3), s3.array.includes(r4) && t2.array(i3), s3.number.includes(r4) && t2.number(i3);
          });
        });
      })();
      const e2 = t2.customScriptName ? t2.$0 : s2.path.basename(t2.$0), r3 = t2.getDemandedOptions(), o3 = t2.getDemandedCommands(), a3 = t2.getDeprecatedOptions(), h3 = t2.getGroups(), l3 = t2.getOptions();
      let g2 = [];
      g2 = g2.concat(Object.keys(p2)), g2 = g2.concat(Object.keys(r3)), g2 = g2.concat(Object.keys(o3)), g2 = g2.concat(Object.keys(l3.default)), g2 = g2.filter(C2), g2 = Object.keys(g2.reduce((t3, e3) => (e3 !== "_" && (t3[e3] = true), t3), {}));
      const y3 = n2.getWrap(), b3 = s2.cliui({ width: y3, wrap: !!y3 });
      if (!f2) {
        if (c2.length)
          c2.forEach((t3) => {
            b3.div({ text: `${t3[0].replace(/\$0/g, e2)}` }), t3[1] && b3.div({ text: `${t3[1]}`, padding: [1, 0, 0, 0] });
          }), b3.div();
        else if (u2.length) {
          let t3 = null;
          t3 = o3._ ? `${e2} <${i2("command")}>
` : `${e2} [${i2("command")}]
`, b3.div(`${t3}`);
        }
      }
      if (u2.length > 1 || u2.length === 1 && !u2[0][2]) {
        b3.div(i2("Commands:"));
        const s3 = t2.getInternalMethods().getContext(), n3 = s3.commands.length ? `${s3.commands.join(" ")} ` : "";
        t2.getInternalMethods().getParserConfiguration()["sort-commands"] === true && (u2 = u2.sort((t3, e3) => t3[0].localeCompare(e3[0])));
        const r4 = e2 ? `${e2} ` : "";
        u2.forEach((t3) => {
          const s4 = `${r4}${n3}${t3[0].replace(/^\$0 ?/, "")}`;
          b3.span({ text: s4, padding: [0, 2, 0, 2], width: O2(u2, y3, `${e2}${n3}`) + 4 }, { text: t3[1] });
          const o4 = [];
          t3[2] && o4.push(`[${i2("default")}]`), t3[3] && t3[3].length && o4.push(`[${i2("aliases:")} ${t3[3].join(", ")}]`), t3[4] && (typeof t3[4] == "string" ? o4.push(`[${i2("deprecated: %s", t3[4])}]`) : o4.push(`[${i2("deprecated")}]`)), o4.length ? b3.div({ text: o4.join(" "), padding: [0, 0, 0, 2], align: "right" }) : b3.div();
        }), b3.div();
      }
      const M3 = (Object.keys(l3.alias) || []).concat(Object.keys(t2.parsed.newAliases) || []);
      g2 = g2.filter((e3) => !t2.parsed.newAliases[e3] && M3.every((t3) => (l3.alias[t3] || []).indexOf(e3) === -1));
      const _3 = i2("Options:");
      h3[_3] || (h3[_3] = []), function(t3, e3, s3, i3) {
        let n3 = [], r4 = null;
        Object.keys(s3).forEach((t4) => {
          n3 = n3.concat(s3[t4]);
        }), t3.forEach((t4) => {
          r4 = [t4].concat(e3[t4]), r4.some((t5) => n3.indexOf(t5) !== -1) || s3[i3].push(t4);
        });
      }(g2, l3.alias, h3, _3);
      const k2 = (t3) => /^--/.test(I(t3)), x2 = Object.keys(h3).filter((t3) => h3[t3].length > 0).map((t3) => ({ groupName: t3, normalizedKeys: h3[t3].filter(C2).map((t4) => {
        if (M3.includes(t4))
          return t4;
        for (let e3, s3 = 0;(e3 = M3[s3]) !== undefined; s3++)
          if ((l3.alias[e3] || []).includes(t4))
            return e3;
        return t4;
      }) })).filter(({ normalizedKeys: t3 }) => t3.length > 0).map(({ groupName: t3, normalizedKeys: e3 }) => {
        const s3 = e3.reduce((e4, s4) => (e4[s4] = [s4].concat(l3.alias[s4] || []).map((e5) => t3 === n2.getPositionalGroupName() ? e5 : (/^[0-9]$/.test(e5) ? l3.boolean.includes(s4) ? "-" : "--" : e5.length > 1 ? "--" : "-") + e5).sort((t4, e5) => k2(t4) === k2(e5) ? 0 : k2(t4) ? 1 : -1).join(", "), e4), {});
        return { groupName: t3, normalizedKeys: e3, switches: s3 };
      });
      if (x2.filter(({ groupName: t3 }) => t3 !== n2.getPositionalGroupName()).some(({ normalizedKeys: t3, switches: e3 }) => !t3.every((t4) => k2(e3[t4]))) && x2.filter(({ groupName: t3 }) => t3 !== n2.getPositionalGroupName()).forEach(({ normalizedKeys: t3, switches: e3 }) => {
        t3.forEach((t4) => {
          var s3, i3;
          k2(e3[t4]) && (e3[t4] = (s3 = e3[t4], i3 = 4, S(s3) ? { text: s3.text, indentation: s3.indentation + i3 } : { text: s3, indentation: i3 }));
        });
      }), x2.forEach(({ groupName: e3, normalizedKeys: s3, switches: o4 }) => {
        b3.div(e3), s3.forEach((e4) => {
          const s4 = o4[e4];
          let h4 = p2[e4] || "", c3 = null;
          h4.includes(v2) && (h4 = i2(h4.substring(16))), l3.boolean.includes(e4) && (c3 = `[${i2("boolean")}]`), l3.count.includes(e4) && (c3 = `[${i2("count")}]`), l3.string.includes(e4) && (c3 = `[${i2("string")}]`), l3.normalize.includes(e4) && (c3 = `[${i2("string")}]`), l3.array.includes(e4) && (c3 = `[${i2("array")}]`), l3.number.includes(e4) && (c3 = `[${i2("number")}]`);
          const f3 = [e4 in a3 ? (d3 = a3[e4], typeof d3 == "string" ? `[${i2("deprecated: %s", d3)}]` : `[${i2("deprecated")}]`) : null, c3, e4 in r3 ? `[${i2("required")}]` : null, l3.choices && l3.choices[e4] ? `[${i2("choices:")} ${n2.stringifiedValues(l3.choices[e4])}]` : null, j2(l3.default[e4], l3.defaultDescription[e4])].filter(Boolean).join(" ");
          var d3;
          b3.span({ text: I(s4), padding: [0, 2, 0, 2 + $(s4)], width: O2(o4, y3) + 4 }, h4);
          const u3 = t2.getInternalMethods().getUsageConfiguration()["hide-types"] === true;
          f3 && !u3 ? b3.div({ text: f3, padding: [0, 0, 0, 2], align: "right" }) : b3.div();
        }), b3.div();
      }), d2.length && (b3.div(i2("Examples:")), d2.forEach((t3) => {
        t3[0] = t3[0].replace(/\$0/g, e2);
      }), d2.forEach((t3) => {
        t3[1] === "" ? b3.div({ text: t3[0], padding: [0, 2, 0, 2] }) : b3.div({ text: t3[0], padding: [0, 2, 0, 2], width: O2(d2, y3) + 4 }, { text: t3[1] });
      }), b3.div()), m2.length > 0) {
        const t3 = m2.map((t4) => t4.replace(/\$0/g, e2)).join(`
`);
        b3.div(`${t3}
`);
      }
      return b3.toString().replace(/\s*$/, "");
    }, n2.cacheHelpMessage = function() {
      w2 = this.help();
    }, n2.clearCachedHelpMessage = function() {
      w2 = undefined;
    }, n2.hasCachedHelpMessage = function() {
      return !!w2;
    }, n2.showHelp = (e2) => {
      const s3 = t2.getInternalMethods().getLoggerInstance();
      e2 || (e2 = "error");
      (typeof e2 == "function" ? e2 : s3[e2])(n2.help());
    }, n2.functionDescription = (t3) => ["(", t3.name ? s2.Parser.decamelize(t3.name, "-") : i2("generated-value"), ")"].join(""), n2.stringifiedValues = function(t3, e2) {
      let s3 = "";
      const i3 = e2 || ", ", n3 = [].concat(t3);
      return t3 && n3.length ? (n3.forEach((t4) => {
        s3.length && (s3 += i3), s3 += JSON.stringify(t4);
      }), s3) : s3;
    };
    let M2 = null;
    n2.version = (t3) => {
      M2 = t3;
    }, n2.showVersion = (e2) => {
      const s3 = t2.getInternalMethods().getLoggerInstance();
      e2 || (e2 = "error");
      (typeof e2 == "function" ? e2 : s3[e2])(M2);
    }, n2.reset = function(t3) {
      return o2 = null, l2 = false, c2 = [], f2 = false, m2 = [], d2 = [], u2 = [], p2 = g(p2, (e2) => !t3[e2]), n2;
    };
    const _2 = [];
    return n2.freeze = function() {
      _2.push({ failMessage: o2, failureOutput: l2, usages: c2, usageDisabled: f2, epilogs: m2, examples: d2, commands: u2, descriptions: p2 });
    }, n2.unfreeze = function(t3 = false) {
      const e2 = _2.pop();
      e2 && (t3 ? (p2 = { ...e2.descriptions, ...p2 }, u2 = [...e2.commands, ...u2], c2 = [...e2.usages, ...c2], d2 = [...e2.examples, ...d2], m2 = [...e2.epilogs, ...m2]) : { failMessage: o2, failureOutput: l2, usages: c2, usageDisabled: f2, epilogs: m2, examples: d2, commands: u2, descriptions: p2 } = e2);
    }, n2;
  }
  function S(t2) {
    return typeof t2 == "object";
  }
  function $(t2) {
    return S(t2) ? t2.indentation : 0;
  }
  function I(t2) {
    return S(t2) ? t2.text : t2;
  }

  class D {
    constructor(t2, e2, s2, i2) {
      var n2, r2, o2;
      this.yargs = t2, this.usage = e2, this.command = s2, this.shim = i2, this.completionKey = "get-yargs-completions", this.aliases = null, this.customCompletionFunction = null, this.indexAfterLastReset = 0, this.zshShell = (o2 = ((n2 = this.shim.getEnv("SHELL")) === null || n2 === undefined ? undefined : n2.includes("zsh")) || ((r2 = this.shim.getEnv("ZSH_NAME")) === null || r2 === undefined ? undefined : r2.includes("zsh"))) !== null && o2 !== undefined && o2;
    }
    defaultCompletion(t2, e2, s2, i2) {
      const n2 = this.command.getCommandHandlers();
      for (let e3 = 0, s3 = t2.length;e3 < s3; ++e3)
        if (n2[t2[e3]] && n2[t2[e3]].builder) {
          const s4 = n2[t2[e3]].builder;
          if (x(s4)) {
            this.indexAfterLastReset = e3 + 1;
            const t3 = this.yargs.getInternalMethods().reset();
            return s4(t3, true), t3.argv;
          }
        }
      const r2 = [];
      this.commandCompletions(r2, t2, s2), this.optionCompletions(r2, t2, e2, s2), this.choicesFromOptionsCompletions(r2, t2, e2, s2), this.choicesFromPositionalsCompletions(r2, t2, e2, s2), i2(null, r2);
    }
    commandCompletions(t2, e2, s2) {
      const i2 = this.yargs.getInternalMethods().getContext().commands;
      s2.match(/^-/) || i2[i2.length - 1] === s2 || this.previousArgHasChoices(e2) || this.usage.getCommands().forEach((s3) => {
        const i3 = o(s3[0]).cmd;
        if (e2.indexOf(i3) === -1)
          if (this.zshShell) {
            const e3 = s3[1] || "";
            t2.push(i3.replace(/:/g, "\\:") + ":" + e3);
          } else
            t2.push(i3);
      });
    }
    optionCompletions(t2, e2, s2, i2) {
      if ((i2.match(/^-/) || i2 === "" && t2.length === 0) && !this.previousArgHasChoices(e2)) {
        const s3 = this.yargs.getOptions(), n2 = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
        Object.keys(s3.key).forEach((r2) => {
          const o2 = !!s3.configuration["boolean-negation"] && s3.boolean.includes(r2);
          n2.includes(r2) || s3.hiddenOptions.includes(r2) || this.argsContainKey(e2, r2, o2) || this.completeOptionKey(r2, t2, i2, o2 && !!s3.default[r2]);
        });
      }
    }
    choicesFromOptionsCompletions(t2, e2, s2, i2) {
      if (this.previousArgHasChoices(e2)) {
        const s3 = this.getPreviousArgChoices(e2);
        s3 && s3.length > 0 && t2.push(...s3.map((t3) => t3.replace(/:/g, "\\:")));
      }
    }
    choicesFromPositionalsCompletions(t2, e2, s2, i2) {
      if (i2 === "" && t2.length > 0 && this.previousArgHasChoices(e2))
        return;
      const n2 = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [], r2 = Math.max(this.indexAfterLastReset, this.yargs.getInternalMethods().getContext().commands.length + 1), o2 = n2[s2._.length - r2 - 1];
      if (!o2)
        return;
      const a2 = this.yargs.getOptions().choices[o2] || [];
      for (const e3 of a2)
        e3.startsWith(i2) && t2.push(e3.replace(/:/g, "\\:"));
    }
    getPreviousArgChoices(t2) {
      if (t2.length < 1)
        return;
      let e2 = t2[t2.length - 1], s2 = "";
      if (!e2.startsWith("-") && t2.length > 1 && (s2 = e2, e2 = t2[t2.length - 2]), !e2.startsWith("-"))
        return;
      const i2 = e2.replace(/^-+/, ""), n2 = this.yargs.getOptions(), r2 = [i2, ...this.yargs.getAliases()[i2] || []];
      let o2;
      for (const t3 of r2)
        if (Object.prototype.hasOwnProperty.call(n2.key, t3) && Array.isArray(n2.choices[t3])) {
          o2 = n2.choices[t3];
          break;
        }
      return o2 ? o2.filter((t3) => !s2 || t3.startsWith(s2)) : undefined;
    }
    previousArgHasChoices(t2) {
      const e2 = this.getPreviousArgChoices(t2);
      return e2 !== undefined && e2.length > 0;
    }
    argsContainKey(t2, e2, s2) {
      const i2 = (e3) => t2.indexOf((/^[^0-9]$/.test(e3) ? "-" : "--") + e3) !== -1;
      if (i2(e2))
        return true;
      if (s2 && i2(`no-${e2}`))
        return true;
      if (this.aliases) {
        for (const t3 of this.aliases[e2])
          if (i2(t3))
            return true;
      }
      return false;
    }
    completeOptionKey(t2, e2, s2, i2) {
      var n2, r2, o2, a2;
      let h2 = t2;
      if (this.zshShell) {
        const e3 = this.usage.getDescriptions(), s3 = (r2 = (n2 = this == null ? undefined : this.aliases) === null || n2 === undefined ? undefined : n2[t2]) === null || r2 === undefined ? undefined : r2.find((t3) => {
          const s4 = e3[t3];
          return typeof s4 == "string" && s4.length > 0;
        }), i3 = s3 ? e3[s3] : undefined, l3 = (a2 = (o2 = e3[t2]) !== null && o2 !== undefined ? o2 : i3) !== null && a2 !== undefined ? a2 : "";
        h2 = `${t2.replace(/:/g, "\\:")}:${l3.replace("__yargsString__:", "").replace(/(\r\n|\n|\r)/gm, " ")}`;
      }
      const l2 = !/^--/.test(s2) && ((t3) => /^[^0-9]$/.test(t3))(t2) ? "-" : "--";
      e2.push(l2 + h2), i2 && e2.push(l2 + "no-" + h2);
    }
    customCompletion(t2, e2, s2, i2) {
      if (d(this.customCompletionFunction, null, this.shim), this.customCompletionFunction.length < 3) {
        const t3 = this.customCompletionFunction(s2, e2);
        return f(t3) ? t3.then((t4) => {
          this.shim.process.nextTick(() => {
            i2(null, t4);
          });
        }).catch((t4) => {
          this.shim.process.nextTick(() => {
            i2(t4, undefined);
          });
        }) : i2(null, t3);
      }
      return function(t3) {
        return t3.length > 3;
      }(this.customCompletionFunction) ? this.customCompletionFunction(s2, e2, (n2 = i2) => this.defaultCompletion(t2, e2, s2, n2), (t3) => {
        i2(null, t3);
      }) : this.customCompletionFunction(s2, e2, (t3) => {
        i2(null, t3);
      });
    }
    getCompletion(t2, e2) {
      const s2 = t2.length ? t2[t2.length - 1] : "", i2 = this.yargs.parse(t2, true), n2 = this.customCompletionFunction ? (i3) => this.customCompletion(t2, i3, s2, e2) : (i3) => this.defaultCompletion(t2, i3, s2, e2);
      return f(i2) ? i2.then(n2) : n2(i2);
    }
    generateCompletionScript(t2, e2) {
      let s2 = this.zshShell ? `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zprofile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
` : `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o bashdefault -o default -F _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
      const i2 = this.shim.path.basename(t2);
      return t2.match(/\.js$/) && (t2 = `./${t2}`), s2 = s2.replace(/{{app_name}}/g, i2), s2 = s2.replace(/{{completion_command}}/g, e2), s2.replace(/{{app_path}}/g, t2);
    }
    registerFunction(t2) {
      this.customCompletionFunction = t2;
    }
    setParsed(t2) {
      this.aliases = t2.aliases;
    }
  }
  function N(t2, e2) {
    if (t2.length === 0)
      return e2.length;
    if (e2.length === 0)
      return t2.length;
    const s2 = [];
    let i2, n2;
    for (i2 = 0;i2 <= e2.length; i2++)
      s2[i2] = [i2];
    for (n2 = 0;n2 <= t2.length; n2++)
      s2[0][n2] = n2;
    for (i2 = 1;i2 <= e2.length; i2++)
      for (n2 = 1;n2 <= t2.length; n2++)
        e2.charAt(i2 - 1) === t2.charAt(n2 - 1) ? s2[i2][n2] = s2[i2 - 1][n2 - 1] : i2 > 1 && n2 > 1 && e2.charAt(i2 - 2) === t2.charAt(n2 - 1) && e2.charAt(i2 - 1) === t2.charAt(n2 - 2) ? s2[i2][n2] = s2[i2 - 2][n2 - 2] + 1 : s2[i2][n2] = Math.min(s2[i2 - 1][n2 - 1] + 1, Math.min(s2[i2][n2 - 1] + 1, s2[i2 - 1][n2] + 1));
    return s2[e2.length][t2.length];
  }
  var H = ["$0", "--", "_"];
  var z;
  var W;
  var q;
  var U;
  var F;
  var L;
  var V;
  var G;
  var R;
  var T;
  var B;
  var Y;
  var K;
  var J;
  var Z;
  var X;
  var Q;
  var tt;
  var et;
  var st;
  var it;
  var nt;
  var rt;
  var ot;
  var at;
  var ht;
  var lt;
  var ct;
  var ft;
  var dt;
  var ut;
  var pt;
  var gt;
  var mt;
  var yt;
  var bt = Symbol("copyDoubleDash");
  var vt = Symbol("copyDoubleDash");
  var Ot = Symbol("deleteFromParserHintObject");
  var wt = Symbol("emitWarning");
  var Ct = Symbol("freeze");
  var jt = Symbol("getDollarZero");
  var Mt = Symbol("getParserConfiguration");
  var _t = Symbol("getUsageConfiguration");
  var kt = Symbol("guessLocale");
  var xt = Symbol("guessVersion");
  var Et = Symbol("parsePositionalNumbers");
  var At = Symbol("pkgUp");
  var Pt = Symbol("populateParserHintArray");
  var St = Symbol("populateParserHintSingleValueDictionary");
  var $t = Symbol("populateParserHintArrayDictionary");
  var It = Symbol("populateParserHintDictionary");
  var Dt = Symbol("sanitizeKey");
  var Nt = Symbol("setKey");
  var Ht = Symbol("unfreeze");
  var zt = Symbol("validateAsync");
  var Wt = Symbol("getCommandInstance");
  var qt = Symbol("getContext");
  var Ut = Symbol("getHasOutput");
  var Ft = Symbol("getLoggerInstance");
  var Lt = Symbol("getParseContext");
  var Vt = Symbol("getUsageInstance");
  var Gt = Symbol("getValidationInstance");
  var Rt = Symbol("hasParseCallback");
  var Tt = Symbol("isGlobalContext");
  var Bt = Symbol("postProcess");
  var Yt = Symbol("rebase");
  var Kt = Symbol("reset");
  var Jt = Symbol("runYargsParserAndExecuteCommands");
  var Zt = Symbol("runValidation");
  var Xt = Symbol("setHasOutput");
  var Qt = Symbol("kTrackManuallySetKeys");

  class te {
    constructor(t2 = [], e2, s2, i2) {
      this.customScriptName = false, this.parsed = false, z.set(this, undefined), W.set(this, undefined), q.set(this, { commands: [], fullCommands: [] }), U.set(this, null), F.set(this, null), L.set(this, "show-hidden"), V.set(this, null), G.set(this, true), R.set(this, {}), T.set(this, true), B.set(this, []), Y.set(this, undefined), K.set(this, {}), J.set(this, false), Z.set(this, null), X.set(this, true), Q.set(this, undefined), tt.set(this, ""), et.set(this, undefined), st.set(this, undefined), it.set(this, {}), nt.set(this, null), rt.set(this, null), ot.set(this, {}), at.set(this, {}), ht.set(this, undefined), lt.set(this, false), ct.set(this, undefined), ft.set(this, false), dt.set(this, false), ut.set(this, false), pt.set(this, undefined), gt.set(this, {}), mt.set(this, null), yt.set(this, undefined), O(this, ct, i2, "f"), O(this, ht, t2, "f"), O(this, W, e2, "f"), O(this, st, s2, "f"), O(this, Y, new w(this), "f"), this.$0 = this[jt](), this[Kt](), O(this, z, v(this, z, "f"), "f"), O(this, pt, v(this, pt, "f"), "f"), O(this, yt, v(this, yt, "f"), "f"), O(this, et, v(this, et, "f"), "f"), v(this, et, "f").showHiddenOpt = v(this, L, "f"), O(this, Q, this[vt](), "f");
    }
    addHelpOpt(t2, e2) {
      return h("[string|boolean] [string]", [t2, e2], arguments.length), v(this, Z, "f") && (this[Ot](v(this, Z, "f")), O(this, Z, null, "f")), t2 === false && e2 === undefined || (O(this, Z, typeof t2 == "string" ? t2 : "help", "f"), this.boolean(v(this, Z, "f")), this.describe(v(this, Z, "f"), e2 || v(this, pt, "f").deferY18nLookup("Show help"))), this;
    }
    help(t2, e2) {
      return this.addHelpOpt(t2, e2);
    }
    addShowHiddenOpt(t2, e2) {
      if (h("[string|boolean] [string]", [t2, e2], arguments.length), t2 === false && e2 === undefined)
        return this;
      const s2 = typeof t2 == "string" ? t2 : v(this, L, "f");
      return this.boolean(s2), this.describe(s2, e2 || v(this, pt, "f").deferY18nLookup("Show hidden options")), v(this, et, "f").showHiddenOpt = s2, this;
    }
    showHidden(t2, e2) {
      return this.addShowHiddenOpt(t2, e2);
    }
    alias(t2, e2) {
      return h("<object|string|array> [string|array]", [t2, e2], arguments.length), this[$t](this.alias.bind(this), "alias", t2, e2), this;
    }
    array(t2) {
      return h("<array|string>", [t2], arguments.length), this[Pt]("array", t2), this[Qt](t2), this;
    }
    boolean(t2) {
      return h("<array|string>", [t2], arguments.length), this[Pt]("boolean", t2), this[Qt](t2), this;
    }
    check(t2, e2) {
      return h("<function> [boolean]", [t2, e2], arguments.length), this.middleware((e3, s2) => j(() => t2(e3, s2.getOptions()), (s3) => (s3 ? (typeof s3 == "string" || s3 instanceof Error) && v(this, pt, "f").fail(s3.toString(), s3) : v(this, pt, "f").fail(v(this, ct, "f").y18n.__("Argument check failed: %s", t2.toString())), e3), (t3) => (v(this, pt, "f").fail(t3.message ? t3.message : t3.toString(), t3), e3)), false, e2), this;
    }
    choices(t2, e2) {
      return h("<object|string|array> [string|array]", [t2, e2], arguments.length), this[$t](this.choices.bind(this), "choices", t2, e2), this;
    }
    coerce(t2, s2) {
      if (h("<object|string|array> [function]", [t2, s2], arguments.length), Array.isArray(t2)) {
        if (!s2)
          throw new e("coerce callback must be provided");
        for (const e2 of t2)
          this.coerce(e2, s2);
        return this;
      }
      if (typeof t2 == "object") {
        for (const e2 of Object.keys(t2))
          this.coerce(e2, t2[e2]);
        return this;
      }
      if (!s2)
        throw new e("coerce callback must be provided");
      return v(this, et, "f").key[t2] = true, v(this, Y, "f").addCoerceMiddleware((i2, n2) => {
        let r2;
        return Object.prototype.hasOwnProperty.call(i2, t2) ? j(() => (r2 = n2.getAliases(), s2(i2[t2])), (e2) => {
          i2[t2] = e2;
          const s3 = n2.getInternalMethods().getParserConfiguration()["strip-aliased"];
          if (r2[t2] && s3 !== true)
            for (const s4 of r2[t2])
              i2[s4] = e2;
          return i2;
        }, (t3) => {
          throw new e(t3.message);
        }) : i2;
      }, t2), this;
    }
    conflicts(t2, e2) {
      return h("<string|object> [string|array]", [t2, e2], arguments.length), v(this, yt, "f").conflicts(t2, e2), this;
    }
    config(t2 = "config", e2, s2) {
      return h("[object|string] [string|function] [function]", [t2, e2, s2], arguments.length), typeof t2 != "object" || Array.isArray(t2) ? (typeof e2 == "function" && (s2 = e2, e2 = undefined), this.describe(t2, e2 || v(this, pt, "f").deferY18nLookup("Path to JSON config file")), (Array.isArray(t2) ? t2 : [t2]).forEach((t3) => {
        v(this, et, "f").config[t3] = s2 || true;
      }), this) : (t2 = n(t2, v(this, W, "f"), this[Mt]()["deep-merge-config"] || false, v(this, ct, "f")), v(this, et, "f").configObjects = (v(this, et, "f").configObjects || []).concat(t2), this);
    }
    completion(t2, e2, s2) {
      return h("[string] [string|boolean|function] [function]", [t2, e2, s2], arguments.length), typeof e2 == "function" && (s2 = e2, e2 = undefined), O(this, F, t2 || v(this, F, "f") || "completion", "f"), e2 || e2 === false || (e2 = "generate completion script"), this.command(v(this, F, "f"), e2), s2 && v(this, U, "f").registerFunction(s2), this;
    }
    command(t2, e2, s2, i2, n2, r2) {
      return h("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]", [t2, e2, s2, i2, n2, r2], arguments.length), v(this, z, "f").addHandler(t2, e2, s2, i2, n2, r2), this;
    }
    commands(t2, e2, s2, i2, n2, r2) {
      return this.command(t2, e2, s2, i2, n2, r2);
    }
    commandDir(t2, e2) {
      h("<string> [object]", [t2, e2], arguments.length);
      const s2 = v(this, st, "f") || v(this, ct, "f").require;
      return v(this, z, "f").addDirectory(t2, s2, v(this, ct, "f").getCallerFile(), e2), this;
    }
    count(t2) {
      return h("<array|string>", [t2], arguments.length), this[Pt]("count", t2), this[Qt](t2), this;
    }
    default(t2, e2, s2) {
      return h("<object|string|array> [*] [string]", [t2, e2, s2], arguments.length), s2 && (u(t2, v(this, ct, "f")), v(this, et, "f").defaultDescription[t2] = s2), typeof e2 == "function" && (u(t2, v(this, ct, "f")), v(this, et, "f").defaultDescription[t2] || (v(this, et, "f").defaultDescription[t2] = v(this, pt, "f").functionDescription(e2)), e2 = e2.call()), this[St](this.default.bind(this), "default", t2, e2), this;
    }
    defaults(t2, e2, s2) {
      return this.default(t2, e2, s2);
    }
    demandCommand(t2 = 1, e2, s2, i2) {
      return h("[number] [number|string] [string|null|undefined] [string|null|undefined]", [t2, e2, s2, i2], arguments.length), typeof e2 != "number" && (s2 = e2, e2 = 1 / 0), this.global("_", false), v(this, et, "f").demandedCommands._ = { min: t2, max: e2, minMsg: s2, maxMsg: i2 }, this;
    }
    demand(t2, e2, s2) {
      return Array.isArray(e2) ? (e2.forEach((t3) => {
        d(s2, true, v(this, ct, "f")), this.demandOption(t3, s2);
      }), e2 = 1 / 0) : typeof e2 != "number" && (s2 = e2, e2 = 1 / 0), typeof t2 == "number" ? (d(s2, true, v(this, ct, "f")), this.demandCommand(t2, e2, s2, s2)) : Array.isArray(t2) ? t2.forEach((t3) => {
        d(s2, true, v(this, ct, "f")), this.demandOption(t3, s2);
      }) : typeof s2 == "string" ? this.demandOption(t2, s2) : s2 !== true && s2 !== undefined || this.demandOption(t2), this;
    }
    demandOption(t2, e2) {
      return h("<object|string|array> [string]", [t2, e2], arguments.length), this[St](this.demandOption.bind(this), "demandedOptions", t2, e2), this;
    }
    deprecateOption(t2, e2) {
      return h("<string> [string|boolean]", [t2, e2], arguments.length), v(this, et, "f").deprecatedOptions[t2] = e2, this;
    }
    describe(t2, e2) {
      return h("<object|string|array> [string]", [t2, e2], arguments.length), this[Nt](t2, true), v(this, pt, "f").describe(t2, e2), this;
    }
    detectLocale(t2) {
      return h("<boolean>", [t2], arguments.length), O(this, G, t2, "f"), this;
    }
    env(t2) {
      return h("[string|boolean]", [t2], arguments.length), t2 === false ? delete v(this, et, "f").envPrefix : v(this, et, "f").envPrefix = t2 || "", this;
    }
    epilogue(t2) {
      return h("<string>", [t2], arguments.length), v(this, pt, "f").epilog(t2), this;
    }
    epilog(t2) {
      return this.epilogue(t2);
    }
    example(t2, e2) {
      return h("<string|array> [string]", [t2, e2], arguments.length), Array.isArray(t2) ? t2.forEach((t3) => this.example(...t3)) : v(this, pt, "f").example(t2, e2), this;
    }
    exit(t2, e2) {
      O(this, J, true, "f"), O(this, V, e2, "f"), v(this, T, "f") && v(this, ct, "f").process.exit(t2);
    }
    exitProcess(t2 = true) {
      return h("[boolean]", [t2], arguments.length), O(this, T, t2, "f"), this;
    }
    fail(t2) {
      if (h("<function|boolean>", [t2], arguments.length), typeof t2 == "boolean" && t2 !== false)
        throw new e("Invalid first argument. Expected function or boolean 'false'");
      return v(this, pt, "f").failFn(t2), this;
    }
    getAliases() {
      return this.parsed ? this.parsed.aliases : {};
    }
    async getCompletion(t2, e2) {
      return h("<array> [function]", [t2, e2], arguments.length), e2 ? v(this, U, "f").getCompletion(t2, e2) : new Promise((e3, s2) => {
        v(this, U, "f").getCompletion(t2, (t3, i2) => {
          t3 ? s2(t3) : e3(i2);
        });
      });
    }
    getDemandedOptions() {
      return h([], 0), v(this, et, "f").demandedOptions;
    }
    getDemandedCommands() {
      return h([], 0), v(this, et, "f").demandedCommands;
    }
    getDeprecatedOptions() {
      return h([], 0), v(this, et, "f").deprecatedOptions;
    }
    getDetectLocale() {
      return v(this, G, "f");
    }
    getExitProcess() {
      return v(this, T, "f");
    }
    getGroups() {
      return Object.assign({}, v(this, K, "f"), v(this, at, "f"));
    }
    getHelp() {
      if (O(this, J, true, "f"), !v(this, pt, "f").hasCachedHelpMessage()) {
        if (!this.parsed) {
          const t3 = this[Jt](v(this, ht, "f"), undefined, undefined, 0, true);
          if (f(t3))
            return t3.then(() => v(this, pt, "f").help());
        }
        const t2 = v(this, z, "f").runDefaultBuilderOn(this);
        if (f(t2))
          return t2.then(() => v(this, pt, "f").help());
      }
      return Promise.resolve(v(this, pt, "f").help());
    }
    getOptions() {
      return v(this, et, "f");
    }
    getStrict() {
      return v(this, ft, "f");
    }
    getStrictCommands() {
      return v(this, dt, "f");
    }
    getStrictOptions() {
      return v(this, ut, "f");
    }
    global(t2, e2) {
      return h("<string|array> [boolean]", [t2, e2], arguments.length), t2 = [].concat(t2), e2 !== false ? v(this, et, "f").local = v(this, et, "f").local.filter((e3) => t2.indexOf(e3) === -1) : t2.forEach((t3) => {
        v(this, et, "f").local.includes(t3) || v(this, et, "f").local.push(t3);
      }), this;
    }
    group(t2, e2) {
      h("<string|array> <string>", [t2, e2], arguments.length);
      const s2 = v(this, at, "f")[e2] || v(this, K, "f")[e2];
      v(this, at, "f")[e2] && delete v(this, at, "f")[e2];
      const i2 = {};
      return v(this, K, "f")[e2] = (s2 || []).concat(t2).filter((t3) => !i2[t3] && (i2[t3] = true)), this;
    }
    hide(t2) {
      return h("<string>", [t2], arguments.length), v(this, et, "f").hiddenOptions.push(t2), this;
    }
    implies(t2, e2) {
      return h("<string|object> [number|string|array]", [t2, e2], arguments.length), v(this, yt, "f").implies(t2, e2), this;
    }
    locale(t2) {
      return h("[string]", [t2], arguments.length), t2 === undefined ? (this[kt](), v(this, ct, "f").y18n.getLocale()) : (O(this, G, false, "f"), v(this, ct, "f").y18n.setLocale(t2), this);
    }
    middleware(t2, e2, s2) {
      return v(this, Y, "f").addMiddleware(t2, !!e2, s2);
    }
    nargs(t2, e2) {
      return h("<string|object|array> [number]", [t2, e2], arguments.length), this[St](this.nargs.bind(this), "narg", t2, e2), this;
    }
    normalize(t2) {
      return h("<array|string>", [t2], arguments.length), this[Pt]("normalize", t2), this;
    }
    number(t2) {
      return h("<array|string>", [t2], arguments.length), this[Pt]("number", t2), this[Qt](t2), this;
    }
    option(t2, e2) {
      if (h("<string|object> [object]", [t2, e2], arguments.length), typeof t2 == "object")
        Object.keys(t2).forEach((e3) => {
          this.options(e3, t2[e3]);
        });
      else {
        typeof e2 != "object" && (e2 = {}), this[Qt](t2), !v(this, mt, "f") || t2 !== "version" && (e2 == null ? undefined : e2.alias) !== "version" || this[wt](['"version" is a reserved word.', "Please do one of the following:", '- Disable version with `yargs.version(false)` if using "version" as an option', "- Use the built-in `yargs.version` method instead (if applicable)", "- Use a different option key", "https://yargs.js.org/docs/#api-reference-version"].join(`
`), undefined, "versionWarning"), v(this, et, "f").key[t2] = true, e2.alias && this.alias(t2, e2.alias);
        const s2 = e2.deprecate || e2.deprecated;
        s2 && this.deprecateOption(t2, s2);
        const i2 = e2.demand || e2.required || e2.require;
        i2 && this.demand(t2, i2), e2.demandOption && this.demandOption(t2, typeof e2.demandOption == "string" ? e2.demandOption : undefined), e2.conflicts && this.conflicts(t2, e2.conflicts), "default" in e2 && this.default(t2, e2.default), e2.implies !== undefined && this.implies(t2, e2.implies), e2.nargs !== undefined && this.nargs(t2, e2.nargs), e2.config && this.config(t2, e2.configParser), e2.normalize && this.normalize(t2), e2.choices && this.choices(t2, e2.choices), e2.coerce && this.coerce(t2, e2.coerce), e2.group && this.group(t2, e2.group), (e2.boolean || e2.type === "boolean") && (this.boolean(t2), e2.alias && this.boolean(e2.alias)), (e2.array || e2.type === "array") && (this.array(t2), e2.alias && this.array(e2.alias)), (e2.number || e2.type === "number") && (this.number(t2), e2.alias && this.number(e2.alias)), (e2.string || e2.type === "string") && (this.string(t2), e2.alias && this.string(e2.alias)), (e2.count || e2.type === "count") && this.count(t2), typeof e2.global == "boolean" && this.global(t2, e2.global), e2.defaultDescription && (v(this, et, "f").defaultDescription[t2] = e2.defaultDescription), e2.skipValidation && this.skipValidation(t2);
        const n2 = e2.describe || e2.description || e2.desc, r2 = v(this, pt, "f").getDescriptions();
        Object.prototype.hasOwnProperty.call(r2, t2) && typeof n2 != "string" || this.describe(t2, n2), e2.hidden && this.hide(t2), e2.requiresArg && this.requiresArg(t2);
      }
      return this;
    }
    options(t2, e2) {
      return this.option(t2, e2);
    }
    parse(t2, e2, s2) {
      h("[string|array] [function|boolean|object] [function]", [t2, e2, s2], arguments.length), this[Ct](), t2 === undefined && (t2 = v(this, ht, "f")), typeof e2 == "object" && (O(this, rt, e2, "f"), e2 = s2), typeof e2 == "function" && (O(this, nt, e2, "f"), e2 = false), e2 || O(this, ht, t2, "f"), v(this, nt, "f") && O(this, T, false, "f");
      const i2 = this[Jt](t2, !!e2), n2 = this.parsed;
      return v(this, U, "f").setParsed(this.parsed), f(i2) ? i2.then((t3) => (v(this, nt, "f") && v(this, nt, "f").call(this, v(this, V, "f"), t3, v(this, tt, "f")), t3)).catch((t3) => {
        throw v(this, nt, "f") && v(this, nt, "f")(t3, this.parsed.argv, v(this, tt, "f")), t3;
      }).finally(() => {
        this[Ht](), this.parsed = n2;
      }) : (v(this, nt, "f") && v(this, nt, "f").call(this, v(this, V, "f"), i2, v(this, tt, "f")), this[Ht](), this.parsed = n2, i2);
    }
    parseAsync(t2, e2, s2) {
      const i2 = this.parse(t2, e2, s2);
      return f(i2) ? i2 : Promise.resolve(i2);
    }
    parseSync(t2, s2, i2) {
      const n2 = this.parse(t2, s2, i2);
      if (f(n2))
        throw new e(".parseSync() must not be used with asynchronous builders, handlers, or middleware");
      return n2;
    }
    parserConfiguration(t2) {
      return h("<object>", [t2], arguments.length), O(this, it, t2, "f"), this;
    }
    pkgConf(t2, e2) {
      h("<string> [string]", [t2, e2], arguments.length);
      let s2 = null;
      const i2 = this[At](e2 || v(this, W, "f"));
      return i2[t2] && typeof i2[t2] == "object" && (s2 = n(i2[t2], e2 || v(this, W, "f"), this[Mt]()["deep-merge-config"] || false, v(this, ct, "f")), v(this, et, "f").configObjects = (v(this, et, "f").configObjects || []).concat(s2)), this;
    }
    positional(t2, e2) {
      h("<string> <object>", [t2, e2], arguments.length);
      const s2 = ["default", "defaultDescription", "implies", "normalize", "choices", "conflicts", "coerce", "type", "describe", "desc", "description", "alias"];
      e2 = g(e2, (t3, e3) => !(t3 === "type" && !["string", "number", "boolean"].includes(e3)) && s2.includes(t3));
      const i2 = v(this, q, "f").fullCommands[v(this, q, "f").fullCommands.length - 1], n2 = i2 ? v(this, z, "f").cmdToParseOptions(i2) : { array: [], alias: {}, default: {}, demand: {} };
      return p(n2).forEach((s3) => {
        const i3 = n2[s3];
        Array.isArray(i3) ? i3.indexOf(t2) !== -1 && (e2[s3] = true) : i3[t2] && !(s3 in e2) && (e2[s3] = i3[t2]);
      }), this.group(t2, v(this, pt, "f").getPositionalGroupName()), this.option(t2, e2);
    }
    recommendCommands(t2 = true) {
      return h("[boolean]", [t2], arguments.length), O(this, lt, t2, "f"), this;
    }
    required(t2, e2, s2) {
      return this.demand(t2, e2, s2);
    }
    require(t2, e2, s2) {
      return this.demand(t2, e2, s2);
    }
    requiresArg(t2) {
      return h("<array|string|object> [number]", [t2], arguments.length), typeof t2 == "string" && v(this, et, "f").narg[t2] || this[St](this.requiresArg.bind(this), "narg", t2, NaN), this;
    }
    showCompletionScript(t2, e2) {
      return h("[string] [string]", [t2, e2], arguments.length), t2 = t2 || this.$0, v(this, Q, "f").log(v(this, U, "f").generateCompletionScript(t2, e2 || v(this, F, "f") || "completion")), this;
    }
    showHelp(t2) {
      if (h("[string|function]", [t2], arguments.length), O(this, J, true, "f"), !v(this, pt, "f").hasCachedHelpMessage()) {
        if (!this.parsed) {
          const e3 = this[Jt](v(this, ht, "f"), undefined, undefined, 0, true);
          if (f(e3))
            return e3.then(() => {
              v(this, pt, "f").showHelp(t2);
            }), this;
        }
        const e2 = v(this, z, "f").runDefaultBuilderOn(this);
        if (f(e2))
          return e2.then(() => {
            v(this, pt, "f").showHelp(t2);
          }), this;
      }
      return v(this, pt, "f").showHelp(t2), this;
    }
    scriptName(t2) {
      return this.customScriptName = true, this.$0 = t2, this;
    }
    showHelpOnFail(t2, e2) {
      return h("[boolean|string] [string]", [t2, e2], arguments.length), v(this, pt, "f").showHelpOnFail(t2, e2), this;
    }
    showVersion(t2) {
      return h("[string|function]", [t2], arguments.length), v(this, pt, "f").showVersion(t2), this;
    }
    skipValidation(t2) {
      return h("<array|string>", [t2], arguments.length), this[Pt]("skipValidation", t2), this;
    }
    strict(t2) {
      return h("[boolean]", [t2], arguments.length), O(this, ft, t2 !== false, "f"), this;
    }
    strictCommands(t2) {
      return h("[boolean]", [t2], arguments.length), O(this, dt, t2 !== false, "f"), this;
    }
    strictOptions(t2) {
      return h("[boolean]", [t2], arguments.length), O(this, ut, t2 !== false, "f"), this;
    }
    string(t2) {
      return h("<array|string>", [t2], arguments.length), this[Pt]("string", t2), this[Qt](t2), this;
    }
    terminalWidth() {
      return h([], 0), v(this, ct, "f").process.stdColumns;
    }
    updateLocale(t2) {
      return this.updateStrings(t2);
    }
    updateStrings(t2) {
      return h("<object>", [t2], arguments.length), O(this, G, false, "f"), v(this, ct, "f").y18n.updateLocale(t2), this;
    }
    usage(t2, s2, i2, n2) {
      if (h("<string|null|undefined> [string|boolean] [function|object] [function]", [t2, s2, i2, n2], arguments.length), s2 !== undefined) {
        if (d(t2, null, v(this, ct, "f")), (t2 || "").match(/^\$0( |$)/))
          return this.command(t2, s2, i2, n2);
        throw new e(".usage() description must start with $0 if being used as alias for .command()");
      }
      return v(this, pt, "f").usage(t2), this;
    }
    usageConfiguration(t2) {
      return h("<object>", [t2], arguments.length), O(this, gt, t2, "f"), this;
    }
    version(t2, e2, s2) {
      const i2 = "version";
      if (h("[boolean|string] [string] [string]", [t2, e2, s2], arguments.length), v(this, mt, "f") && (this[Ot](v(this, mt, "f")), v(this, pt, "f").version(undefined), O(this, mt, null, "f")), arguments.length === 0)
        s2 = this[xt](), t2 = i2;
      else if (arguments.length === 1) {
        if (t2 === false)
          return this;
        s2 = t2, t2 = i2;
      } else
        arguments.length === 2 && (s2 = e2, e2 = undefined);
      return O(this, mt, typeof t2 == "string" ? t2 : i2, "f"), e2 = e2 || v(this, pt, "f").deferY18nLookup("Show version number"), v(this, pt, "f").version(s2 || undefined), this.boolean(v(this, mt, "f")), this.describe(v(this, mt, "f"), e2), this;
    }
    wrap(t2) {
      return h("<number|null|undefined>", [t2], arguments.length), v(this, pt, "f").wrap(t2), this;
    }
    [(z = new WeakMap, W = new WeakMap, q = new WeakMap, U = new WeakMap, F = new WeakMap, L = new WeakMap, V = new WeakMap, G = new WeakMap, R = new WeakMap, T = new WeakMap, B = new WeakMap, Y = new WeakMap, K = new WeakMap, J = new WeakMap, Z = new WeakMap, X = new WeakMap, Q = new WeakMap, tt = new WeakMap, et = new WeakMap, st = new WeakMap, it = new WeakMap, nt = new WeakMap, rt = new WeakMap, ot = new WeakMap, at = new WeakMap, ht = new WeakMap, lt = new WeakMap, ct = new WeakMap, ft = new WeakMap, dt = new WeakMap, ut = new WeakMap, pt = new WeakMap, gt = new WeakMap, mt = new WeakMap, yt = new WeakMap, bt)](t2) {
      if (!t2._ || !t2["--"])
        return t2;
      t2._.push.apply(t2._, t2["--"]);
      try {
        delete t2["--"];
      } catch (t3) {
      }
      return t2;
    }
    [vt]() {
      return { log: (...t2) => {
        this[Rt]() || console.log(...t2), O(this, J, true, "f"), v(this, tt, "f").length && O(this, tt, v(this, tt, "f") + `
`, "f"), O(this, tt, v(this, tt, "f") + t2.join(" "), "f");
      }, error: (...t2) => {
        this[Rt]() || console.error(...t2), O(this, J, true, "f"), v(this, tt, "f").length && O(this, tt, v(this, tt, "f") + `
`, "f"), O(this, tt, v(this, tt, "f") + t2.join(" "), "f");
      } };
    }
    [Ot](t2) {
      p(v(this, et, "f")).forEach((e2) => {
        if (e2 === "configObjects")
          return;
        const s2 = v(this, et, "f")[e2];
        Array.isArray(s2) ? s2.includes(t2) && s2.splice(s2.indexOf(t2), 1) : typeof s2 == "object" && delete s2[t2];
      }), delete v(this, pt, "f").getDescriptions()[t2];
    }
    [wt](t2, e2, s2) {
      v(this, R, "f")[s2] || (v(this, ct, "f").process.emitWarning(t2, e2), v(this, R, "f")[s2] = true);
    }
    [Ct]() {
      v(this, B, "f").push({ options: v(this, et, "f"), configObjects: v(this, et, "f").configObjects.slice(0), exitProcess: v(this, T, "f"), groups: v(this, K, "f"), strict: v(this, ft, "f"), strictCommands: v(this, dt, "f"), strictOptions: v(this, ut, "f"), completionCommand: v(this, F, "f"), output: v(this, tt, "f"), exitError: v(this, V, "f"), hasOutput: v(this, J, "f"), parsed: this.parsed, parseFn: v(this, nt, "f"), parseContext: v(this, rt, "f") }), v(this, pt, "f").freeze(), v(this, yt, "f").freeze(), v(this, z, "f").freeze(), v(this, Y, "f").freeze();
    }
    [jt]() {
      let t2, e2 = "";
      return t2 = /\b(node|iojs|electron)(\.exe)?$/.test(v(this, ct, "f").process.argv()[0]) ? v(this, ct, "f").process.argv().slice(1, 2) : v(this, ct, "f").process.argv().slice(0, 1), e2 = t2.map((t3) => {
        const e3 = this[Yt](v(this, W, "f"), t3);
        return t3.match(/^(\/|([a-zA-Z]:)?\\)/) && e3.length < t3.length ? e3 : t3;
      }).join(" ").trim(), v(this, ct, "f").getEnv("_") && v(this, ct, "f").getProcessArgvBin() === v(this, ct, "f").getEnv("_") && (e2 = v(this, ct, "f").getEnv("_").replace(`${v(this, ct, "f").path.dirname(v(this, ct, "f").process.execPath())}/`, "")), e2;
    }
    [Mt]() {
      return v(this, it, "f");
    }
    [_t]() {
      return v(this, gt, "f");
    }
    [kt]() {
      if (!v(this, G, "f"))
        return;
      const t2 = v(this, ct, "f").getEnv("LC_ALL") || v(this, ct, "f").getEnv("LC_MESSAGES") || v(this, ct, "f").getEnv("LANG") || v(this, ct, "f").getEnv("LANGUAGE") || "en_US";
      this.locale(t2.replace(/[.:].*/, ""));
    }
    [xt]() {
      return this[At]().version || "unknown";
    }
    [Et](t2) {
      const e2 = t2["--"] ? t2["--"] : t2._;
      for (let t3, s2 = 0;(t3 = e2[s2]) !== undefined; s2++)
        v(this, ct, "f").Parser.looksLikeNumber(t3) && Number.isSafeInteger(Math.floor(parseFloat(`${t3}`))) && (e2[s2] = Number(t3));
      return t2;
    }
    [At](t2) {
      const e2 = t2 || "*";
      if (v(this, ot, "f")[e2])
        return v(this, ot, "f")[e2];
      let s2 = {};
      try {
        let e3 = t2 || v(this, ct, "f").mainFilename;
        !t2 && v(this, ct, "f").path.extname(e3) && (e3 = v(this, ct, "f").path.dirname(e3));
        const i2 = v(this, ct, "f").findUp(e3, (t3, e4) => e4.includes("package.json") ? "package.json" : undefined);
        d(i2, undefined, v(this, ct, "f")), s2 = JSON.parse(v(this, ct, "f").readFileSync(i2, "utf8"));
      } catch (t3) {
      }
      return v(this, ot, "f")[e2] = s2 || {}, v(this, ot, "f")[e2];
    }
    [Pt](t2, e2) {
      (e2 = [].concat(e2)).forEach((e3) => {
        e3 = this[Dt](e3), v(this, et, "f")[t2].push(e3);
      });
    }
    [St](t2, e2, s2, i2) {
      this[It](t2, e2, s2, i2, (t3, e3, s3) => {
        v(this, et, "f")[t3][e3] = s3;
      });
    }
    [$t](t2, e2, s2, i2) {
      this[It](t2, e2, s2, i2, (t3, e3, s3) => {
        v(this, et, "f")[t3][e3] = (v(this, et, "f")[t3][e3] || []).concat(s3);
      });
    }
    [It](t2, e2, s2, i2, n2) {
      if (Array.isArray(s2))
        s2.forEach((e3) => {
          t2(e3, i2);
        });
      else if (((t3) => typeof t3 == "object")(s2))
        for (const e3 of p(s2))
          t2(e3, s2[e3]);
      else
        n2(e2, this[Dt](s2), i2);
    }
    [Dt](t2) {
      return t2 === "__proto__" ? "___proto___" : t2;
    }
    [Nt](t2, e2) {
      return this[St](this[Nt].bind(this), "key", t2, e2), this;
    }
    [Ht]() {
      var t2, e2, s2, i2, n2, r2, o2, a2, h2, l2, c2, f2;
      const u2 = v(this, B, "f").pop();
      let p2;
      d(u2, undefined, v(this, ct, "f")), t2 = this, e2 = this, s2 = this, i2 = this, n2 = this, r2 = this, o2 = this, a2 = this, h2 = this, l2 = this, c2 = this, f2 = this, { options: { set value(e3) {
        O(t2, et, e3, "f");
      } }.value, configObjects: p2, exitProcess: { set value(t3) {
        O(e2, T, t3, "f");
      } }.value, groups: { set value(t3) {
        O(s2, K, t3, "f");
      } }.value, output: { set value(t3) {
        O(i2, tt, t3, "f");
      } }.value, exitError: { set value(t3) {
        O(n2, V, t3, "f");
      } }.value, hasOutput: { set value(t3) {
        O(r2, J, t3, "f");
      } }.value, parsed: this.parsed, strict: { set value(t3) {
        O(o2, ft, t3, "f");
      } }.value, strictCommands: { set value(t3) {
        O(a2, dt, t3, "f");
      } }.value, strictOptions: { set value(t3) {
        O(h2, ut, t3, "f");
      } }.value, completionCommand: { set value(t3) {
        O(l2, F, t3, "f");
      } }.value, parseFn: { set value(t3) {
        O(c2, nt, t3, "f");
      } }.value, parseContext: { set value(t3) {
        O(f2, rt, t3, "f");
      } }.value } = u2, v(this, et, "f").configObjects = p2, v(this, pt, "f").unfreeze(), v(this, yt, "f").unfreeze(), v(this, z, "f").unfreeze(), v(this, Y, "f").unfreeze();
    }
    [zt](t2, e2) {
      return j(e2, (e3) => (t2(e3), e3));
    }
    getInternalMethods() {
      return { getCommandInstance: this[Wt].bind(this), getContext: this[qt].bind(this), getHasOutput: this[Ut].bind(this), getLoggerInstance: this[Ft].bind(this), getParseContext: this[Lt].bind(this), getParserConfiguration: this[Mt].bind(this), getUsageConfiguration: this[_t].bind(this), getUsageInstance: this[Vt].bind(this), getValidationInstance: this[Gt].bind(this), hasParseCallback: this[Rt].bind(this), isGlobalContext: this[Tt].bind(this), postProcess: this[Bt].bind(this), reset: this[Kt].bind(this), runValidation: this[Zt].bind(this), runYargsParserAndExecuteCommands: this[Jt].bind(this), setHasOutput: this[Xt].bind(this) };
    }
    [Wt]() {
      return v(this, z, "f");
    }
    [qt]() {
      return v(this, q, "f");
    }
    [Ut]() {
      return v(this, J, "f");
    }
    [Ft]() {
      return v(this, Q, "f");
    }
    [Lt]() {
      return v(this, rt, "f") || {};
    }
    [Vt]() {
      return v(this, pt, "f");
    }
    [Gt]() {
      return v(this, yt, "f");
    }
    [Rt]() {
      return !!v(this, nt, "f");
    }
    [Tt]() {
      return v(this, X, "f");
    }
    [Bt](t2, e2, s2, i2) {
      if (s2)
        return t2;
      if (f(t2))
        return t2;
      e2 || (t2 = this[bt](t2));
      return (this[Mt]()["parse-positional-numbers"] || this[Mt]()["parse-positional-numbers"] === undefined) && (t2 = this[Et](t2)), i2 && (t2 = C(t2, this, v(this, Y, "f").getMiddleware(), false)), t2;
    }
    [Kt](t2 = {}) {
      O(this, et, v(this, et, "f") || {}, "f");
      const e2 = {};
      e2.local = v(this, et, "f").local || [], e2.configObjects = v(this, et, "f").configObjects || [];
      const s2 = {};
      e2.local.forEach((e3) => {
        s2[e3] = true, (t2[e3] || []).forEach((t3) => {
          s2[t3] = true;
        });
      }), Object.assign(v(this, at, "f"), Object.keys(v(this, K, "f")).reduce((t3, e3) => {
        const i2 = v(this, K, "f")[e3].filter((t4) => !(t4 in s2));
        return i2.length > 0 && (t3[e3] = i2), t3;
      }, {})), O(this, K, {}, "f");
      return ["array", "boolean", "string", "skipValidation", "count", "normalize", "number", "hiddenOptions"].forEach((t3) => {
        e2[t3] = (v(this, et, "f")[t3] || []).filter((t4) => !s2[t4]);
      }), ["narg", "key", "alias", "default", "defaultDescription", "config", "choices", "demandedOptions", "demandedCommands", "deprecatedOptions"].forEach((t3) => {
        e2[t3] = g(v(this, et, "f")[t3], (t4) => !s2[t4]);
      }), e2.envPrefix = v(this, et, "f").envPrefix, O(this, et, e2, "f"), O(this, pt, v(this, pt, "f") ? v(this, pt, "f").reset(s2) : P(this, v(this, ct, "f")), "f"), O(this, yt, v(this, yt, "f") ? v(this, yt, "f").reset(s2) : function(t3, e3, s3) {
        const i2 = s3.y18n.__, n2 = s3.y18n.__n, r2 = { nonOptionCount: function(s4) {
          const i3 = t3.getDemandedCommands(), r3 = s4._.length + (s4["--"] ? s4["--"].length : 0) - t3.getInternalMethods().getContext().commands.length;
          i3._ && (r3 < i3._.min || r3 > i3._.max) && (r3 < i3._.min ? i3._.minMsg !== undefined ? e3.fail(i3._.minMsg ? i3._.minMsg.replace(/\$0/g, r3.toString()).replace(/\$1/, i3._.min.toString()) : null) : e3.fail(n2("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", r3, r3.toString(), i3._.min.toString())) : r3 > i3._.max && (i3._.maxMsg !== undefined ? e3.fail(i3._.maxMsg ? i3._.maxMsg.replace(/\$0/g, r3.toString()).replace(/\$1/, i3._.max.toString()) : null) : e3.fail(n2("Too many non-option arguments: got %s, maximum of %s", "Too many non-option arguments: got %s, maximum of %s", r3, r3.toString(), i3._.max.toString()))));
        }, positionalCount: function(t4, s4) {
          s4 < t4 && e3.fail(n2("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", s4, s4 + "", t4 + ""));
        }, requiredArguments: function(t4, s4) {
          let i3 = null;
          for (const e4 of Object.keys(s4))
            Object.prototype.hasOwnProperty.call(t4, e4) && t4[e4] !== undefined || (i3 = i3 || {}, i3[e4] = s4[e4]);
          if (i3) {
            const t5 = [];
            for (const e4 of Object.keys(i3)) {
              const s6 = i3[e4];
              s6 && t5.indexOf(s6) < 0 && t5.push(s6);
            }
            const s5 = t5.length ? `
${t5.join(`
`)}` : "";
            e3.fail(n2("Missing required argument: %s", "Missing required arguments: %s", Object.keys(i3).length, Object.keys(i3).join(", ") + s5));
          }
        }, unknownArguments: function(s4, i3, o3, a3, h2 = true) {
          var l3;
          const c3 = t3.getInternalMethods().getCommandInstance().getCommands(), f2 = [], d2 = t3.getInternalMethods().getContext();
          if (Object.keys(s4).forEach((e4) => {
            H.includes(e4) || Object.prototype.hasOwnProperty.call(o3, e4) || Object.prototype.hasOwnProperty.call(t3.getInternalMethods().getParseContext(), e4) || r2.isValidAndSomeAliasIsNotNew(e4, i3) || f2.push(e4);
          }), h2 && (d2.commands.length > 0 || c3.length > 0 || a3) && s4._.slice(d2.commands.length).forEach((t4) => {
            c3.includes("" + t4) || f2.push("" + t4);
          }), h2) {
            const e4 = ((l3 = t3.getDemandedCommands()._) === null || l3 === undefined ? undefined : l3.max) || 0, i4 = d2.commands.length + e4;
            i4 < s4._.length && s4._.slice(i4).forEach((t4) => {
              t4 = String(t4), d2.commands.includes(t4) || f2.includes(t4) || f2.push(t4);
            });
          }
          f2.length && e3.fail(n2("Unknown argument: %s", "Unknown arguments: %s", f2.length, f2.map((t4) => t4.trim() ? t4 : `"${t4}"`).join(", ")));
        }, unknownCommands: function(s4) {
          const i3 = t3.getInternalMethods().getCommandInstance().getCommands(), r3 = [], o3 = t3.getInternalMethods().getContext();
          return (o3.commands.length > 0 || i3.length > 0) && s4._.slice(o3.commands.length).forEach((t4) => {
            i3.includes("" + t4) || r3.push("" + t4);
          }), r3.length > 0 && (e3.fail(n2("Unknown command: %s", "Unknown commands: %s", r3.length, r3.join(", "))), true);
        }, isValidAndSomeAliasIsNotNew: function(e4, s4) {
          if (!Object.prototype.hasOwnProperty.call(s4, e4))
            return false;
          const i3 = t3.parsed.newAliases;
          return [e4, ...s4[e4]].some((t4) => !Object.prototype.hasOwnProperty.call(i3, t4) || !i3[e4]);
        }, limitedChoices: function(s4) {
          const n3 = t3.getOptions(), r3 = {};
          if (!Object.keys(n3.choices).length)
            return;
          Object.keys(s4).forEach((t4) => {
            H.indexOf(t4) === -1 && Object.prototype.hasOwnProperty.call(n3.choices, t4) && [].concat(s4[t4]).forEach((e4) => {
              n3.choices[t4].indexOf(e4) === -1 && e4 !== undefined && (r3[t4] = (r3[t4] || []).concat(e4));
            });
          });
          const o3 = Object.keys(r3);
          if (!o3.length)
            return;
          let a3 = i2("Invalid values:");
          o3.forEach((t4) => {
            a3 += `
  ${i2("Argument: %s, Given: %s, Choices: %s", t4, e3.stringifiedValues(r3[t4]), e3.stringifiedValues(n3.choices[t4]))}`;
          }), e3.fail(a3);
        } };
        let o2 = {};
        function a2(t4, e4) {
          const s4 = Number(e4);
          return typeof (e4 = isNaN(s4) ? e4 : s4) == "number" ? e4 = t4._.length >= e4 : e4.match(/^--no-.+/) ? (e4 = e4.match(/^--no-(.+)/)[1], e4 = !Object.prototype.hasOwnProperty.call(t4, e4)) : e4 = Object.prototype.hasOwnProperty.call(t4, e4), e4;
        }
        r2.implies = function(e4, i3) {
          h("<string|object> [array|number|string]", [e4, i3], arguments.length), typeof e4 == "object" ? Object.keys(e4).forEach((t4) => {
            r2.implies(t4, e4[t4]);
          }) : (t3.global(e4), o2[e4] || (o2[e4] = []), Array.isArray(i3) ? i3.forEach((t4) => r2.implies(e4, t4)) : (d(i3, undefined, s3), o2[e4].push(i3)));
        }, r2.getImplied = function() {
          return o2;
        }, r2.implications = function(t4) {
          const s4 = [];
          if (Object.keys(o2).forEach((e4) => {
            const i3 = e4;
            (o2[e4] || []).forEach((e5) => {
              let n3 = i3;
              const r3 = e5;
              n3 = a2(t4, n3), e5 = a2(t4, e5), n3 && !e5 && s4.push(` ${i3} -> ${r3}`);
            });
          }), s4.length) {
            let t5 = `${i2("Implications failed:")}
`;
            s4.forEach((e4) => {
              t5 += e4;
            }), e3.fail(t5);
          }
        };
        let l2 = {};
        r2.conflicts = function(e4, s4) {
          h("<string|object> [array|string]", [e4, s4], arguments.length), typeof e4 == "object" ? Object.keys(e4).forEach((t4) => {
            r2.conflicts(t4, e4[t4]);
          }) : (t3.global(e4), l2[e4] || (l2[e4] = []), Array.isArray(s4) ? s4.forEach((t4) => r2.conflicts(e4, t4)) : l2[e4].push(s4));
        }, r2.getConflicting = () => l2, r2.conflicting = function(n3) {
          Object.keys(n3).forEach((t4) => {
            l2[t4] && l2[t4].forEach((s4) => {
              s4 && n3[t4] !== undefined && n3[s4] !== undefined && e3.fail(i2("Arguments %s and %s are mutually exclusive", t4, s4));
            });
          }), t3.getInternalMethods().getParserConfiguration()["strip-dashed"] && Object.keys(l2).forEach((t4) => {
            l2[t4].forEach((r3) => {
              r3 && n3[s3.Parser.camelCase(t4)] !== undefined && n3[s3.Parser.camelCase(r3)] !== undefined && e3.fail(i2("Arguments %s and %s are mutually exclusive", t4, r3));
            });
          });
        }, r2.recommendCommands = function(t4, s4) {
          s4 = s4.sort((t5, e4) => e4.length - t5.length);
          let n3 = null, r3 = 1 / 0;
          for (let e4, i3 = 0;(e4 = s4[i3]) !== undefined; i3++) {
            const s5 = N(t4, e4);
            s5 <= 3 && s5 < r3 && (r3 = s5, n3 = e4);
          }
          n3 && e3.fail(i2("Did you mean %s?", n3));
        }, r2.reset = function(t4) {
          return o2 = g(o2, (e4) => !t4[e4]), l2 = g(l2, (e4) => !t4[e4]), r2;
        };
        const c2 = [];
        return r2.freeze = function() {
          c2.push({ implied: o2, conflicting: l2 });
        }, r2.unfreeze = function() {
          const t4 = c2.pop();
          d(t4, undefined, s3), { implied: o2, conflicting: l2 } = t4;
        }, r2;
      }(this, v(this, pt, "f"), v(this, ct, "f")), "f"), O(this, z, v(this, z, "f") ? v(this, z, "f").reset() : function(t3, e3, s3, i2) {
        return new _(t3, e3, s3, i2);
      }(v(this, pt, "f"), v(this, yt, "f"), v(this, Y, "f"), v(this, ct, "f")), "f"), v(this, U, "f") || O(this, U, function(t3, e3, s3, i2) {
        return new D(t3, e3, s3, i2);
      }(this, v(this, pt, "f"), v(this, z, "f"), v(this, ct, "f")), "f"), v(this, Y, "f").reset(), O(this, F, null, "f"), O(this, tt, "", "f"), O(this, V, null, "f"), O(this, J, false, "f"), this.parsed = false, this;
    }
    [Yt](t2, e2) {
      return v(this, ct, "f").path.relative(t2, e2);
    }
    [Jt](t2, s2, i2, n2 = 0, r2 = false) {
      let o2 = !!i2 || r2;
      t2 = t2 || v(this, ht, "f"), v(this, et, "f").__ = v(this, ct, "f").y18n.__, v(this, et, "f").configuration = this[Mt]();
      const a2 = !!v(this, et, "f").configuration["populate--"], h2 = Object.assign({}, v(this, et, "f").configuration, { "populate--": true }), l2 = v(this, ct, "f").Parser.detailed(t2, Object.assign({}, v(this, et, "f"), { configuration: { "parse-positional-numbers": false, ...h2 } })), c2 = Object.assign(l2.argv, v(this, rt, "f"));
      let d2;
      const u2 = l2.aliases;
      let p2 = false, g2 = false;
      Object.keys(c2).forEach((t3) => {
        t3 === v(this, Z, "f") && c2[t3] ? p2 = true : t3 === v(this, mt, "f") && c2[t3] && (g2 = true);
      }), c2.$0 = this.$0, this.parsed = l2, n2 === 0 && v(this, pt, "f").clearCachedHelpMessage();
      try {
        if (this[kt](), s2)
          return this[Bt](c2, a2, !!i2, false);
        if (v(this, Z, "f")) {
          [v(this, Z, "f")].concat(u2[v(this, Z, "f")] || []).filter((t3) => t3.length > 1).includes("" + c2._[c2._.length - 1]) && (c2._.pop(), p2 = true);
        }
        O(this, X, false, "f");
        const h3 = v(this, z, "f").getCommands(), m2 = v(this, U, "f").completionKey in c2, y2 = p2 || m2 || r2;
        if (c2._.length) {
          if (h3.length) {
            let t3;
            for (let e2, s3 = n2 || 0;c2._[s3] !== undefined; s3++) {
              if (e2 = String(c2._[s3]), h3.includes(e2) && e2 !== v(this, F, "f")) {
                const t4 = v(this, z, "f").runCommand(e2, this, l2, s3 + 1, r2, p2 || g2 || r2);
                return this[Bt](t4, a2, !!i2, false);
              }
              if (!t3 && e2 !== v(this, F, "f")) {
                t3 = e2;
                break;
              }
            }
            !v(this, z, "f").hasDefaultCommand() && v(this, lt, "f") && t3 && !y2 && v(this, yt, "f").recommendCommands(t3, h3);
          }
          v(this, F, "f") && c2._.includes(v(this, F, "f")) && !m2 && (v(this, T, "f") && E(true), this.showCompletionScript(), this.exit(0));
        }
        if (v(this, z, "f").hasDefaultCommand() && !y2) {
          const t3 = v(this, z, "f").runCommand(null, this, l2, 0, r2, p2 || g2 || r2);
          return this[Bt](t3, a2, !!i2, false);
        }
        if (m2) {
          v(this, T, "f") && E(true);
          const s3 = (t2 = [].concat(t2)).slice(t2.indexOf(`--${v(this, U, "f").completionKey}`) + 1);
          return v(this, U, "f").getCompletion(s3, (t3, s4) => {
            if (t3)
              throw new e(t3.message);
            (s4 || []).forEach((t4) => {
              v(this, Q, "f").log(t4);
            }), this.exit(0);
          }), this[Bt](c2, !a2, !!i2, false);
        }
        if (v(this, J, "f") || (p2 ? (v(this, T, "f") && E(true), o2 = true, this.showHelp("log"), this.exit(0)) : g2 && (v(this, T, "f") && E(true), o2 = true, v(this, pt, "f").showVersion("log"), this.exit(0))), !o2 && v(this, et, "f").skipValidation.length > 0 && (o2 = Object.keys(c2).some((t3) => v(this, et, "f").skipValidation.indexOf(t3) >= 0 && c2[t3] === true)), !o2) {
          if (l2.error)
            throw new e(l2.error.message);
          if (!m2) {
            const t3 = this[Zt](u2, {}, l2.error);
            i2 || (d2 = C(c2, this, v(this, Y, "f").getMiddleware(), true)), d2 = this[zt](t3, d2 != null ? d2 : c2), f(d2) && !i2 && (d2 = d2.then(() => C(c2, this, v(this, Y, "f").getMiddleware(), false)));
          }
        }
      } catch (t3) {
        if (!(t3 instanceof e))
          throw t3;
        v(this, pt, "f").fail(t3.message, t3);
      }
      return this[Bt](d2 != null ? d2 : c2, a2, !!i2, true);
    }
    [Zt](t2, s2, i2, n2) {
      const r2 = { ...this.getDemandedOptions() };
      return (o2) => {
        if (i2)
          throw new e(i2.message);
        v(this, yt, "f").nonOptionCount(o2), v(this, yt, "f").requiredArguments(o2, r2);
        let a2 = false;
        v(this, dt, "f") && (a2 = v(this, yt, "f").unknownCommands(o2)), v(this, ft, "f") && !a2 ? v(this, yt, "f").unknownArguments(o2, t2, s2, !!n2) : v(this, ut, "f") && v(this, yt, "f").unknownArguments(o2, t2, {}, false, false), v(this, yt, "f").limitedChoices(o2), v(this, yt, "f").implications(o2), v(this, yt, "f").conflicting(o2);
      };
    }
    [Xt]() {
      O(this, J, true, "f");
    }
    [Qt](t2) {
      if (typeof t2 == "string")
        v(this, et, "f").key[t2] = true;
      else
        for (const e2 of t2)
          v(this, et, "f").key[e2] = true;
    }
  }
  var ee;
  var se;
  var { readFileSync: ie } = import.meta.require("fs");
  var { inspect: ne } = import.meta.require("util");
  var { resolve: re } = import.meta.require("path");
  var oe = require_build();
  var ae = require_build2();
  var he;
  var le = { assert: { notStrictEqual: t.notStrictEqual, strictEqual: t.strictEqual }, cliui: require_build3(), findUp: require_sync(), getEnv: (t2) => process.env[t2], getCallerFile: require_get_caller_file(), getProcessArgvBin: y, inspect: ne, mainFilename: (se = (ee = import.meta.require === null || import.meta.require === undefined ? undefined : import.meta.require.main) === null || ee === undefined ? undefined : ee.filename) !== null && se !== undefined ? se : process.cwd(), Parser: ae, path: import.meta.require("path"), process: { argv: () => process.argv, cwd: process.cwd, emitWarning: (t2, e2) => process.emitWarning(t2, e2), execPath: () => process.execPath, exit: (t2) => {
    process.exit(t2);
  }, nextTick: process.nextTick, stdColumns: process.stdout.columns !== undefined ? process.stdout.columns : null }, readFileSync: ie, require: import.meta.require, requireDirectory: require_require_directory(), stringWidth: require_string_width(), y18n: oe({ directory: re(__dirname, "../locales"), updateFiles: false }) };
  var ce = ((he = process === null || process === undefined ? undefined : process.env) === null || he === undefined ? undefined : he.YARGS_MIN_NODE_VERSION) ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
  if (process && process.version) {
    if (Number(process.version.match(/v([^.]+)/)[1]) < ce)
      throw Error(`yargs supports a minimum Node.js version of ${ce}. Read our version support policy: https://github.com/yargs/yargs#supported-nodejs-versions`);
  }
  var fe = require_build2();
  var de;
  var ue = { applyExtends: n, cjsPlatformShim: le, Yargs: (de = le, (t2 = [], e2 = de.process.cwd(), s2) => {
    const i2 = new te(t2, e2, s2, de);
    return Object.defineProperty(i2, "argv", { get: () => i2.parse(), enumerable: true }), i2.help(), i2.version(), i2;
  }), argsert: h, isPromise: f, objFilter: g, parseCommand: o, Parser: fe, processArgv: b, YError: e };
  module.exports = ue;
});

// node_modules/yargs/yargs.mjs
var import_build = __toESM(require_build4(), 1);
var { applyExtends, cjsPlatformShim, Parser, processArgv, Yargs } = import_build.default;
Yargs.applyExtends = (config, cwd, mergeExtends) => {
  return applyExtends(config, cwd, mergeExtends, cjsPlatformShim);
};
Yargs.hideBin = processArgv.hideBin;
Yargs.Parser = Parser;
var yargs_default = Yargs;

// node_modules/yargs/build/lib/yerror.js
class YError extends Error {
  constructor(msg) {
    super(msg || "yargs error");
    this.name = "YError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, YError);
    }
  }
}

// node_modules/yargs/build/lib/utils/process-argv.js
function getProcessArgvBinIndex() {
  if (isBundledElectronApp())
    return 0;
  return 1;
}
function isBundledElectronApp() {
  return isElectronApp() && !process.defaultApp;
}
function isElectronApp() {
  return !!process.versions.electron;
}
function hideBin(argv) {
  return argv.slice(getProcessArgvBinIndex() + 1);
}
function getProcessArgvBin() {
  return process.argv[getProcessArgvBinIndex()];
}

// node_modules/yargs-parser/build/lib/index.js
import { format } from "util";
import { normalize, resolve } from "path";

// node_modules/yargs-parser/build/lib/string-utils.js
function camelCase(str) {
  const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
  if (!isCamelCase) {
    str = str.toLowerCase();
  }
  if (str.indexOf("-") === -1 && str.indexOf("_") === -1) {
    return str;
  } else {
    let camelcase = "";
    let nextChrUpper = false;
    const leadingHyphens = str.match(/^-+/);
    for (let i = leadingHyphens ? leadingHyphens[0].length : 0;i < str.length; i++) {
      let chr = str.charAt(i);
      if (nextChrUpper) {
        nextChrUpper = false;
        chr = chr.toUpperCase();
      }
      if (i !== 0 && (chr === "-" || chr === "_")) {
        nextChrUpper = true;
      } else if (chr !== "-" && chr !== "_") {
        camelcase += chr;
      }
    }
    return camelcase;
  }
}
function decamelize(str, joinString) {
  const lowercase = str.toLowerCase();
  joinString = joinString || "-";
  let notCamelcase = "";
  for (let i = 0;i < str.length; i++) {
    const chrLower = lowercase.charAt(i);
    const chrString = str.charAt(i);
    if (chrLower !== chrString && i > 0) {
      notCamelcase += `${joinString}${lowercase.charAt(i)}`;
    } else {
      notCamelcase += chrString;
    }
  }
  return notCamelcase;
}
function looksLikeNumber(x) {
  if (x === null || x === undefined)
    return false;
  if (typeof x === "number")
    return true;
  if (/^0x[0-9a-f]+$/i.test(x))
    return true;
  if (/^0[^.]/.test(x))
    return false;
  return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}

// node_modules/yargs-parser/build/lib/tokenize-arg-string.js
function tokenizeArgString(argString) {
  if (Array.isArray(argString)) {
    return argString.map((e) => typeof e !== "string" ? e + "" : e);
  }
  argString = argString.trim();
  let i = 0;
  let prevC = null;
  let c = null;
  let opening = null;
  const args = [];
  for (let ii = 0;ii < argString.length; ii++) {
    prevC = c;
    c = argString.charAt(ii);
    if (c === " " && !opening) {
      if (!(prevC === " ")) {
        i++;
      }
      continue;
    }
    if (c === opening) {
      opening = null;
    } else if ((c === "'" || c === '"') && !opening) {
      opening = c;
    }
    if (!args[i])
      args[i] = "";
    args[i] += c;
  }
  return args;
}

// node_modules/yargs-parser/build/lib/yargs-parser-types.js
var DefaultValuesForTypeKey;
(function(DefaultValuesForTypeKey2) {
  DefaultValuesForTypeKey2["BOOLEAN"] = "boolean";
  DefaultValuesForTypeKey2["STRING"] = "string";
  DefaultValuesForTypeKey2["NUMBER"] = "number";
  DefaultValuesForTypeKey2["ARRAY"] = "array";
})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));

// node_modules/yargs-parser/build/lib/yargs-parser.js
var mixin;

class YargsParser {
  constructor(_mixin) {
    mixin = _mixin;
  }
  parse(argsInput, options) {
    const opts = Object.assign({
      alias: undefined,
      array: undefined,
      boolean: undefined,
      config: undefined,
      configObjects: undefined,
      configuration: undefined,
      coerce: undefined,
      count: undefined,
      default: undefined,
      envPrefix: undefined,
      narg: undefined,
      normalize: undefined,
      string: undefined,
      number: undefined,
      __: undefined,
      key: undefined
    }, options);
    const args = tokenizeArgString(argsInput);
    const inputIsString = typeof argsInput === "string";
    const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
    const configuration = Object.assign({
      "boolean-negation": true,
      "camel-case-expansion": true,
      "combine-arrays": false,
      "dot-notation": true,
      "duplicate-arguments-array": true,
      "flatten-duplicate-arrays": true,
      "greedy-arrays": true,
      "halt-at-non-option": false,
      "nargs-eats-options": false,
      "negation-prefix": "no-",
      "parse-numbers": true,
      "parse-positional-numbers": true,
      "populate--": false,
      "set-placeholder-key": false,
      "short-option-groups": true,
      "strip-aliased": false,
      "strip-dashed": false,
      "unknown-options-as-args": false
    }, opts.configuration);
    const defaults = Object.assign(Object.create(null), opts.default);
    const configObjects = opts.configObjects || [];
    const envPrefix = opts.envPrefix;
    const notFlagsOption = configuration["populate--"];
    const notFlagsArgv = notFlagsOption ? "--" : "_";
    const newAliases = Object.create(null);
    const defaulted = Object.create(null);
    const __ = opts.__ || mixin.format;
    const flags = {
      aliases: Object.create(null),
      arrays: Object.create(null),
      bools: Object.create(null),
      strings: Object.create(null),
      numbers: Object.create(null),
      counts: Object.create(null),
      normalize: Object.create(null),
      configs: Object.create(null),
      nargs: Object.create(null),
      coercions: Object.create(null),
      keys: []
    };
    const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
    const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
    [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
      const key = typeof opt === "object" ? opt.key : opt;
      const assignment = Object.keys(opt).map(function(key2) {
        const arrayFlagKeys = {
          boolean: "bools",
          string: "strings",
          number: "numbers"
        };
        return arrayFlagKeys[key2];
      }).filter(Boolean).pop();
      if (assignment) {
        flags[assignment][key] = true;
      }
      flags.arrays[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
      flags.bools[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
      flags.strings[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
      flags.numbers[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
      flags.counts[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
      flags.normalize[key] = true;
      flags.keys.push(key);
    });
    if (typeof opts.narg === "object") {
      Object.entries(opts.narg).forEach(([key, value]) => {
        if (typeof value === "number") {
          flags.nargs[key] = value;
          flags.keys.push(key);
        }
      });
    }
    if (typeof opts.coerce === "object") {
      Object.entries(opts.coerce).forEach(([key, value]) => {
        if (typeof value === "function") {
          flags.coercions[key] = value;
          flags.keys.push(key);
        }
      });
    }
    if (typeof opts.config !== "undefined") {
      if (Array.isArray(opts.config) || typeof opts.config === "string") {
        [].concat(opts.config).filter(Boolean).forEach(function(key) {
          flags.configs[key] = true;
        });
      } else if (typeof opts.config === "object") {
        Object.entries(opts.config).forEach(([key, value]) => {
          if (typeof value === "boolean" || typeof value === "function") {
            flags.configs[key] = value;
          }
        });
      }
    }
    extendAliases(opts.key, aliases, opts.default, flags.arrays);
    Object.keys(defaults).forEach(function(key) {
      (flags.aliases[key] || []).forEach(function(alias) {
        defaults[alias] = defaults[key];
      });
    });
    let error = null;
    checkConfiguration();
    let notFlags = [];
    const argv = Object.assign(Object.create(null), { _: [] });
    const argvReturn = {};
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      const truncatedArg = arg.replace(/^-{3,}/, "---");
      let broken;
      let key;
      let letters;
      let m;
      let next;
      let value;
      if (arg !== "--" && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
        pushPositional(arg);
      } else if (truncatedArg.match(/^---+(=|$)/)) {
        pushPositional(arg);
        continue;
      } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
        m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
        if (m !== null && Array.isArray(m) && m.length >= 3) {
          if (checkAllAliases(m[1], flags.arrays)) {
            i = eatArray(i, m[1], args, m[2]);
          } else if (checkAllAliases(m[1], flags.nargs) !== false) {
            i = eatNargs(i, m[1], args, m[2]);
          } else {
            setArg(m[1], m[2], true);
          }
        }
      } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
        m = arg.match(negatedBoolean);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
        }
      } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
        m = arg.match(/^--?(.+)/);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          if (checkAllAliases(key, flags.arrays)) {
            i = eatArray(i, key, args);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            i = eatNargs(i, key, args);
          } else {
            next = args[i + 1];
            if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (arg.match(/^-.\..+=/)) {
        m = arg.match(/^-([^=]+)=([\s\S]*)$/);
        if (m !== null && Array.isArray(m) && m.length >= 3) {
          setArg(m[1], m[2]);
        }
      } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
        next = args[i + 1];
        m = arg.match(/^-(.\..+)/);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
            setArg(key, next);
            i++;
          } else {
            setArg(key, defaultValue(key));
          }
        }
      } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
        letters = arg.slice(1, -1).split("");
        broken = false;
        for (let j = 0;j < letters.length; j++) {
          next = arg.slice(j + 2);
          if (letters[j + 1] && letters[j + 1] === "=") {
            value = arg.slice(j + 3);
            key = letters[j];
            if (checkAllAliases(key, flags.arrays)) {
              i = eatArray(i, key, args, value);
            } else if (checkAllAliases(key, flags.nargs) !== false) {
              i = eatNargs(i, key, args, value);
            } else {
              setArg(key, value);
            }
            broken = true;
            break;
          }
          if (next === "-") {
            setArg(letters[j], next);
            continue;
          }
          if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
            setArg(letters[j], next);
            broken = true;
            break;
          }
          if (letters[j + 1] && letters[j + 1].match(/\W/)) {
            setArg(letters[j], next);
            broken = true;
            break;
          } else {
            setArg(letters[j], defaultValue(letters[j]));
          }
        }
        key = arg.slice(-1)[0];
        if (!broken && key !== "-") {
          if (checkAllAliases(key, flags.arrays)) {
            i = eatArray(i, key, args);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            i = eatNargs(i, key, args);
          } else {
            next = args[i + 1];
            if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
        key = arg.slice(1);
        setArg(key, defaultValue(key));
      } else if (arg === "--") {
        notFlags = args.slice(i + 1);
        break;
      } else if (configuration["halt-at-non-option"]) {
        notFlags = args.slice(i);
        break;
      } else {
        pushPositional(arg);
      }
    }
    applyEnvVars(argv, true);
    applyEnvVars(argv, false);
    setConfig(argv);
    setConfigObjects();
    applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
    applyCoercions(argv);
    if (configuration["set-placeholder-key"])
      setPlaceholderKeys(argv);
    Object.keys(flags.counts).forEach(function(key) {
      if (!hasKey(argv, key.split(".")))
        setArg(key, 0);
    });
    if (notFlagsOption && notFlags.length)
      argv[notFlagsArgv] = [];
    notFlags.forEach(function(key) {
      argv[notFlagsArgv].push(key);
    });
    if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
      Object.keys(argv).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
        delete argv[key];
      });
    }
    if (configuration["strip-aliased"]) {
      [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
        if (configuration["camel-case-expansion"] && alias.includes("-")) {
          delete argv[alias.split(".").map((prop) => camelCase(prop)).join(".")];
        }
        delete argv[alias];
      });
    }
    function pushPositional(arg) {
      const maybeCoercedNumber = maybeCoerceNumber("_", arg);
      if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") {
        argv._.push(maybeCoercedNumber);
      }
    }
    function eatNargs(i, key, args2, argAfterEqualSign) {
      let ii;
      let toEat = checkAllAliases(key, flags.nargs);
      toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
      if (toEat === 0) {
        if (!isUndefined(argAfterEqualSign)) {
          error = Error(__("Argument unexpected for: %s", key));
        }
        setArg(key, defaultValue(key));
        return i;
      }
      let available = isUndefined(argAfterEqualSign) ? 0 : 1;
      if (configuration["nargs-eats-options"]) {
        if (args2.length - (i + 1) + available < toEat) {
          error = Error(__("Not enough arguments following: %s", key));
        }
        available = toEat;
      } else {
        for (ii = i + 1;ii < args2.length; ii++) {
          if (!args2[ii].match(/^-[^0-9]/) || args2[ii].match(negative) || isUnknownOptionAsArg(args2[ii]))
            available++;
          else
            break;
        }
        if (available < toEat)
          error = Error(__("Not enough arguments following: %s", key));
      }
      let consumed = Math.min(available, toEat);
      if (!isUndefined(argAfterEqualSign) && consumed > 0) {
        setArg(key, argAfterEqualSign);
        consumed--;
      }
      for (ii = i + 1;ii < consumed + i + 1; ii++) {
        setArg(key, args2[ii]);
      }
      return i + consumed;
    }
    function eatArray(i, key, args2, argAfterEqualSign) {
      let argsToSet = [];
      let next = argAfterEqualSign || args2[i + 1];
      const nargsCount = checkAllAliases(key, flags.nargs);
      if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
        argsToSet.push(true);
      } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
        if (defaults[key] !== undefined) {
          const defVal = defaults[key];
          argsToSet = Array.isArray(defVal) ? defVal : [defVal];
        }
      } else {
        if (!isUndefined(argAfterEqualSign)) {
          argsToSet.push(processValue(key, argAfterEqualSign, true));
        }
        for (let ii = i + 1;ii < args2.length; ii++) {
          if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount)
            break;
          next = args2[ii];
          if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
            break;
          i = ii;
          argsToSet.push(processValue(key, next, inputIsString));
        }
      }
      if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
        error = Error(__("Not enough arguments following: %s", key));
      }
      setArg(key, argsToSet);
      return i;
    }
    function setArg(key, val, shouldStripQuotes = inputIsString) {
      if (/-/.test(key) && configuration["camel-case-expansion"]) {
        const alias = key.split(".").map(function(prop) {
          return camelCase(prop);
        }).join(".");
        addNewAlias(key, alias);
      }
      const value = processValue(key, val, shouldStripQuotes);
      const splitKey = key.split(".");
      setKey(argv, splitKey, value);
      if (flags.aliases[key]) {
        flags.aliases[key].forEach(function(x) {
          const keyProperties = x.split(".");
          setKey(argv, keyProperties, value);
        });
      }
      if (splitKey.length > 1 && configuration["dot-notation"]) {
        (flags.aliases[splitKey[0]] || []).forEach(function(x) {
          let keyProperties = x.split(".");
          const a = [].concat(splitKey);
          a.shift();
          keyProperties = keyProperties.concat(a);
          if (!(flags.aliases[key] || []).includes(keyProperties.join("."))) {
            setKey(argv, keyProperties, value);
          }
        });
      }
      if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
        const keys = [key].concat(flags.aliases[key] || []);
        keys.forEach(function(key2) {
          Object.defineProperty(argvReturn, key2, {
            enumerable: true,
            get() {
              return val;
            },
            set(value2) {
              val = typeof value2 === "string" ? mixin.normalize(value2) : value2;
            }
          });
        });
      }
    }
    function addNewAlias(key, alias) {
      if (!(flags.aliases[key] && flags.aliases[key].length)) {
        flags.aliases[key] = [alias];
        newAliases[alias] = true;
      }
      if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
        addNewAlias(alias, key);
      }
    }
    function processValue(key, val, shouldStripQuotes) {
      if (shouldStripQuotes) {
        val = stripQuotes(val);
      }
      if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
        if (typeof val === "string")
          val = val === "true";
      }
      let value = Array.isArray(val) ? val.map(function(v) {
        return maybeCoerceNumber(key, v);
      }) : maybeCoerceNumber(key, val);
      if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === "boolean")) {
        value = increment();
      }
      if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
        if (Array.isArray(val))
          value = val.map((val2) => {
            return mixin.normalize(val2);
          });
        else
          value = mixin.normalize(val);
      }
      return value;
    }
    function maybeCoerceNumber(key, value) {
      if (!configuration["parse-positional-numbers"] && key === "_")
        return value;
      if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
        const shouldCoerceNumber = looksLikeNumber(value) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));
        if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {
          value = Number(value);
        }
      }
      return value;
    }
    function setConfig(argv2) {
      const configLookup = Object.create(null);
      applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
      Object.keys(flags.configs).forEach(function(configKey) {
        const configPath = argv2[configKey] || configLookup[configKey];
        if (configPath) {
          try {
            let config = null;
            const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
            const resolveConfig = flags.configs[configKey];
            if (typeof resolveConfig === "function") {
              try {
                config = resolveConfig(resolvedConfigPath);
              } catch (e) {
                config = e;
              }
              if (config instanceof Error) {
                error = config;
                return;
              }
            } else {
              config = mixin.require(resolvedConfigPath);
            }
            setConfigObject(config);
          } catch (ex) {
            if (ex.name === "PermissionDenied")
              error = ex;
            else if (argv2[configKey])
              error = Error(__("Invalid JSON config file: %s", configPath));
          }
        }
      });
    }
    function setConfigObject(config, prev) {
      Object.keys(config).forEach(function(key) {
        const value = config[key];
        const fullKey = prev ? prev + "." + key : key;
        if (typeof value === "object" && value !== null && !Array.isArray(value) && configuration["dot-notation"]) {
          setConfigObject(value, fullKey);
        } else {
          if (!hasKey(argv, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
            setArg(fullKey, value);
          }
        }
      });
    }
    function setConfigObjects() {
      if (typeof configObjects !== "undefined") {
        configObjects.forEach(function(configObject) {
          setConfigObject(configObject);
        });
      }
    }
    function applyEnvVars(argv2, configOnly) {
      if (typeof envPrefix === "undefined")
        return;
      const prefix = typeof envPrefix === "string" ? envPrefix : "";
      const env = mixin.env();
      Object.keys(env).forEach(function(envVar) {
        if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
          const keys = envVar.split("__").map(function(key, i) {
            if (i === 0) {
              key = key.substring(prefix.length);
            }
            return camelCase(key);
          });
          if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv2, keys)) {
            setArg(keys.join("."), env[envVar]);
          }
        }
      });
    }
    function applyCoercions(argv2) {
      let coerce;
      const applied = new Set;
      Object.keys(argv2).forEach(function(key) {
        if (!applied.has(key)) {
          coerce = checkAllAliases(key, flags.coercions);
          if (typeof coerce === "function") {
            try {
              const value = maybeCoerceNumber(key, coerce(argv2[key]));
              [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                applied.add(ali);
                argv2[ali] = value;
              });
            } catch (err) {
              error = err;
            }
          }
        }
      });
    }
    function setPlaceholderKeys(argv2) {
      flags.keys.forEach((key) => {
        if (~key.indexOf("."))
          return;
        if (typeof argv2[key] === "undefined")
          argv2[key] = undefined;
      });
      return argv2;
    }
    function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
      Object.keys(defaults2).forEach(function(key) {
        if (!hasKey(obj, key.split("."))) {
          setKey(obj, key.split("."), defaults2[key]);
          if (canLog)
            defaulted[key] = true;
          (aliases2[key] || []).forEach(function(x) {
            if (hasKey(obj, x.split(".")))
              return;
            setKey(obj, x.split("."), defaults2[key]);
          });
        }
      });
    }
    function hasKey(obj, keys) {
      let o = obj;
      if (!configuration["dot-notation"])
        keys = [keys.join(".")];
      keys.slice(0, -1).forEach(function(key2) {
        o = o[key2] || {};
      });
      const key = keys[keys.length - 1];
      if (typeof o !== "object")
        return false;
      else
        return key in o;
    }
    function setKey(obj, keys, value) {
      let o = obj;
      if (!configuration["dot-notation"])
        keys = [keys.join(".")];
      keys.slice(0, -1).forEach(function(key2) {
        key2 = sanitizeKey(key2);
        if (typeof o === "object" && o[key2] === undefined) {
          o[key2] = {};
        }
        if (typeof o[key2] !== "object" || Array.isArray(o[key2])) {
          if (Array.isArray(o[key2])) {
            o[key2].push({});
          } else {
            o[key2] = [o[key2], {}];
          }
          o = o[key2][o[key2].length - 1];
        } else {
          o = o[key2];
        }
      });
      const key = sanitizeKey(keys[keys.length - 1]);
      const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
      const isValueArray = Array.isArray(value);
      let duplicate = configuration["duplicate-arguments-array"];
      if (!duplicate && checkAllAliases(key, flags.nargs)) {
        duplicate = true;
        if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
          o[key] = undefined;
        }
      }
      if (value === increment()) {
        o[key] = increment(o[key]);
      } else if (Array.isArray(o[key])) {
        if (duplicate && isTypeArray && isValueArray) {
          o[key] = configuration["flatten-duplicate-arrays"] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
        } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
          o[key] = value;
        } else {
          o[key] = o[key].concat([value]);
        }
      } else if (o[key] === undefined && isTypeArray) {
        o[key] = isValueArray ? value : [value];
      } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
        o[key] = [o[key], value];
      } else {
        o[key] = value;
      }
    }
    function extendAliases(...args2) {
      args2.forEach(function(obj) {
        Object.keys(obj || {}).forEach(function(key) {
          if (flags.aliases[key])
            return;
          flags.aliases[key] = [].concat(aliases[key] || []);
          flags.aliases[key].concat(key).forEach(function(x) {
            if (/-/.test(x) && configuration["camel-case-expansion"]) {
              const c = camelCase(x);
              if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                flags.aliases[key].push(c);
                newAliases[c] = true;
              }
            }
          });
          flags.aliases[key].concat(key).forEach(function(x) {
            if (x.length > 1 && /[A-Z]/.test(x) && configuration["camel-case-expansion"]) {
              const c = decamelize(x, "-");
              if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                flags.aliases[key].push(c);
                newAliases[c] = true;
              }
            }
          });
          flags.aliases[key].forEach(function(x) {
            flags.aliases[x] = [key].concat(flags.aliases[key].filter(function(y) {
              return x !== y;
            }));
          });
        });
      });
    }
    function checkAllAliases(key, flag) {
      const toCheck = [].concat(flags.aliases[key] || [], key);
      const keys = Object.keys(flag);
      const setAlias = toCheck.find((key2) => keys.includes(key2));
      return setAlias ? flag[setAlias] : false;
    }
    function hasAnyFlag(key) {
      const flagsKeys = Object.keys(flags);
      const toCheck = [].concat(flagsKeys.map((k) => flags[k]));
      return toCheck.some(function(flag) {
        return Array.isArray(flag) ? flag.includes(key) : flag[key];
      });
    }
    function hasFlagsMatching(arg, ...patterns) {
      const toCheck = [].concat(...patterns);
      return toCheck.some(function(pattern) {
        const match = arg.match(pattern);
        return match && hasAnyFlag(match[1]);
      });
    }
    function hasAllShortFlags(arg) {
      if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
        return false;
      }
      let hasAllFlags = true;
      let next;
      const letters = arg.slice(1).split("");
      for (let j = 0;j < letters.length; j++) {
        next = arg.slice(j + 2);
        if (!hasAnyFlag(letters[j])) {
          hasAllFlags = false;
          break;
        }
        if (letters[j + 1] && letters[j + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
          break;
        }
      }
      return hasAllFlags;
    }
    function isUnknownOptionAsArg(arg) {
      return configuration["unknown-options-as-args"] && isUnknownOption(arg);
    }
    function isUnknownOption(arg) {
      arg = arg.replace(/^-{3,}/, "--");
      if (arg.match(negative)) {
        return false;
      }
      if (hasAllShortFlags(arg)) {
        return false;
      }
      const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
      const normalFlag = /^-+([^=]+?)$/;
      const flagEndingInHyphen = /^-+([^=]+?)-$/;
      const flagEndingInDigits = /^-+([^=]+?\d+)$/;
      const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
      return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
    }
    function defaultValue(key) {
      if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
        return defaults[key];
      } else {
        return defaultForType(guessType(key));
      }
    }
    function defaultForType(type) {
      const def = {
        [DefaultValuesForTypeKey.BOOLEAN]: true,
        [DefaultValuesForTypeKey.STRING]: "",
        [DefaultValuesForTypeKey.NUMBER]: undefined,
        [DefaultValuesForTypeKey.ARRAY]: []
      };
      return def[type];
    }
    function guessType(key) {
      let type = DefaultValuesForTypeKey.BOOLEAN;
      if (checkAllAliases(key, flags.strings))
        type = DefaultValuesForTypeKey.STRING;
      else if (checkAllAliases(key, flags.numbers))
        type = DefaultValuesForTypeKey.NUMBER;
      else if (checkAllAliases(key, flags.bools))
        type = DefaultValuesForTypeKey.BOOLEAN;
      else if (checkAllAliases(key, flags.arrays))
        type = DefaultValuesForTypeKey.ARRAY;
      return type;
    }
    function isUndefined(num) {
      return num === undefined;
    }
    function checkConfiguration() {
      Object.keys(flags.counts).find((key) => {
        if (checkAllAliases(key, flags.arrays)) {
          error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
          return true;
        } else if (checkAllAliases(key, flags.nargs)) {
          error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
          return true;
        }
        return false;
      });
    }
    return {
      aliases: Object.assign({}, flags.aliases),
      argv: Object.assign(argvReturn, argv),
      configuration,
      defaulted: Object.assign({}, defaulted),
      error,
      newAliases: Object.assign({}, newAliases)
    };
  }
}
function combineAliases(aliases) {
  const aliasArrays = [];
  const combined = Object.create(null);
  let change = true;
  Object.keys(aliases).forEach(function(key) {
    aliasArrays.push([].concat(aliases[key], key));
  });
  while (change) {
    change = false;
    for (let i = 0;i < aliasArrays.length; i++) {
      for (let ii = i + 1;ii < aliasArrays.length; ii++) {
        const intersect = aliasArrays[i].filter(function(v) {
          return aliasArrays[ii].indexOf(v) !== -1;
        });
        if (intersect.length) {
          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
          aliasArrays.splice(ii, 1);
          change = true;
          break;
        }
      }
    }
  }
  aliasArrays.forEach(function(aliasArray) {
    aliasArray = aliasArray.filter(function(v, i, self) {
      return self.indexOf(v) === i;
    });
    const lastAlias = aliasArray.pop();
    if (lastAlias !== undefined && typeof lastAlias === "string") {
      combined[lastAlias] = aliasArray;
    }
  });
  return combined;
}
function increment(orig) {
  return orig !== undefined ? orig + 1 : 1;
}
function sanitizeKey(key) {
  if (key === "__proto__")
    return "___proto___";
  return key;
}
function stripQuotes(val) {
  return typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;
}

// node_modules/yargs-parser/build/lib/index.js
var _a;
var _b;
var _c;
var minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
var nodeVersion = (_b = (_a = process === null || process === undefined ? undefined : process.versions) === null || _a === undefined ? undefined : _a.node) !== null && _b !== undefined ? _b : (_c = process === null || process === undefined ? undefined : process.version) === null || _c === undefined ? undefined : _c.slice(1);
if (nodeVersion) {
  const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
  if (major < minNodeVersion) {
    throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
  }
}
var env = process ? process.env : {};
var parser = new YargsParser({
  cwd: process.cwd,
  env: () => {
    return env;
  },
  format,
  normalize,
  resolve,
  require: (path) => {
    if (true) {
      return import.meta.require(path);
    } else
      ;
  }
});
var yargsParser = function Parser2(args, opts) {
  const result = parser.parse(args.slice(), opts);
  return result.argv;
};
yargsParser.detailed = function(args, opts) {
  return parser.parse(args.slice(), opts);
};
yargsParser.camelCase = camelCase;
yargsParser.decamelize = decamelize;
yargsParser.looksLikeNumber = looksLikeNumber;
var lib_default = yargsParser;

// node_modules/yargs/lib/platform-shims/esm.mjs
import { notStrictEqual, strictEqual } from "assert";

// node_modules/cliui/build/lib/index.js
var align = {
  right: alignRight,
  center: alignCenter
};
var top = 0;
var right = 1;
var bottom = 2;
var left = 3;

class UI {
  constructor(opts) {
    var _a2;
    this.width = opts.width;
    this.wrap = (_a2 = opts.wrap) !== null && _a2 !== undefined ? _a2 : true;
    this.rows = [];
  }
  span(...args) {
    const cols = this.div(...args);
    cols.span = true;
  }
  resetOutput() {
    this.rows = [];
  }
  div(...args) {
    if (args.length === 0) {
      this.div("");
    }
    if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === "string") {
      return this.applyLayoutDSL(args[0]);
    }
    const cols = args.map((arg) => {
      if (typeof arg === "string") {
        return this.colFromString(arg);
      }
      return arg;
    });
    this.rows.push(cols);
    return cols;
  }
  shouldApplyLayoutDSL(...args) {
    return args.length === 1 && typeof args[0] === "string" && /[\t\n]/.test(args[0]);
  }
  applyLayoutDSL(str) {
    const rows = str.split(`
`).map((row) => row.split("\t"));
    let leftColumnWidth = 0;
    rows.forEach((columns) => {
      if (columns.length > 1 && mixin2.stringWidth(columns[0]) > leftColumnWidth) {
        leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin2.stringWidth(columns[0]));
      }
    });
    rows.forEach((columns) => {
      this.div(...columns.map((r, i) => {
        return {
          text: r.trim(),
          padding: this.measurePadding(r),
          width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined
        };
      }));
    });
    return this.rows[this.rows.length - 1];
  }
  colFromString(text) {
    return {
      text,
      padding: this.measurePadding(text)
    };
  }
  measurePadding(str) {
    const noAnsi = mixin2.stripAnsi(str);
    return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
  }
  toString() {
    const lines = [];
    this.rows.forEach((row) => {
      this.rowToString(row, lines);
    });
    return lines.filter((line) => !line.hidden).map((line) => line.text).join(`
`);
  }
  rowToString(row, lines) {
    this.rasterize(row).forEach((rrow, r) => {
      let str = "";
      rrow.forEach((col, c) => {
        const { width } = row[c];
        const wrapWidth = this.negatePadding(row[c]);
        let ts = col;
        if (wrapWidth > mixin2.stringWidth(col)) {
          ts += " ".repeat(wrapWidth - mixin2.stringWidth(col));
        }
        if (row[c].align && row[c].align !== "left" && this.wrap) {
          const fn = align[row[c].align];
          ts = fn(ts, wrapWidth);
          if (mixin2.stringWidth(ts) < wrapWidth) {
            ts += " ".repeat((width || 0) - mixin2.stringWidth(ts) - 1);
          }
        }
        const padding = row[c].padding || [0, 0, 0, 0];
        if (padding[left]) {
          str += " ".repeat(padding[left]);
        }
        str += addBorder(row[c], ts, "| ");
        str += ts;
        str += addBorder(row[c], ts, " |");
        if (padding[right]) {
          str += " ".repeat(padding[right]);
        }
        if (r === 0 && lines.length > 0) {
          str = this.renderInline(str, lines[lines.length - 1]);
        }
      });
      lines.push({
        text: str.replace(/ +$/, ""),
        span: row.span
      });
    });
    return lines;
  }
  renderInline(source, previousLine) {
    const match = source.match(/^ */);
    const leadingWhitespace = match ? match[0].length : 0;
    const target = previousLine.text;
    const targetTextWidth = mixin2.stringWidth(target.trimRight());
    if (!previousLine.span) {
      return source;
    }
    if (!this.wrap) {
      previousLine.hidden = true;
      return target + source;
    }
    if (leadingWhitespace < targetTextWidth) {
      return source;
    }
    previousLine.hidden = true;
    return target.trimRight() + " ".repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
  }
  rasterize(row) {
    const rrows = [];
    const widths = this.columnWidths(row);
    let wrapped;
    row.forEach((col, c) => {
      col.width = widths[c];
      if (this.wrap) {
        wrapped = mixin2.wrap(col.text, this.negatePadding(col), { hard: true }).split(`
`);
      } else {
        wrapped = col.text.split(`
`);
      }
      if (col.border) {
        wrapped.unshift("." + "-".repeat(this.negatePadding(col) + 2) + ".");
        wrapped.push("'" + "-".repeat(this.negatePadding(col) + 2) + "'");
      }
      if (col.padding) {
        wrapped.unshift(...new Array(col.padding[top] || 0).fill(""));
        wrapped.push(...new Array(col.padding[bottom] || 0).fill(""));
      }
      wrapped.forEach((str, r) => {
        if (!rrows[r]) {
          rrows.push([]);
        }
        const rrow = rrows[r];
        for (let i = 0;i < c; i++) {
          if (rrow[i] === undefined) {
            rrow.push("");
          }
        }
        rrow.push(str);
      });
    });
    return rrows;
  }
  negatePadding(col) {
    let wrapWidth = col.width || 0;
    if (col.padding) {
      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
    }
    if (col.border) {
      wrapWidth -= 4;
    }
    return wrapWidth;
  }
  columnWidths(row) {
    if (!this.wrap) {
      return row.map((col) => {
        return col.width || mixin2.stringWidth(col.text);
      });
    }
    let unset = row.length;
    let remainingWidth = this.width;
    const widths = row.map((col) => {
      if (col.width) {
        unset--;
        remainingWidth -= col.width;
        return col.width;
      }
      return;
    });
    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
    return widths.map((w, i) => {
      if (w === undefined) {
        return Math.max(unsetWidth, _minWidth(row[i]));
      }
      return w;
    });
  }
}
function addBorder(col, ts, style) {
  if (col.border) {
    if (/[.']-+[.']/.test(ts)) {
      return "";
    }
    if (ts.trim().length !== 0) {
      return style;
    }
    return "  ";
  }
  return "";
}
function _minWidth(col) {
  const padding = col.padding || [];
  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
  if (col.border) {
    return minWidth + 4;
  }
  return minWidth;
}
function getWindowWidth() {
  if (typeof process === "object" && process.stdout && process.stdout.columns) {
    return process.stdout.columns;
  }
  return 80;
}
function alignRight(str, width) {
  str = str.trim();
  const strWidth = mixin2.stringWidth(str);
  if (strWidth < width) {
    return " ".repeat(width - strWidth) + str;
  }
  return str;
}
function alignCenter(str, width) {
  str = str.trim();
  const strWidth = mixin2.stringWidth(str);
  if (strWidth >= width) {
    return str;
  }
  return " ".repeat(width - strWidth >> 1) + str;
}
var mixin2;
function cliui(opts, _mixin) {
  mixin2 = _mixin;
  return new UI({
    width: (opts === null || opts === undefined ? undefined : opts.width) || getWindowWidth(),
    wrap: opts === null || opts === undefined ? undefined : opts.wrap
  });
}

// node_modules/cliui/build/lib/string-utils.js
var ansi = new RegExp("\x1B(?:\\[(?:\\d+[ABCDEFGJKSTm]|\\d+;\\d+[Hfm]|" + "\\d+;\\d+;\\d+m|6n|s|u|\\?25[lh])|\\w)", "g");
function stripAnsi(str) {
  return str.replace(ansi, "");
}
function wrap(str, width) {
  const [start, end] = str.match(ansi) || ["", ""];
  str = stripAnsi(str);
  let wrapped = "";
  for (let i = 0;i < str.length; i++) {
    if (i !== 0 && i % width === 0) {
      wrapped += `
`;
    }
    wrapped += str.charAt(i);
  }
  if (start && end) {
    wrapped = `${start}${wrapped}${end}`;
  }
  return wrapped;
}

// node_modules/cliui/index.mjs
function ui(opts) {
  return cliui(opts, {
    stringWidth: (str) => {
      return [...str].length;
    },
    stripAnsi,
    wrap
  });
}

// node_modules/escalade/sync/index.mjs
import { dirname, resolve as resolve2 } from "path";
import { readdirSync, statSync } from "fs";
function sync_default(start, callback) {
  let dir = resolve2(".", start);
  let tmp, stats = statSync(dir);
  if (!stats.isDirectory()) {
    dir = dirname(dir);
  }
  while (true) {
    tmp = callback(dir, readdirSync(dir));
    if (tmp)
      return resolve2(dir, tmp);
    dir = dirname(tmp = dir);
    if (tmp === dir)
      break;
  }
}

// node_modules/yargs/lib/platform-shims/esm.mjs
import { inspect } from "util";
import { readFileSync as readFileSync2 } from "fs";
import { fileURLToPath } from "url";
import { basename, dirname as dirname2, extname, relative, resolve as resolve4 } from "path";

// node_modules/y18n/build/lib/platform-shims/node.js
import { readFileSync, statSync as statSync2, writeFile } from "fs";
import { format as format2 } from "util";
import { resolve as resolve3 } from "path";
var node_default = {
  fs: {
    readFileSync,
    writeFile
  },
  format: format2,
  resolve: resolve3,
  exists: (file) => {
    try {
      return statSync2(file).isFile();
    } catch (err) {
      return false;
    }
  }
};

// node_modules/y18n/build/lib/index.js
var shim;

class Y18N {
  constructor(opts) {
    opts = opts || {};
    this.directory = opts.directory || "./locales";
    this.updateFiles = typeof opts.updateFiles === "boolean" ? opts.updateFiles : true;
    this.locale = opts.locale || "en";
    this.fallbackToLanguage = typeof opts.fallbackToLanguage === "boolean" ? opts.fallbackToLanguage : true;
    this.cache = Object.create(null);
    this.writeQueue = [];
  }
  __(...args) {
    if (typeof arguments[0] !== "string") {
      return this._taggedLiteral(arguments[0], ...arguments);
    }
    const str = args.shift();
    let cb = function() {
    };
    if (typeof args[args.length - 1] === "function")
      cb = args.pop();
    cb = cb || function() {
    };
    if (!this.cache[this.locale])
      this._readLocaleFile();
    if (!this.cache[this.locale][str] && this.updateFiles) {
      this.cache[this.locale][str] = str;
      this._enqueueWrite({
        directory: this.directory,
        locale: this.locale,
        cb
      });
    } else {
      cb();
    }
    return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));
  }
  __n() {
    const args = Array.prototype.slice.call(arguments);
    const singular = args.shift();
    const plural = args.shift();
    const quantity = args.shift();
    let cb = function() {
    };
    if (typeof args[args.length - 1] === "function")
      cb = args.pop();
    if (!this.cache[this.locale])
      this._readLocaleFile();
    let str = quantity === 1 ? singular : plural;
    if (this.cache[this.locale][singular]) {
      const entry = this.cache[this.locale][singular];
      str = entry[quantity === 1 ? "one" : "other"];
    }
    if (!this.cache[this.locale][singular] && this.updateFiles) {
      this.cache[this.locale][singular] = {
        one: singular,
        other: plural
      };
      this._enqueueWrite({
        directory: this.directory,
        locale: this.locale,
        cb
      });
    } else {
      cb();
    }
    const values = [str];
    if (~str.indexOf("%d"))
      values.push(quantity);
    return shim.format.apply(shim.format, values.concat(args));
  }
  setLocale(locale) {
    this.locale = locale;
  }
  getLocale() {
    return this.locale;
  }
  updateLocale(obj) {
    if (!this.cache[this.locale])
      this._readLocaleFile();
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        this.cache[this.locale][key] = obj[key];
      }
    }
  }
  _taggedLiteral(parts, ...args) {
    let str = "";
    parts.forEach(function(part, i) {
      const arg = args[i + 1];
      str += part;
      if (typeof arg !== "undefined") {
        str += "%s";
      }
    });
    return this.__.apply(this, [str].concat([].slice.call(args, 1)));
  }
  _enqueueWrite(work) {
    this.writeQueue.push(work);
    if (this.writeQueue.length === 1)
      this._processWriteQueue();
  }
  _processWriteQueue() {
    const _this = this;
    const work = this.writeQueue[0];
    const directory = work.directory;
    const locale = work.locale;
    const cb = work.cb;
    const languageFile = this._resolveLocaleFile(directory, locale);
    const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
    shim.fs.writeFile(languageFile, serializedLocale, "utf-8", function(err) {
      _this.writeQueue.shift();
      if (_this.writeQueue.length > 0)
        _this._processWriteQueue();
      cb(err);
    });
  }
  _readLocaleFile() {
    let localeLookup = {};
    const languageFile = this._resolveLocaleFile(this.directory, this.locale);
    try {
      if (shim.fs.readFileSync) {
        localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, "utf-8"));
      }
    } catch (err) {
      if (err instanceof SyntaxError) {
        err.message = "syntax error in " + languageFile;
      }
      if (err.code === "ENOENT")
        localeLookup = {};
      else
        throw err;
    }
    this.cache[this.locale] = localeLookup;
  }
  _resolveLocaleFile(directory, locale) {
    let file = shim.resolve(directory, "./", locale + ".json");
    if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf("_")) {
      const languageFile = shim.resolve(directory, "./", locale.split("_")[0] + ".json");
      if (this._fileExistsSync(languageFile))
        file = languageFile;
    }
    return file;
  }
  _fileExistsSync(file) {
    return shim.exists(file);
  }
}
function y18n(opts, _shim) {
  shim = _shim;
  const y18n2 = new Y18N(opts);
  return {
    __: y18n2.__.bind(y18n2),
    __n: y18n2.__n.bind(y18n2),
    setLocale: y18n2.setLocale.bind(y18n2),
    getLocale: y18n2.getLocale.bind(y18n2),
    updateLocale: y18n2.updateLocale.bind(y18n2),
    locale: y18n2.locale
  };
}

// node_modules/y18n/index.mjs
var y18n2 = (opts) => {
  return y18n(opts, node_default);
};
var y18n_default = y18n2;

// node_modules/yargs/lib/platform-shims/esm.mjs
var REQUIRE_ERROR = "require is not supported by ESM";
var REQUIRE_DIRECTORY_ERROR = "loading a directory of commands is not supported yet for ESM";
var __dirname2;
try {
  __dirname2 = fileURLToPath(import.meta.url);
} catch (e) {
  __dirname2 = process.cwd();
}
var mainFilename = __dirname2.substring(0, __dirname2.lastIndexOf("node_modules"));
var esm_default = {
  assert: {
    notStrictEqual,
    strictEqual
  },
  cliui: ui,
  findUp: sync_default,
  getEnv: (key) => {
    return process.env[key];
  },
  inspect,
  getCallerFile: () => {
    throw new YError(REQUIRE_DIRECTORY_ERROR);
  },
  getProcessArgvBin,
  mainFilename: mainFilename || process.cwd(),
  Parser: lib_default,
  path: {
    basename,
    dirname: dirname2,
    extname,
    relative,
    resolve: resolve4
  },
  process: {
    argv: () => process.argv,
    cwd: process.cwd,
    emitWarning: (warning, type) => process.emitWarning(warning, type),
    execPath: () => process.execPath,
    exit: process.exit,
    nextTick: process.nextTick,
    stdColumns: typeof process.stdout.columns !== "undefined" ? process.stdout.columns : null
  },
  readFileSync: readFileSync2,
  require: () => {
    throw new YError(REQUIRE_ERROR);
  },
  requireDirectory: () => {
    throw new YError(REQUIRE_DIRECTORY_ERROR);
  },
  stringWidth: (str) => {
    return [...str].length;
  },
  y18n: y18n_default({
    directory: resolve4(__dirname2, "../../../locales"),
    updateFiles: false
  })
};

// node_modules/drizzle-orm/bun-sqlite/driver.js
import { Database } from "bun:sqlite";

// node_modules/drizzle-orm/entity.js
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(`Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = Object.getPrototypeOf(value).constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}

// node_modules/drizzle-orm/logger.js
class ConsoleLogWriter {
  static [entityKind] = "ConsoleLogWriter";
  write(message) {
    console.log(message);
  }
}

class DefaultLogger {
  static [entityKind] = "DefaultLogger";
  writer;
  constructor(config) {
    this.writer = config?.writer ?? new ConsoleLogWriter;
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p) => {
      try {
        return JSON.stringify(p);
      } catch {
        return String(p);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
}

class NoopLogger {
  static [entityKind] = "NoopLogger";
  logQuery() {
  }
}

// node_modules/drizzle-orm/table.utils.js
var TableName = Symbol.for("drizzle:Name");

// node_modules/drizzle-orm/table.js
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");

class Table {
  static [entityKind] = "Table";
  static Symbol = {
    Name: TableName,
    Schema,
    OriginalName,
    Columns,
    ExtraConfigColumns,
    BaseName,
    IsAlias,
    ExtraConfigBuilder
  };
  [TableName];
  [OriginalName];
  [Schema];
  [Columns];
  [ExtraConfigColumns];
  [BaseName];
  [IsAlias] = false;
  [IsDrizzleTable] = true;
  [ExtraConfigBuilder] = undefined;
  constructor(name, schema, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema] = schema;
    this[BaseName] = baseName;
  }
}
function getTableName(table) {
  return table[TableName];
}
function getTableUniqueName(table) {
  return `${table[Schema] ?? "public"}.${table[TableName]}`;
}

// node_modules/drizzle-orm/column.js
class Column {
  constructor(table, config) {
    this.table = table;
    this.config = config;
    this.name = config.name;
    this.keyAsName = config.keyAsName;
    this.notNull = config.notNull;
    this.default = config.default;
    this.defaultFn = config.defaultFn;
    this.onUpdateFn = config.onUpdateFn;
    this.hasDefault = config.hasDefault;
    this.primary = config.primaryKey;
    this.isUnique = config.isUnique;
    this.uniqueName = config.uniqueName;
    this.uniqueType = config.uniqueType;
    this.dataType = config.dataType;
    this.columnType = config.columnType;
    this.generated = config.generated;
    this.generatedIdentity = config.generatedIdentity;
  }
  static [entityKind] = "Column";
  name;
  keyAsName;
  primary;
  notNull;
  default;
  defaultFn;
  onUpdateFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = undefined;
  generated = undefined;
  generatedIdentity = undefined;
  config;
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
  shouldDisableInsert() {
    return this.config.generated !== undefined && this.config.generated.type !== "byDefault";
  }
}

// node_modules/drizzle-orm/column-builder.js
class ColumnBuilder {
  static [entityKind] = "ColumnBuilder";
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      keyAsName: name === "",
      notNull: false,
      default: undefined,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: undefined,
      uniqueType: undefined,
      dataType,
      columnType,
      generated: undefined
    };
  }
  $type() {
    return this;
  }
  notNull() {
    this.config.notNull = true;
    return this;
  }
  default(value) {
    this.config.default = value;
    this.config.hasDefault = true;
    return this;
  }
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $default = this.$defaultFn;
  $onUpdateFn(fn) {
    this.config.onUpdateFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $onUpdate = this.$onUpdateFn;
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
  setName(name) {
    if (this.config.name !== "")
      return;
    this.config.name = name;
  }
}

// node_modules/drizzle-orm/tracing-utils.js
function iife(fn, ...args) {
  return fn(...args);
}

// node_modules/drizzle-orm/pg-core/unique-constraint.js
function uniqueKeyName(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}

// node_modules/drizzle-orm/pg-core/columns/common.js
class PgColumn extends Column {
  constructor(table, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName(table, [config.name]);
    }
    super(table, config);
    this.table = table;
  }
  static [entityKind] = "PgColumn";
}

class ExtraConfigColumn extends PgColumn {
  static [entityKind] = "ExtraConfigColumn";
  getSQLType() {
    return this.getSQLType();
  }
  indexConfig = {
    order: this.config.order ?? "asc",
    nulls: this.config.nulls ?? "last",
    opClass: this.config.opClass
  };
  defaultConfig = {
    order: "asc",
    nulls: "last",
    opClass: undefined
  };
  asc() {
    this.indexConfig.order = "asc";
    return this;
  }
  desc() {
    this.indexConfig.order = "desc";
    return this;
  }
  nullsFirst() {
    this.indexConfig.nulls = "first";
    return this;
  }
  nullsLast() {
    this.indexConfig.nulls = "last";
    return this;
  }
  op(opClass) {
    this.indexConfig.opClass = opClass;
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/columns/enum.js
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
class PgEnumColumn extends PgColumn {
  static [entityKind] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config) {
    super(table, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}

// node_modules/drizzle-orm/subquery.js
class Subquery {
  static [entityKind] = "Subquery";
  constructor(sql, selection, alias, isWith = false) {
    this._ = {
      brand: "Subquery",
      sql,
      selectedFields: selection,
      alias,
      isWith
    };
  }
}

class WithSubquery extends Subquery {
  static [entityKind] = "WithSubquery";
}

// node_modules/drizzle-orm/version.js
var version = "0.36.0";

// node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name, fn) {
    if (!otel) {
      return fn();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version);
    }
    return iife((otel2, rawTracer2) => rawTracer2.startActiveSpan(name, (span) => {
      try {
        return fn(span);
      } catch (e) {
        span.setStatus({
          code: otel2.SpanStatusCode.ERROR,
          message: e instanceof Error ? e.message : "Unknown error"
        });
        throw e;
      } finally {
        span.end();
      }
    }), otel, rawTracer);
  }
};

// node_modules/drizzle-orm/view-common.js
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// node_modules/drizzle-orm/sql/sql.js
function isSQLWrapper(value) {
  return value !== null && value !== undefined && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}

class StringChunk {
  static [entityKind] = "StringChunk";
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL([this]);
  }
}

class SQL {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
  }
  static [entityKind] = "SQL";
  decoder = noopDecoder;
  shouldInlineParams = false;
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      casing,
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === undefined) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i, p] of chunk.entries()) {
          result.push(p);
          if (i < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config);
      }
      if (is(chunk, SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === undefined ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        const columnName = casing.getColumnCasing(chunk);
        if (_config.invokeSource === "indexes") {
          return { sql: escapeName(columnName), params: [] };
        }
        return { sql: escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName), params: [] };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === undefined ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        if (is(chunk.value, Placeholder)) {
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config), params: [] };
        }
        let typings = ["none"];
        if (prepareTyping) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
      }
      if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk._.isWith) {
          return { sql: escapeName(chunk._.alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk._.sql,
          new StringChunk(") "),
          new Name(chunk._.alias)
        ], config);
      }
      if (isPgEnum(chunk)) {
        if (chunk.schema) {
          return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
        }
        return { sql: escapeName(chunk.enumName), params: [] };
      }
      if (isSQLWrapper(chunk)) {
        if (chunk.shouldOmitSQLParens?.()) {
          return this.buildQueryFromSourceParams([chunk.getSQL()], config);
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === undefined) {
      return this;
    }
    return new SQL.Aliased(this, alias);
  }
  mapWith(decoder) {
    this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
  if(condition) {
    return condition ? this : undefined;
  }
}

class Name {
  constructor(value) {
    this.value = value;
  }
  static [entityKind] = "Name";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
var noopDecoder = {
  mapFromDriverValue: (value) => value
};
var noopEncoder = {
  mapToDriverValue: (value) => value
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};

class Param {
  constructor(value, encoder = noopEncoder) {
    this.value = value;
    this.encoder = encoder;
  }
  static [entityKind] = "Param";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
((sql2) => {
  function empty() {
    return new SQL([]);
  }
  sql2.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  sql2.fromList = fromList;
  function raw(str) {
    return new SQL([new StringChunk(str)]);
  }
  sql2.raw = raw;
  function join(chunks, separator) {
    const result = [];
    for (const [i, chunk] of chunks.entries()) {
      if (i > 0 && separator !== undefined) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  sql2.join = join;
  function identifier(value) {
    return new Name(value);
  }
  sql2.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  sql2.placeholder = placeholder2;
  function param2(value, encoder) {
    return new Param(value, encoder);
  }
  sql2.param = param2;
})(sql || (sql = {}));
((SQL2) => {

  class Aliased {
    constructor(sql2, fieldAlias) {
      this.sql = sql2;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));

class Placeholder {
  constructor(name2) {
    this.name = name2;
  }
  static [entityKind] = "Placeholder";
  getSQL() {
    return new SQL([this]);
  }
}
function fillPlaceholders(params, values) {
  return params.map((p) => {
    if (is(p, Placeholder)) {
      if (!(p.name in values)) {
        throw new Error(`No value for placeholder "${p.name}" was provided`);
      }
      return values[p.name];
    }
    if (is(p, Param) && is(p.value, Placeholder)) {
      if (!(p.value.name in values)) {
        throw new Error(`No value for placeholder "${p.value.name}" was provided`);
      }
      return p.encoder.mapToDriverValue(values[p.value.name]);
    }
    return p;
  });
}

class View {
  static [entityKind] = "View";
  [ViewBaseConfig];
  constructor({ name: name2, schema, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
}
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce((result2, { path, field }, columnIndex) => {
    let decoder;
    if (is(field, Column)) {
      decoder = field;
    } else if (is(field, SQL)) {
      decoder = field.decoder;
    } else {
      decoder = field.sql.decoder;
    }
    let node = result2;
    for (const [pathChunkIndex, pathChunk] of path.entries()) {
      if (pathChunkIndex < path.length - 1) {
        if (!(pathChunk in node)) {
          node[pathChunk] = {};
        }
        node = node[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
          const objectName = path[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result2;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left2, right2) {
  const leftKeys = Object.keys(left2);
  const rightKeys = Object.keys(right2);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index, key] of leftKeys.entries()) {
    if (key !== rightKeys[index]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== undefined).map(([key, value]) => {
    if (is(value, SQL)) {
      return [key, value];
    } else {
      return [key, new Param(value, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(baseClass.prototype, name, Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null));
    }
  }
}
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
function getTableLikeName(table) {
  return is(table, Subquery) ? table._.alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}
function getColumnNameAndConfig(a, b) {
  return {
    name: typeof a === "string" && a.length > 0 ? a : "",
    config: typeof a === "object" ? a : b
  };
}
function isConfig(data) {
  if (typeof data !== "object" || data === null)
    return false;
  if (data.constructor.name !== "Object")
    return false;
  if ("logger" in data) {
    const type = typeof data["logger"];
    if (type !== "boolean" && (type !== "object" || typeof data["logger"]["logQuery"] !== "function") && type !== "undefined")
      return false;
    return true;
  }
  if ("schema" in data) {
    const type = typeof data["logger"];
    if (type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("casing" in data) {
    const type = typeof data["logger"];
    if (type !== "string" && type !== "undefined")
      return false;
    return true;
  }
  if ("mode" in data) {
    if (data["mode"] !== "default" || data["mode"] !== "planetscale" || data["mode"] !== undefined)
      return false;
    return true;
  }
  if ("connection" in data) {
    const type = typeof data["connection"];
    if (type !== "string" && type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("client" in data) {
    const type = typeof data["client"];
    if (type !== "object" && type !== "function" && type !== "undefined")
      return false;
    return true;
  }
  if (Object.keys(data).length === 0)
    return true;
  return false;
}

// node_modules/drizzle-orm/pg-core/columns/char.js
class PgChar extends PgColumn {
  static [entityKind] = "PgChar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `char` : `char(${this.length})`;
  }
}

// node_modules/drizzle-orm/pg-core/columns/uuid.js
class PgUUID extends PgColumn {
  static [entityKind] = "PgUUID";
  getSQLType() {
    return "uuid";
  }
}

// node_modules/drizzle-orm/pg-core/columns/varchar.js
class PgVarchar extends PgColumn {
  static [entityKind] = "PgVarchar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `varchar` : `varchar(${this.length})`;
  }
}

// node_modules/drizzle-orm/pg-core/table.js
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
var EnableRLS = Symbol.for("drizzle:EnableRLS");

class PgTable extends Table {
  static [entityKind] = "PgTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys,
    EnableRLS
  });
  [InlineForeignKeys] = [];
  [EnableRLS] = false;
  [Table.Symbol.ExtraConfigBuilder] = undefined;
}

// node_modules/drizzle-orm/pg-core/primary-keys.js
class PrimaryKeyBuilder {
  static [entityKind] = "PgPrimaryKeyBuilder";
  columns;
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  build(table) {
    return new PrimaryKey(table, this.columns, this.name);
  }
}

class PrimaryKey {
  constructor(table, columns, name) {
    this.table = table;
    this.columns = columns;
    this.name = name;
  }
  static [entityKind] = "PgPrimaryKey";
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
}

// node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
var eq = (left2, right2) => {
  return sql`${left2} = ${bindIfParam(right2, left2)}`;
};
var ne = (left2, right2) => {
  return sql`${left2} <> ${bindIfParam(right2, left2)}`;
};
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
var gt = (left2, right2) => {
  return sql`${left2} > ${bindIfParam(right2, left2)}`;
};
var gte = (left2, right2) => {
  return sql`${left2} >= ${bindIfParam(right2, left2)}`;
};
var lt = (left2, right2) => {
  return sql`${left2} < ${bindIfParam(right2, left2)}`;
};
var lte = (left2, right2) => {
  return sql`${left2} <= ${bindIfParam(right2, left2)}`;
};
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}

// node_modules/drizzle-orm/sql/expressions/select.js
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}

// node_modules/drizzle-orm/relations.js
class Relation {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  static [entityKind] = "Relation";
  referencedTableName;
  fieldName;
}

class Relations {
  constructor(table, config) {
    this.table = table;
    this.config = config;
  }
  static [entityKind] = "Relations";
}

class One extends Relation {
  constructor(sourceTable, referencedTable, config, isNullable) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
    this.isNullable = isNullable;
  }
  static [entityKind] = "One";
  withFieldName(fieldName) {
    const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
    relation.fieldName = fieldName;
    return relation;
  }
}

class Many extends Relation {
  constructor(sourceTable, referencedTable, config) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
  }
  static [entityKind] = "Many";
  withFieldName(fieldName) {
    const relation = new Many(this.sourceTable, this.referencedTable, this.config);
    relation.fieldName = fieldName;
    return relation;
  }
}
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (is(value, Table)) {
      const dbName = getTableUniqueName(value);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(value[Table.Symbol.Columns])) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = getTableUniqueName(value.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(configHelpers(value.table));
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function createOne(sourceTable) {
  return function one(table, config) {
    return new One(sourceTable, table, config, config?.fields.reduce((res, f) => res && f.notNull, true) ?? false);
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  };
}
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`) : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue) : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
    }
  }
  return result;
}

// node_modules/drizzle-orm/alias.js
class ColumnAliasProxyHandler {
  constructor(table) {
    this.table = table;
  }
  static [entityKind] = "ColumnAliasProxyHandler";
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
}

class TableAliasProxyHandler {
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  static [entityKind] = "TableAliasProxyHandler";
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
      });
      return proxiedColumns;
    }
    const value = target[prop];
    if (is(value, Column)) {
      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value;
  }
}
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(column, new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))));
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c) => {
    if (is(c, Column)) {
      return aliasedTableColumn(c, alias);
    }
    if (is(c, SQL)) {
      return mapColumnsInSQLToAlias(c, alias);
    }
    if (is(c, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c, alias);
    }
    return c;
  }));
}

// node_modules/drizzle-orm/selection-proxy.js
class SelectionProxyHandler {
  static [entityKind] = "SelectionProxyHandler";
  config;
  constructor(config) {
    this.config = { ...config };
  }
  get(subquery, prop) {
    if (prop === "_") {
      return {
        ...subquery["_"],
        selectedFields: new Proxy(subquery._.selectedFields, this)
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(subquery[ViewBaseConfig].selectedFields, this)
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value = columns[prop];
    if (is(value, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
        return value.sql;
      }
      const newValue = value.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value;
      }
      throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
    }
    if (is(value, Column)) {
      if (this.config.alias) {
        return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(value.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
      }
      return value;
    }
    if (typeof value !== "object" || value === null) {
      return value;
    }
    return new Proxy(value, new SelectionProxyHandler(this.config));
  }
}

// node_modules/drizzle-orm/query-promise.js
class QueryPromise {
  static [entityKind] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
}

// node_modules/drizzle-orm/sqlite-core/foreign-keys.js
class ForeignKeyBuilder {
  static [entityKind] = "SQLiteForeignKeyBuilder";
  reference;
  _onUpdate;
  _onDelete;
  constructor(config, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action;
    return this;
  }
  build(table) {
    return new ForeignKey(table, this);
  }
}

class ForeignKey {
  constructor(table, builder) {
    this.table = table;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  static [entityKind] = "SQLiteForeignKey";
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[TableName],
      ...columnNames,
      foreignColumns[0].table[TableName],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
}

// node_modules/drizzle-orm/sqlite-core/unique-constraint.js
function uniqueKeyName2(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}

// node_modules/drizzle-orm/sqlite-core/columns/common.js
class SQLiteColumnBuilder extends ColumnBuilder {
  static [entityKind] = "SQLiteColumnBuilder";
  foreignKeyConfigs = [];
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    return this;
  }
  generatedAlwaysAs(as, config) {
    this.config.generated = {
      as,
      type: "always",
      mode: config?.mode ?? "virtual"
    };
    return this;
  }
  buildForeignKeys(column, table) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return ((ref2, actions2) => {
        const builder = new ForeignKeyBuilder(() => {
          const foreignColumn = ref2();
          return { columns: [column], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder.onDelete(actions2.onDelete);
        }
        return builder.build(table);
      })(ref, actions);
    });
  }
}

class SQLiteColumn extends Column {
  constructor(table, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName2(table, [config.name]);
    }
    super(table, config);
    this.table = table;
  }
  static [entityKind] = "SQLiteColumn";
}

// node_modules/drizzle-orm/sqlite-core/columns/blob.js
class SQLiteBigIntBuilder extends SQLiteColumnBuilder {
  static [entityKind] = "SQLiteBigIntBuilder";
  constructor(name) {
    super(name, "bigint", "SQLiteBigInt");
  }
  build(table) {
    return new SQLiteBigInt(table, this.config);
  }
}

class SQLiteBigInt extends SQLiteColumn {
  static [entityKind] = "SQLiteBigInt";
  getSQLType() {
    return "blob";
  }
  mapFromDriverValue(value) {
    return BigInt(value.toString());
  }
  mapToDriverValue(value) {
    return Buffer.from(value.toString());
  }
}

class SQLiteBlobJsonBuilder extends SQLiteColumnBuilder {
  static [entityKind] = "SQLiteBlobJsonBuilder";
  constructor(name) {
    super(name, "json", "SQLiteBlobJson");
  }
  build(table) {
    return new SQLiteBlobJson(table, this.config);
  }
}

class SQLiteBlobJson extends SQLiteColumn {
  static [entityKind] = "SQLiteBlobJson";
  getSQLType() {
    return "blob";
  }
  mapFromDriverValue(value) {
    return JSON.parse(value.toString());
  }
  mapToDriverValue(value) {
    return Buffer.from(JSON.stringify(value));
  }
}

class SQLiteBlobBufferBuilder extends SQLiteColumnBuilder {
  static [entityKind] = "SQLiteBlobBufferBuilder";
  constructor(name) {
    super(name, "buffer", "SQLiteBlobBuffer");
  }
  build(table) {
    return new SQLiteBlobBuffer(table, this.config);
  }
}

class SQLiteBlobBuffer extends SQLiteColumn {
  static [entityKind] = "SQLiteBlobBuffer";
  getSQLType() {
    return "blob";
  }
}
function blob(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config?.mode === "json") {
    return new SQLiteBlobJsonBuilder(name);
  }
  if (config?.mode === "bigint") {
    return new SQLiteBigIntBuilder(name);
  }
  return new SQLiteBlobBufferBuilder(name);
}

// node_modules/drizzle-orm/sqlite-core/columns/custom.js
class SQLiteCustomColumnBuilder extends SQLiteColumnBuilder {
  static [entityKind] = "SQLiteCustomColumnBuilder";
  constructor(name, fieldConfig, customTypeParams) {
    super(name, "custom", "SQLiteCustomColumn");
    this.config.fieldConfig = fieldConfig;
    this.config.customTypeParams = customTypeParams;
  }
  build(table) {
    return new SQLiteCustomColumn(table, this.config);
  }
}

class SQLiteCustomColumn extends SQLiteColumn {
  static [entityKind] = "SQLiteCustomColumn";
  sqlName;
  mapTo;
  mapFrom;
  constructor(table, config) {
    super(table, config);
    this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
    this.mapTo = config.customTypeParams.toDriver;
    this.mapFrom = config.customTypeParams.fromDriver;
  }
  getSQLType() {
    return this.sqlName;
  }
  mapFromDriverValue(value) {
    return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
  }
  mapToDriverValue(value) {
    return typeof this.mapTo === "function" ? this.mapTo(value) : value;
  }
}
function customType(customTypeParams) {
  return (a, b) => {
    const { name, config } = getColumnNameAndConfig(a, b);
    return new SQLiteCustomColumnBuilder(name, config, customTypeParams);
  };
}

// node_modules/drizzle-orm/sqlite-core/columns/integer.js
class SQLiteBaseIntegerBuilder extends SQLiteColumnBuilder {
  static [entityKind] = "SQLiteBaseIntegerBuilder";
  constructor(name, dataType, columnType) {
    super(name, dataType, columnType);
    this.config.autoIncrement = false;
  }
  primaryKey(config) {
    if (config?.autoIncrement) {
      this.config.autoIncrement = true;
    }
    this.config.hasDefault = true;
    return super.primaryKey();
  }
}

class SQLiteBaseInteger extends SQLiteColumn {
  static [entityKind] = "SQLiteBaseInteger";
  autoIncrement = this.config.autoIncrement;
  getSQLType() {
    return "integer";
  }
}

class SQLiteIntegerBuilder extends SQLiteBaseIntegerBuilder {
  static [entityKind] = "SQLiteIntegerBuilder";
  constructor(name) {
    super(name, "number", "SQLiteInteger");
  }
  build(table) {
    return new SQLiteInteger(table, this.config);
  }
}

class SQLiteInteger extends SQLiteBaseInteger {
  static [entityKind] = "SQLiteInteger";
}

class SQLiteTimestampBuilder extends SQLiteBaseIntegerBuilder {
  static [entityKind] = "SQLiteTimestampBuilder";
  constructor(name, mode) {
    super(name, "date", "SQLiteTimestamp");
    this.config.mode = mode;
  }
  defaultNow() {
    return this.default(sql`(cast((julianday('now') - 2440587.5)*86400000 as integer))`);
  }
  build(table) {
    return new SQLiteTimestamp(table, this.config);
  }
}

class SQLiteTimestamp extends SQLiteBaseInteger {
  static [entityKind] = "SQLiteTimestamp";
  mode = this.config.mode;
  mapFromDriverValue(value) {
    if (this.config.mode === "timestamp") {
      return new Date(value * 1000);
    }
    return new Date(value);
  }
  mapToDriverValue(value) {
    const unix = value.getTime();
    if (this.config.mode === "timestamp") {
      return Math.floor(unix / 1000);
    }
    return unix;
  }
}

class SQLiteBooleanBuilder extends SQLiteBaseIntegerBuilder {
  static [entityKind] = "SQLiteBooleanBuilder";
  constructor(name, mode) {
    super(name, "boolean", "SQLiteBoolean");
    this.config.mode = mode;
  }
  build(table) {
    return new SQLiteBoolean(table, this.config);
  }
}

class SQLiteBoolean extends SQLiteBaseInteger {
  static [entityKind] = "SQLiteBoolean";
  mode = this.config.mode;
  mapFromDriverValue(value) {
    return Number(value) === 1;
  }
  mapToDriverValue(value) {
    return value ? 1 : 0;
  }
}
function integer(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config?.mode === "timestamp" || config?.mode === "timestamp_ms") {
    return new SQLiteTimestampBuilder(name, config.mode);
  }
  if (config?.mode === "boolean") {
    return new SQLiteBooleanBuilder(name, config.mode);
  }
  return new SQLiteIntegerBuilder(name);
}

// node_modules/drizzle-orm/sqlite-core/columns/numeric.js
class SQLiteNumericBuilder extends SQLiteColumnBuilder {
  static [entityKind] = "SQLiteNumericBuilder";
  constructor(name) {
    super(name, "string", "SQLiteNumeric");
  }
  build(table) {
    return new SQLiteNumeric(table, this.config);
  }
}

class SQLiteNumeric extends SQLiteColumn {
  static [entityKind] = "SQLiteNumeric";
  getSQLType() {
    return "numeric";
  }
}
function numeric(name) {
  return new SQLiteNumericBuilder(name ?? "");
}

// node_modules/drizzle-orm/sqlite-core/columns/real.js
class SQLiteRealBuilder extends SQLiteColumnBuilder {
  static [entityKind] = "SQLiteRealBuilder";
  constructor(name) {
    super(name, "number", "SQLiteReal");
  }
  build(table) {
    return new SQLiteReal(table, this.config);
  }
}

class SQLiteReal extends SQLiteColumn {
  static [entityKind] = "SQLiteReal";
  getSQLType() {
    return "real";
  }
}
function real(name) {
  return new SQLiteRealBuilder(name ?? "");
}

// node_modules/drizzle-orm/sqlite-core/columns/text.js
class SQLiteTextBuilder extends SQLiteColumnBuilder {
  static [entityKind] = "SQLiteTextBuilder";
  constructor(name, config) {
    super(name, "string", "SQLiteText");
    this.config.enumValues = config.enum;
    this.config.length = config.length;
  }
  build(table) {
    return new SQLiteText(table, this.config);
  }
}

class SQLiteText extends SQLiteColumn {
  static [entityKind] = "SQLiteText";
  enumValues = this.config.enumValues;
  length = this.config.length;
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return `text${this.config.length ? `(${this.config.length})` : ""}`;
  }
}

class SQLiteTextJsonBuilder extends SQLiteColumnBuilder {
  static [entityKind] = "SQLiteTextJsonBuilder";
  constructor(name) {
    super(name, "json", "SQLiteTextJson");
  }
  build(table) {
    return new SQLiteTextJson(table, this.config);
  }
}

class SQLiteTextJson extends SQLiteColumn {
  static [entityKind] = "SQLiteTextJson";
  getSQLType() {
    return "text";
  }
  mapFromDriverValue(value) {
    return JSON.parse(value);
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
}
function text(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config.mode === "json") {
    return new SQLiteTextJsonBuilder(name);
  }
  return new SQLiteTextBuilder(name, config);
}

// node_modules/drizzle-orm/sqlite-core/columns/all.js
function getSQLiteColumnBuilders() {
  return {
    blob,
    customType,
    integer,
    numeric,
    real,
    text
  };
}

// node_modules/drizzle-orm/sqlite-core/table.js
var InlineForeignKeys2 = Symbol.for("drizzle:SQLiteInlineForeignKeys");

class SQLiteTable extends Table {
  static [entityKind] = "SQLiteTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys: InlineForeignKeys2
  });
  [Table.Symbol.Columns];
  [InlineForeignKeys2] = [];
  [Table.Symbol.ExtraConfigBuilder] = undefined;
}
function sqliteTableBase(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new SQLiteTable(name, schema, baseName);
  const parsedColumns = typeof columns === "function" ? columns(getSQLiteColumnBuilders()) : columns;
  const builtColumns = Object.fromEntries(Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name2);
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys2].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name2, column];
  }));
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  table[Table.Symbol.ExtraConfigColumns] = builtColumns;
  if (extraConfig) {
    table[SQLiteTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table;
}
var sqliteTable = (name, columns, extraConfig) => {
  return sqliteTableBase(name, columns, extraConfig);
};

// node_modules/drizzle-orm/sqlite-core/query-builders/delete.js
class SQLiteDeleteBase extends QueryPromise {
  constructor(table, session, dialect, withList) {
    super();
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.config = { table, withList };
  }
  static [entityKind] = "SQLiteDelete";
  config;
  where(where) {
    this.config.where = where;
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.table[Table.Symbol.Columns], new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      this.config.orderBy = orderByArray;
    } else {
      const orderByArray = columns;
      this.config.orderBy = orderByArray;
    }
    return this;
  }
  limit(limit) {
    this.config.limit = limit;
    return this;
  }
  returning(fields = this.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(isOneTimeQuery = true) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? "all" : "run", true);
  }
  prepare() {
    return this._prepare(false);
  }
  run = (placeholderValues) => {
    return this._prepare().run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this._prepare().all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this._prepare().get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this._prepare().values(placeholderValues);
  };
  async execute(placeholderValues) {
    return this._prepare().execute(placeholderValues);
  }
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/sqlite-core/query-builders/insert.js
class SQLiteInsertBuilder {
  constructor(table, session, dialect, withList) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  static [entityKind] = "SQLiteInsertBuilder";
  values(values) {
    values = Array.isArray(values) ? values : [values];
    if (values.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new SQLiteInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList);
  }
}

class SQLiteInsertBase extends QueryPromise {
  constructor(table, values, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, values, withList };
  }
  static [entityKind] = "SQLiteInsert";
  config;
  returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  onConflictDoNothing(config = {}) {
    if (config.target === undefined) {
      this.config.onConflict = sql`do nothing`;
    } else {
      const targetSql = Array.isArray(config.target) ? sql`${config.target}` : sql`${[config.target]}`;
      const whereSql = config.where ? sql` where ${config.where}` : sql``;
      this.config.onConflict = sql`${targetSql} do nothing${whereSql}`;
    }
    return this;
  }
  onConflictDoUpdate(config) {
    if (config.where && (config.targetWhere || config.setWhere)) {
      throw new Error('You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.');
    }
    const whereSql = config.where ? sql` where ${config.where}` : undefined;
    const targetWhereSql = config.targetWhere ? sql` where ${config.targetWhere}` : undefined;
    const setWhereSql = config.setWhere ? sql` where ${config.setWhere}` : undefined;
    const targetSql = Array.isArray(config.target) ? sql`${config.target}` : sql`${[config.target]}`;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
    this.config.onConflict = sql`${targetSql}${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;
    return this;
  }
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(isOneTimeQuery = true) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? "all" : "run", true);
  }
  prepare() {
    return this._prepare(false);
  }
  run = (placeholderValues) => {
    return this._prepare().run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this._prepare().all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this._prepare().get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this._prepare().values(placeholderValues);
  };
  async execute() {
    return this.config.returning ? this.all() : this.run();
  }
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/casing.js
function toSnakeCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.map((word) => word.toLowerCase()).join("_");
}
function toCamelCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.reduce((acc, word, i) => {
    const formattedWord = i === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;
    return acc + formattedWord;
  }, "");
}
function noopCase(input) {
  return input;
}

class CasingCache {
  static [entityKind] = "CasingCache";
  cache = {};
  cachedTables = {};
  convert;
  constructor(casing) {
    this.convert = casing === "snake_case" ? toSnakeCase : casing === "camelCase" ? toCamelCase : noopCase;
  }
  getColumnCasing(column) {
    if (!column.keyAsName)
      return column.name;
    const schema = column.table[Table.Symbol.Schema] ?? "public";
    const tableName = column.table[Table.Symbol.OriginalName];
    const key = `${schema}.${tableName}.${column.name}`;
    if (!this.cache[key]) {
      this.cacheTable(column.table);
    }
    return this.cache[key];
  }
  cacheTable(table) {
    const schema = table[Table.Symbol.Schema] ?? "public";
    const tableName = table[Table.Symbol.OriginalName];
    const tableKey = `${schema}.${tableName}`;
    if (!this.cachedTables[tableKey]) {
      for (const column of Object.values(table[Table.Symbol.Columns])) {
        const columnKey = `${tableKey}.${column.name}`;
        this.cache[columnKey] = this.convert(column.name);
      }
      this.cachedTables[tableKey] = true;
    }
  }
  clearCache() {
    this.cache = {};
    this.cachedTables = {};
  }
}

// node_modules/drizzle-orm/errors.js
class DrizzleError extends Error {
  static [entityKind] = "DrizzleError";
  constructor({ message, cause }) {
    super(message);
    this.name = "DrizzleError";
    this.cause = cause;
  }
}

class TransactionRollbackError extends DrizzleError {
  static [entityKind] = "TransactionRollbackError";
  constructor() {
    super({ message: "Rollback" });
  }
}

// node_modules/drizzle-orm/sqlite-core/view-base.js
class SQLiteViewBase extends View {
  static [entityKind] = "SQLiteViewBase";
}

// node_modules/drizzle-orm/sqlite-core/dialect.js
class SQLiteDialect {
  static [entityKind] = "SQLiteDialect";
  casing;
  constructor(config) {
    this.casing = new CasingCache(config?.casing);
  }
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(_num) {
    return "?";
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildWithCTE(queries) {
    if (!queries?.length)
      return;
    const withSqlChunks = [sql`with `];
    for (const [i, w] of queries.entries()) {
      withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
      if (i < queries.length - 1) {
        withSqlChunks.push(sql`, `);
      }
    }
    withSqlChunks.push(sql` `);
    return sql.join(withSqlChunks);
  }
  buildDeleteQuery({ table, where, returning, withList, limit, orderBy }) {
    const withSql = this.buildWithCTE(withList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    const orderBySql = this.buildOrderBy(orderBy);
    const limitSql = this.buildLimit(limit);
    return sql`${withSql}delete from ${table}${whereSql}${returningSql}${orderBySql}${limitSql}`;
  }
  buildUpdateSet(table, set2) {
    const tableColumns = table[Table.Symbol.Columns];
    const columnNames = Object.keys(tableColumns).filter((colName) => set2[colName] !== undefined || tableColumns[colName]?.onUpdateFn !== undefined);
    const setSize = columnNames.length;
    return sql.join(columnNames.flatMap((colName, i) => {
      const col = tableColumns[colName];
      const value = set2[colName] ?? sql.param(col.onUpdateFn(), col);
      const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;
      if (i < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table, set: set2, where, returning, withList, limit, orderBy }) {
    const withSql = this.buildWithCTE(withList);
    const setSql = this.buildUpdateSet(table, set2);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    const orderBySql = this.buildOrderBy(orderBy);
    const limitSql = this.buildLimit(limit);
    return sql`${withSql}update ${table} set ${setSql}${whereSql}${returningSql}${orderBySql}${limitSql}`;
  }
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(new SQL(query.queryChunks.map((c) => {
            if (is(c, Column)) {
              return sql.identifier(this.casing.getColumnCasing(c));
            }
            return c;
          })));
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        const tableName = field.table[Table.Symbol.Name];
        if (isSingleTable) {
          chunk.push(sql.identifier(this.casing.getColumnCasing(field)));
        } else {
          chunk.push(sql`${sql.identifier(tableName)}.${sql.identifier(this.casing.getColumnCasing(field))}`);
        }
      }
      if (i < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildLimit(limit) {
    return typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
  }
  buildOrderBy(orderBy) {
    const orderByList = [];
    if (orderBy) {
      for (const [index, orderByValue] of orderBy.entries()) {
        orderByList.push(orderByValue);
        if (index < orderBy.length - 1) {
          orderByList.push(sql`, `);
        }
      }
    }
    return orderByList.length > 0 ? sql` order by ${sql.join(orderByList)}` : undefined;
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f of fieldsList) {
      if (is(f.field, Column) && getTableName(f.field.table) !== (is(table, Subquery) ? table._.alias : is(table, SQLiteViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : getTableName(table)) && !((table2) => joins?.some(({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])))(f.field.table)) {
        const tableName = getTableName(f.field.table);
        throw new Error(`Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    const withSql = this.buildWithCTE(withList);
    const distinctSql = distinct ? sql` distinct` : undefined;
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = (() => {
      if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
        return sql`${sql.identifier(table[Table.Symbol.OriginalName])} ${sql.identifier(table[Table.Symbol.Name])}`;
      }
      return table;
    })();
    const joinsArray = [];
    if (joins) {
      for (const [index, joinMeta] of joins.entries()) {
        if (index === 0) {
          joinsArray.push(sql` `);
        }
        const table2 = joinMeta.table;
        if (is(table2, SQLiteTable)) {
          const tableName = table2[SQLiteTable.Symbol.Name];
          const tableSchema = table2[SQLiteTable.Symbol.Schema];
          const origTableName = table2[SQLiteTable.Symbol.OriginalName];
          const alias = tableName === origTableName ? undefined : joinMeta.alias;
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
        } else {
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join ${table2} on ${joinMeta.on}`);
        }
        if (index < joins.length - 1) {
          joinsArray.push(sql` `);
        }
      }
    }
    const joinsSql = sql.join(joinsArray);
    const whereSql = where ? sql` where ${where}` : undefined;
    const havingSql = having ? sql` having ${having}` : undefined;
    const groupByList = [];
    if (groupBy) {
      for (const [index, groupByValue] of groupBy.entries()) {
        groupByList.push(groupByValue);
        if (index < groupBy.length - 1) {
          groupByList.push(sql`, `);
        }
      }
    }
    const groupBySql = groupByList.length > 0 ? sql` group by ${sql.join(groupByList)}` : undefined;
    const orderBySql = this.buildOrderBy(orderBy);
    const limitSql = this.buildLimit(limit);
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(this.buildSetOperationQuery({ leftSelect, setOperator }), rest);
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql`${leftSelect.getSQL()} `;
    const rightChunk = sql`${rightSelect.getSQL()}`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is(singleOrderBy, SQLiteColumn)) {
          orderByValues.push(sql.identifier(singleOrderBy.name));
        } else if (is(singleOrderBy, SQL)) {
          for (let i = 0;i < singleOrderBy.queryChunks.length; i++) {
            const chunk = singleOrderBy.queryChunks[i];
            if (is(chunk, SQLiteColumn)) {
              singleOrderBy.queryChunks[i] = sql.identifier(this.casing.getColumnCasing(chunk));
            }
          }
          orderByValues.push(sql`${singleOrderBy}`);
        } else {
          orderByValues.push(sql`${singleOrderBy}`);
        }
      }
      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)}`;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
    const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table, values, onConflict, returning, withList }) {
    const valuesSqlList = [];
    const columns = table[Table.Symbol.Columns];
    const colEntries = Object.entries(columns).filter(([_, col]) => !col.shouldDisableInsert());
    const insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));
    for (const [valueIndex, value] of values.entries()) {
      const valueList = [];
      for (const [fieldName, col] of colEntries) {
        const colValue = value[fieldName];
        if (colValue === undefined || is(colValue, Param) && colValue.value === undefined) {
          let defaultValue;
          if (col.default !== null && col.default !== undefined) {
            defaultValue = is(col.default, SQL) ? col.default : sql.param(col.default, col);
          } else if (col.defaultFn !== undefined) {
            const defaultFnResult = col.defaultFn();
            defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
          } else if (!col.default && col.onUpdateFn !== undefined) {
            const onUpdateFnResult = col.onUpdateFn();
            defaultValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
          } else {
            defaultValue = sql`null`;
          }
          valueList.push(defaultValue);
        } else {
          valueList.push(colValue);
        }
      }
      valuesSqlList.push(valueList);
      if (valueIndex < values.length - 1) {
        valuesSqlList.push(sql`, `);
      }
    }
    const withSql = this.buildWithCTE(withList);
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : undefined;
    return sql`${withSql}insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
  }
  sqlToQuery(sql2, invokeSource) {
    return sql2.toQuery({
      casing: this.casing,
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      invokeSource
    });
  }
  buildRelationalQuery({
    fullSchema,
    schema,
    tableNamesMap,
    table,
    tableConfig,
    queryConfig: config,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: undefined,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
      if (config.where) {
        const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config.columns)) {
          if (value === undefined) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config.with) {
        selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config.extras) {
        extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: undefined,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config.limit;
      offset = config.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = getTableUniqueName(relation.referencedTable);
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i) => eq(aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQuery({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`(${builtRelation.sql})`.as(selectedRelationTsKey);
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({
        message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`
      });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_array(${sql.join(selection.map(({ field: field2 }) => is(field2, SQLiteColumn) ? sql.identifier(this.casing.getColumnCasing(field2)) : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_group_array(${field}), json_array())`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [
            {
              path: [],
              field: sql.raw("*")
            }
          ],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = undefined;
        limit = undefined;
        offset = undefined;
        orderBy = undefined;
      } else {
        result = aliasedTable(table, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, SQLiteTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
}

class SQLiteSyncDialect extends SQLiteDialect {
  static [entityKind] = "SQLiteSyncDialect";
  migrate(migrations, session, config) {
    const migrationsTable = config === undefined ? "__drizzle_migrations" : typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
    session.run(migrationTableCreate);
    const dbMigrations = session.values(sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`);
    const lastDbMigration = dbMigrations[0] ?? undefined;
    session.run(sql`BEGIN`);
    try {
      for (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            session.run(sql.raw(stmt));
          }
          session.run(sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
        }
      }
      session.run(sql`COMMIT`);
    } catch (e) {
      session.run(sql`ROLLBACK`);
      throw e;
    }
  }
}

// node_modules/drizzle-orm/query-builders/query-builder.js
class TypedQueryBuilder {
  static [entityKind] = "TypedQueryBuilder";
  getSelectedFields() {
    return this._.selectedFields;
  }
}

// node_modules/drizzle-orm/sqlite-core/query-builders/select.js
class SQLiteSelectBuilder {
  static [entityKind] = "SQLiteSelectBuilder";
  fields;
  session;
  dialect;
  withList;
  distinct;
  constructor(config) {
    this.fields = config.fields;
    this.session = config.session;
    this.dialect = config.dialect;
    this.withList = config.withList;
    this.distinct = config.distinct;
  }
  from(source) {
    const isPartialSelect = !!this.fields;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(source, Subquery)) {
      fields = Object.fromEntries(Object.keys(source._.selectedFields).map((key) => [key, source[key]]));
    } else if (is(source, SQLiteViewBase)) {
      fields = source[ViewBaseConfig].selectedFields;
    } else if (is(source, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(source);
    }
    return new SQLiteSelectBase({
      table: source,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    });
  }
}

class SQLiteSelectQueryBuilderBase extends TypedQueryBuilder {
  static [entityKind] = "SQLiteSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  createJoin(joinType) {
    return (table, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table._.selectedFields : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  createSetOperator(type, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getSQLiteSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
      this.config.setOperators.push({ type, isAll, rightSelect });
      return this;
    };
  }
  union = this.createSetOperator("union", false);
  unionAll = this.createSetOperator("union", true);
  intersect = this.createSetOperator("intersect", false);
  except = this.createSetOperator("except", false);
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  getSelectedFields() {
    return new Proxy(this.config.fields, new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  $dynamic() {
    return this;
  }
}

class SQLiteSelectBase extends SQLiteSelectQueryBuilderBase {
  static [entityKind] = "SQLiteSelect";
  _prepare(isOneTimeQuery = true) {
    if (!this.session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    const fieldsList = orderSelectedFields(this.config.fields);
    const query = this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](this.dialect.sqlToQuery(this.getSQL()), fieldsList, "all", true);
    query.joinsNotNullableMap = this.joinsNotNullableMap;
    return query;
  }
  prepare() {
    return this._prepare(false);
  }
  run = (placeholderValues) => {
    return this._prepare().run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this._prepare().all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this._prepare().get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this._prepare().values(placeholderValues);
  };
  async execute() {
    return this.all();
  }
}
applyMixins(SQLiteSelectBase, [QueryPromise]);
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var getSQLiteSetOperators = () => ({
  union,
  unionAll,
  intersect,
  except
});
var union = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect = createSetOperator("intersect", false);
var except = createSetOperator("except", false);

// node_modules/drizzle-orm/sqlite-core/query-builders/query-builder.js
class QueryBuilder {
  static [entityKind] = "SQLiteQueryBuilder";
  dialect;
  dialectConfig;
  constructor(dialect) {
    this.dialect = is(dialect, SQLiteDialect) ? dialect : undefined;
    this.dialectConfig = is(dialect, SQLiteDialect) ? undefined : dialect;
  }
  $with(alias) {
    const queryBuilder = this;
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(queryBuilder);
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  with(...queries) {
    const self = this;
    function select(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self.getDialect(),
        withList: queries,
        distinct: true
      });
    }
    return { select, selectDistinct };
  }
  select(fields) {
    return new SQLiteSelectBuilder({ fields: fields ?? undefined, session: undefined, dialect: this.getDialect() });
  }
  selectDistinct(fields) {
    return new SQLiteSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  getDialect() {
    if (!this.dialect) {
      this.dialect = new SQLiteSyncDialect(this.dialectConfig);
    }
    return this.dialect;
  }
}

// node_modules/drizzle-orm/sqlite-core/query-builders/update.js
class SQLiteUpdateBuilder {
  constructor(table, session, dialect, withList) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  static [entityKind] = "SQLiteUpdateBuilder";
  set(values) {
    return new SQLiteUpdateBase(this.table, mapUpdateSet(this.table, values), this.session, this.dialect, this.withList);
  }
}

class SQLiteUpdateBase extends QueryPromise {
  constructor(table, set2, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { set: set2, table, withList };
  }
  static [entityKind] = "SQLiteUpdate";
  config;
  where(where) {
    this.config.where = where;
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.table[Table.Symbol.Columns], new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      this.config.orderBy = orderByArray;
    } else {
      const orderByArray = columns;
      this.config.orderBy = orderByArray;
    }
    return this;
  }
  limit(limit) {
    this.config.limit = limit;
    return this;
  }
  returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(isOneTimeQuery = true) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? "all" : "run", true);
  }
  prepare() {
    return this._prepare(false);
  }
  run = (placeholderValues) => {
    return this._prepare().run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this._prepare().all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this._prepare().get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this._prepare().values(placeholderValues);
  };
  async execute() {
    return this.config.returning ? this.all() : this.run();
  }
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/sqlite-core/query-builders/count.js
class SQLiteCountBuilder extends SQL {
  constructor(params) {
    super(SQLiteCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);
    this.params = params;
    this.session = params.session;
    this.sql = SQLiteCountBuilder.buildCount(params.source, params.filters);
  }
  sql;
  static [entityKind] = "SQLiteCountBuilderAsync";
  [Symbol.toStringTag] = "SQLiteCountBuilderAsync";
  session;
  static buildEmbeddedCount(source, filters) {
    return sql`(select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters})`;
  }
  static buildCount(source, filters) {
    return sql`select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters}`;
  }
  then(onfulfilled, onrejected) {
    return Promise.resolve(this.session.count(this.sql)).then(onfulfilled, onrejected);
  }
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
}

// node_modules/drizzle-orm/sqlite-core/query-builders/query.js
class RelationalQueryBuilder {
  constructor(mode, fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
    this.mode = mode;
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
  }
  static [entityKind] = "SQLiteAsyncRelationalQueryBuilder";
  findMany(config) {
    return this.mode === "sync" ? new SQLiteSyncRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, "many") : new SQLiteRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, "many");
  }
  findFirst(config) {
    return this.mode === "sync" ? new SQLiteSyncRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, "first") : new SQLiteRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, "first");
  }
}

class SQLiteRelationalQuery extends QueryPromise {
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
    this.config = config;
    this.mode = mode;
  }
  static [entityKind] = "SQLiteAsyncRelationalQuery";
  mode;
  getSQL() {
    return this.dialect.buildRelationalQuery({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    }).sql;
  }
  _prepare(isOneTimeQuery = false) {
    const { query, builtQuery } = this._toSQL();
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](builtQuery, undefined, this.mode === "first" ? "get" : "all", true, (rawRows, mapColumnValue) => {
      const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
      if (this.mode === "first") {
        return rows[0];
      }
      return rows;
    });
  }
  prepare() {
    return this._prepare(false);
  }
  _toSQL() {
    const query = this.dialect.buildRelationalQuery({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  executeRaw() {
    if (this.mode === "first") {
      return this._prepare(false).get();
    }
    return this._prepare(false).all();
  }
  async execute() {
    return this.executeRaw();
  }
}

class SQLiteSyncRelationalQuery extends SQLiteRelationalQuery {
  static [entityKind] = "SQLiteSyncRelationalQuery";
  sync() {
    return this.executeRaw();
  }
}

// node_modules/drizzle-orm/sqlite-core/query-builders/raw.js
class SQLiteRaw extends QueryPromise {
  constructor(execute, getSQL, action, dialect, mapBatchResult) {
    super();
    this.execute = execute;
    this.getSQL = getSQL;
    this.dialect = dialect;
    this.mapBatchResult = mapBatchResult;
    this.config = { action };
  }
  static [entityKind] = "SQLiteRaw";
  config;
  getQuery() {
    return { ...this.dialect.sqlToQuery(this.getSQL()), method: this.config.action };
  }
  mapResult(result, isFromBatch) {
    return isFromBatch ? this.mapBatchResult(result) : result;
  }
  _prepare() {
    return this;
  }
  isResponseInArrayMode() {
    return false;
  }
}

// node_modules/drizzle-orm/sqlite-core/db.js
class BaseSQLiteDatabase {
  constructor(resultKind, dialect, session, schema) {
    this.resultKind = resultKind;
    this.dialect = dialect;
    this.session = session;
    this._ = schema ? {
      schema: schema.schema,
      fullSchema: schema.fullSchema,
      tableNamesMap: schema.tableNamesMap
    } : {
      schema: undefined,
      fullSchema: {},
      tableNamesMap: {}
    };
    this.query = {};
    const query = this.query;
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        query[tableName] = new RelationalQueryBuilder(resultKind, schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session);
      }
    }
  }
  static [entityKind] = "BaseSQLiteDatabase";
  query;
  $with(alias) {
    const self = this;
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder(self.dialect));
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  $count(source, filters) {
    return new SQLiteCountBuilder({ source, filters, session: this.session });
  }
  with(...queries) {
    const self = this;
    function select(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? undefined,
        session: self.session,
        dialect: self.dialect,
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? undefined,
        session: self.session,
        dialect: self.dialect,
        withList: queries,
        distinct: true
      });
    }
    function update(table) {
      return new SQLiteUpdateBuilder(table, self.session, self.dialect, queries);
    }
    function insert(into) {
      return new SQLiteInsertBuilder(into, self.session, self.dialect, queries);
    }
    function delete_(from) {
      return new SQLiteDeleteBase(from, self.session, self.dialect, queries);
    }
    return { select, selectDistinct, update, insert, delete: delete_ };
  }
  select(fields) {
    return new SQLiteSelectBuilder({ fields: fields ?? undefined, session: this.session, dialect: this.dialect });
  }
  selectDistinct(fields) {
    return new SQLiteSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  update(table) {
    return new SQLiteUpdateBuilder(table, this.session, this.dialect);
  }
  insert(into) {
    return new SQLiteInsertBuilder(into, this.session, this.dialect);
  }
  delete(from) {
    return new SQLiteDeleteBase(from, this.session, this.dialect);
  }
  run(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(async () => this.session.run(sequel), () => sequel, "run", this.dialect, this.session.extractRawRunValueFromBatchResult.bind(this.session));
    }
    return this.session.run(sequel);
  }
  all(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(async () => this.session.all(sequel), () => sequel, "all", this.dialect, this.session.extractRawAllValueFromBatchResult.bind(this.session));
    }
    return this.session.all(sequel);
  }
  get(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(async () => this.session.get(sequel), () => sequel, "get", this.dialect, this.session.extractRawGetValueFromBatchResult.bind(this.session));
    }
    return this.session.get(sequel);
  }
  values(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(async () => this.session.values(sequel), () => sequel, "values", this.dialect, this.session.extractRawValuesValueFromBatchResult.bind(this.session));
    }
    return this.session.values(sequel);
  }
  transaction(transaction, config) {
    return this.session.transaction(transaction, config);
  }
}

// node_modules/drizzle-orm/sqlite-core/session.js
class ExecuteResultSync extends QueryPromise {
  constructor(resultCb) {
    super();
    this.resultCb = resultCb;
  }
  static [entityKind] = "ExecuteResultSync";
  async execute() {
    return this.resultCb();
  }
  sync() {
    return this.resultCb();
  }
}

class SQLitePreparedQuery {
  constructor(mode, executeMethod, query) {
    this.mode = mode;
    this.executeMethod = executeMethod;
    this.query = query;
  }
  static [entityKind] = "PreparedQuery";
  joinsNotNullableMap;
  getQuery() {
    return this.query;
  }
  mapRunResult(result, _isFromBatch) {
    return result;
  }
  mapAllResult(_result, _isFromBatch) {
    throw new Error("Not implemented");
  }
  mapGetResult(_result, _isFromBatch) {
    throw new Error("Not implemented");
  }
  execute(placeholderValues) {
    if (this.mode === "async") {
      return this[this.executeMethod](placeholderValues);
    }
    return new ExecuteResultSync(() => this[this.executeMethod](placeholderValues));
  }
  mapResult(response, isFromBatch) {
    switch (this.executeMethod) {
      case "run": {
        return this.mapRunResult(response, isFromBatch);
      }
      case "all": {
        return this.mapAllResult(response, isFromBatch);
      }
      case "get": {
        return this.mapGetResult(response, isFromBatch);
      }
    }
  }
}

class SQLiteSession {
  constructor(dialect) {
    this.dialect = dialect;
  }
  static [entityKind] = "SQLiteSession";
  prepareOneTimeQuery(query, fields, executeMethod, isResponseInArrayMode) {
    return this.prepareQuery(query, fields, executeMethod, isResponseInArrayMode);
  }
  run(query) {
    const staticQuery = this.dialect.sqlToQuery(query);
    try {
      return this.prepareOneTimeQuery(staticQuery, undefined, "run", false).run();
    } catch (err) {
      throw new DrizzleError({ cause: err, message: `Failed to run the query '${staticQuery.sql}'` });
    }
  }
  extractRawRunValueFromBatchResult(result) {
    return result;
  }
  all(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, "run", false).all();
  }
  extractRawAllValueFromBatchResult(_result) {
    throw new Error("Not implemented");
  }
  get(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, "run", false).get();
  }
  extractRawGetValueFromBatchResult(_result) {
    throw new Error("Not implemented");
  }
  values(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, "run", false).values();
  }
  async count(sql2) {
    const result = await this.values(sql2);
    return result[0][0];
  }
  extractRawValuesValueFromBatchResult(_result) {
    throw new Error("Not implemented");
  }
}

class SQLiteTransaction extends BaseSQLiteDatabase {
  constructor(resultType, dialect, session, schema, nestedIndex = 0) {
    super(resultType, dialect, session, schema);
    this.schema = schema;
    this.nestedIndex = nestedIndex;
  }
  static [entityKind] = "SQLiteTransaction";
  rollback() {
    throw new TransactionRollbackError;
  }
}

// node_modules/drizzle-orm/bun-sqlite/session.js
class SQLiteBunSession extends SQLiteSession {
  constructor(client, dialect, schema, options = {}) {
    super(dialect);
    this.client = client;
    this.schema = schema;
    this.logger = options.logger ?? new NoopLogger;
  }
  static [entityKind] = "SQLiteBunSession";
  logger;
  exec(query) {
    this.client.exec(query);
  }
  prepareQuery(query, fields, executeMethod, isResponseInArrayMode, customResultMapper) {
    const stmt = this.client.prepare(query.sql);
    return new PreparedQuery(stmt, query, this.logger, fields, executeMethod, isResponseInArrayMode, customResultMapper);
  }
  transaction(transaction, config = {}) {
    const tx = new SQLiteBunTransaction("sync", this.dialect, this, this.schema);
    let result;
    const nativeTx = this.client.transaction(() => {
      result = transaction(tx);
    });
    nativeTx[config.behavior ?? "deferred"]();
    return result;
  }
}

class SQLiteBunTransaction extends SQLiteTransaction {
  static [entityKind] = "SQLiteBunTransaction";
  transaction(transaction) {
    const savepointName = `sp${this.nestedIndex}`;
    const tx = new SQLiteBunTransaction("sync", this.dialect, this.session, this.schema, this.nestedIndex + 1);
    this.session.run(sql.raw(`savepoint ${savepointName}`));
    try {
      const result = transaction(tx);
      this.session.run(sql.raw(`release savepoint ${savepointName}`));
      return result;
    } catch (err) {
      this.session.run(sql.raw(`rollback to savepoint ${savepointName}`));
      throw err;
    }
  }
}

class PreparedQuery extends SQLitePreparedQuery {
  constructor(stmt, query, logger, fields, executeMethod, _isResponseInArrayMode, customResultMapper) {
    super("sync", executeMethod, query);
    this.stmt = stmt;
    this.logger = logger;
    this.fields = fields;
    this._isResponseInArrayMode = _isResponseInArrayMode;
    this.customResultMapper = customResultMapper;
  }
  static [entityKind] = "SQLiteBunPreparedQuery";
  run(placeholderValues) {
    const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
    this.logger.logQuery(this.query.sql, params);
    return this.stmt.run(...params);
  }
  all(placeholderValues) {
    const { fields, query, logger, joinsNotNullableMap, stmt, customResultMapper } = this;
    if (!fields && !customResultMapper) {
      const params = fillPlaceholders(query.params, placeholderValues ?? {});
      logger.logQuery(query.sql, params);
      return stmt.all(...params);
    }
    const rows = this.values(placeholderValues);
    if (customResultMapper) {
      return customResultMapper(rows);
    }
    return rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
  }
  get(placeholderValues) {
    const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
    this.logger.logQuery(this.query.sql, params);
    const row = this.stmt.values(...params)[0];
    if (!row) {
      return;
    }
    const { fields, joinsNotNullableMap, customResultMapper } = this;
    if (!fields && !customResultMapper) {
      return row;
    }
    if (customResultMapper) {
      return customResultMapper([row]);
    }
    return mapResultRow(fields, row, joinsNotNullableMap);
  }
  values(placeholderValues) {
    const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
    this.logger.logQuery(this.query.sql, params);
    return this.stmt.values(...params);
  }
  isResponseInArrayMode() {
    return this._isResponseInArrayMode;
  }
}

// node_modules/drizzle-orm/bun-sqlite/driver.js
class BunSQLiteDatabase extends BaseSQLiteDatabase {
  static [entityKind] = "BunSQLiteDatabase";
}
function construct(client, config = {}) {
  const dialect = new SQLiteSyncDialect({ casing: config.casing });
  let logger;
  if (config.logger === true) {
    logger = new DefaultLogger;
  } else if (config.logger !== false) {
    logger = config.logger;
  }
  let schema;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(config.schema, createTableRelationsHelpers);
    schema = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session = new SQLiteBunSession(client, dialect, schema, { logger });
  const db = new BunSQLiteDatabase("sync", dialect, session, schema);
  db.$client = client;
  return db;
}
function drizzle(...params) {
  if (params[0] === undefined || typeof params[0] === "string") {
    const instance = params[0] === undefined ? new Database : new Database(params[0]);
    return construct(instance, params[1]);
  }
  if (isConfig(params[0])) {
    const { connection, client, ...drizzleConfig } = params[0];
    if (client)
      return construct(client, drizzleConfig);
    if (typeof connection === "object") {
      const { source, ...opts } = connection;
      const options = Object.values(opts).filter((v) => v !== undefined).length ? opts : undefined;
      const instance2 = new Database(source, options);
      return construct(instance2, drizzleConfig);
    }
    const instance = new Database(connection);
    return construct(instance, drizzleConfig);
  }
  return construct(params[0], params[1]);
}
((drizzle2) => {
  function mock(config) {
    return construct({}, config);
  }
  drizzle2.mock = mock;
})(drizzle || (drizzle = {}));

// src/serve.ts
import { Database as Database2 } from "bun:sqlite";

// node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator(value) {
  return IsObject(value) && Symbol.asyncIterator in value;
}
function IsIterator(value) {
  return IsObject(value) && Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject(value) && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null);
}
function IsPromise(value) {
  return value instanceof Promise;
}
function IsDate(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function IsTypedArray(value) {
  return ArrayBuffer.isView(value);
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey(value, key) {
  return key in value;
}
function IsObject(value) {
  return value !== null && typeof value === "object";
}
function IsArray(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined(value) {
  return value === undefined;
}
function IsNull(value) {
  return value === null;
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return Number.isInteger(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsString(value) {
  return typeof value === "string";
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
}
// node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber(value) : Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));
// node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => Set2,
  Has: () => Has,
  Get: () => Get,
  Entries: () => Entries,
  Delete: () => Delete,
  Clear: () => Clear
});
var map = new Map;
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format3) {
  return map.delete(format3);
}
function Has(format3) {
  return map.has(format3);
}
function Set2(format3, func) {
  map.set(format3, func);
}
function Get(format3) {
  return map.get(format3);
}
// node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type = {};
__export(exports_type, {
  Set: () => Set3,
  Has: () => Has2,
  Get: () => Get2,
  Entries: () => Entries2,
  Delete: () => Delete2,
  Clear: () => Clear2
});
var map2 = new Map;
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
// node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");
// node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return {
    ...options,
    [Kind]: options[Kind] ?? "Unsafe"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/esm/system/system.mjs
class TypeSystemDuplicateTypeKind extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem;
(function(TypeSystem2) {
  function Type(kind, check) {
    if (exports_type.Has(kind))
      throw new TypeSystemDuplicateTypeKind(kind);
    exports_type.Set(kind, check);
    return (options = {}) => Unsafe({ ...options, [Kind]: kind });
  }
  TypeSystem2.Type = Type;
  function Format(format3, check) {
    if (exports_format.Has(format3))
      throw new TypeSystemDuplicateFormat(format3);
    exports_format.Set(format3, check);
    return format3;
  }
  TypeSystem2.Format = Format;
})(TypeSystem || (TypeSystem = {}));
// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return {
    [Kind]: "MappedResult",
    properties
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => IsUndefined2,
  IsUint8Array: () => IsUint8Array2,
  IsSymbol: () => IsSymbol2,
  IsString: () => IsString2,
  IsRegExp: () => IsRegExp,
  IsObject: () => IsObject2,
  IsNumber: () => IsNumber2,
  IsNull: () => IsNull2,
  IsIterator: () => IsIterator2,
  IsFunction: () => IsFunction2,
  IsDate: () => IsDate2,
  IsBoolean: () => IsBoolean2,
  IsBigInt: () => IsBigInt2,
  IsAsyncIterator: () => IsAsyncIterator2,
  IsArray: () => IsArray2
});
function IsAsyncIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.asyncIterator in value;
}
function IsArray2(value) {
  return Array.isArray(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsDate2(value) {
  return value instanceof globalThis.Date;
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.iterator in value;
}
function IsNull2(value) {
  return value === null;
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsObject2(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString2(value) {
  return typeof value === "string";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined2(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray2(value) ? ArrayType(value) : IsDate2(value) ? DateType(value) : IsUint8Array2(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject2(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneRest(schemas) {
  return schemas.map((schema) => CloneType(schema));
}
function CloneType(schema, options = {}) {
  return { ...Clone(schema), ...options };
}

// node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value, key) {
  const { [key]: _, ...rest } = value;
  return rest;
}
function Discard(value, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}
// node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(schema, options = {}) {
  return {
    ...options,
    [Kind]: "Array",
    type: "array",
    items: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Constructor",
    type: "Constructor",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Function",
    type: "Function",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options = {}) {
  return {
    ...options,
    [Kind]: "Never",
    not: {}
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
  return IsObject2(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject2(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArray3(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
  return IsKindOf(value, "Boolean");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
  return IsKindOf(value, "Date");
}
function IsFunction3(value) {
  return IsKindOf(value, "Function");
}
function IsInteger2(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject2(value) && Kind in value && value[Kind] === kind;
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull3(value) {
  return IsKindOf(value, "Null");
}
function IsNumber3(value) {
  return IsKindOf(value, "Number");
}
function IsObject3(value) {
  return IsKindOf(value, "Object");
}
function IsPromise2(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString3(value) {
  return IsKindOf(value, "String");
}
function IsSymbol3(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject2(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject2(value) && Kind in value && IsString2(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArray3(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsConstructor(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect(value) || IsIterator3(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull3(value) || IsNumber3(value) || IsObject3(value) || IsPromise2(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined3(value) || IsUnion(value) || IsUint8Array3(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return Discard(CloneType(schema), [OptionalKind]);
}
function AddOptional(schema) {
  return { ...CloneType(schema), [OptionalKind]: "Optional" };
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult(R, F) {
  return FromProperties(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: CloneRest(T) } : { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(T) {
  return T.every((L) => IsOptional(L));
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function RemoveOptionalFromRest(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType(L) : L);
}
function ResolveIntersect(T, options) {
  return IsIntersectOptional(T) ? Optional(IntersectCreate(RemoveOptionalFromRest(T), options)) : IntersectCreate(RemoveOptionalFromRest(T), options);
}
function IntersectEvaluated(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return { ...options, [Kind]: "Union", anyOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(T) {
  return T.some((L) => IsOptional(L));
}
function RemoveOptionalFromRest2(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType2(L) : L);
}
function RemoveOptionalFromType2(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(T, options) {
  return IsUnionOptional(T) ? Optional(UnionCreate(RemoveOptionalFromRest2(T), options)) : UnionCreate(RemoveOptionalFromRest2(T), options);
}
function UnionEvaluated(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : ResolveUnion(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : UnionCreate(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
class TemplateLiteralParserError extends TypeBoxError {
}
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count += 1;
      if (IsCloseParen(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
class TemplateLiteralFiniteError extends TypeBoxError {
}
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
class TemplateLiteralGenerateError extends TypeBoxError {
}
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left2 of buffer[0]) {
    for (const right2 of GenerateReduce(buffer.slice(1))) {
      yield `${left2}${right2}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}
// node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value, options = {}) {
  return {
    ...options,
    [Kind]: "Literal",
    const: value,
    type: typeof value
  };
}
// node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options = {}) {
  return {
    ...options,
    [Kind]: "Boolean",
    type: "boolean"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options = {}) {
  return {
    ...options,
    [Kind]: "BigInt",
    type: "bigint"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options = {}) {
  return {
    ...options,
    [Kind]: "Number",
    type: "number"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options = {}) {
  return { ...options, [Kind]: "String", type: "string" };
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal2) => Literal(literal2.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}
// node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternBooleanExact = `^${PatternBoolean}$`;
var PatternNumberExact = `^${PatternNumber}$`;
var PatternStringExact = `^${PatternString}$`;
// node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
class TemplateLiteralPatternError extends TypeBoxError {
}
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options = {}) {
  const pattern = IsString2(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return { ...options, [Kind]: "TemplateLiteral", type: "string", pattern };
}
// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(T) {
  const R = TemplateLiteralGenerate(T);
  return R.map((S) => S.toString());
}
function FromUnion2(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexPropertyKeys(L));
  return Acc;
}
function FromLiteral(T) {
  return [T.toString()];
}
function IndexPropertyKeys(T) {
  return [...new Set(IsTemplateLiteral(T) ? FromTemplateLiteral(T) : IsUnion(T) ? FromUnion2(T.anyOf) : IsLiteral(T) ? FromLiteral(T.const) : IsNumber3(T) ? ["[number]"] : IsInteger2(T) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties2(T, P, options) {
  const Acc = {};
  for (const K2 of Object.getOwnPropertyNames(P)) {
    Acc[K2] = Index(T, IndexPropertyKeys(P[K2]), options);
  }
  return Acc;
}
function FromMappedResult2(T, R, options) {
  return FromProperties2(T, R.properties, options);
}
function IndexFromMappedResult(T, R, options) {
  const P = FromMappedResult2(T, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(T, K) {
  return T.map((L) => IndexFromPropertyKey(L, K));
}
function FromIntersectRest(T) {
  return T.filter((L) => !IsNever(L));
}
function FromIntersect(T, K) {
  return IntersectEvaluated(FromIntersectRest(FromRest(T, K)));
}
function FromUnionRest(T) {
  return T.some((L) => IsNever(L)) ? [] : T;
}
function FromUnion3(T, K) {
  return UnionEvaluated(FromUnionRest(FromRest(T, K)));
}
function FromTuple(T, K) {
  return K in T ? T[K] : K === "[number]" ? UnionEvaluated(T) : Never();
}
function FromArray(T, K) {
  return K === "[number]" ? T : Never();
}
function FromProperty(T, K) {
  return K in T ? T[K] : Never();
}
function IndexFromPropertyKey(T, K) {
  return IsIntersect(T) ? FromIntersect(T.allOf, K) : IsUnion(T) ? FromUnion3(T.anyOf, K) : IsTuple(T) ? FromTuple(T.items ?? [], K) : IsArray3(T) ? FromArray(T.items, K) : IsObject3(T) ? FromProperty(T.properties, K) : Never();
}
function IndexFromPropertyKeys(T, K) {
  return K.map((L) => IndexFromPropertyKey(T, L));
}
function FromSchema(T, K) {
  return UnionEvaluated(IndexFromPropertyKeys(T, K));
}
function Index(T, K, options = {}) {
  return IsMappedResult(K) ? CloneType(IndexFromMappedResult(T, K, options)) : IsMappedKey(K) ? CloneType(IndexFromMappedKey(T, K, options)) : IsSchema(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) : CloneType(FromSchema(T, K), options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(T, K, options) {
  return { [K]: Index(T, [K], options) };
}
function MappedIndexPropertyKeys(T, K, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
  }, {});
}
function MappedIndexProperties(T, K, options) {
  return MappedIndexPropertyKeys(T, K.keys, options);
}
function IndexFromMappedKey(T, K, options) {
  const P = MappedIndexProperties(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "Iterator",
    type: "Iterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function _Object(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};
  const clonedProperties = {};
  for (const key of propertyKeys)
    clonedProperties[key] = CloneType(properties[key]);
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties };
}
var Object2 = _Object;
// node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options = {}) {
  return {
    ...options,
    [Kind]: "Promise",
    type: "Promise",
    item: CloneType(item)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return Discard(CloneType(schema), [ReadonlyKind]);
}
function AddReadonly(schema) {
  return { ...CloneType(schema), [ReadonlyKind]: "Readonly" };
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties3(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult3(R, F) {
  return FromProperties3(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult3(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind]: "Tuple", type: "array", items: CloneRest(items), additionalItems, minItems, maxItems } : { ...options, [Kind]: "Tuple", type: "array", minItems, maxItems };
}
// node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}
// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult4(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult4(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties4(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult4(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items)) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items)) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf)) : IsUnion(T) ? Union(FromRest2(K, T.anyOf)) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? [])) : IsObject3(T) ? Object2(FromProperties4(K, T.properties)) : IsArray3(T) ? Array2(FromSchemaType(K, T.items)) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item)) : T;
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map3, options = {}) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return CloneType(Object2(R), options);
}
// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest3(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(KeyOfPropertyKeys(L));
  return Acc;
}
function FromIntersect2(T) {
  const C = FromRest3(T);
  const R = SetUnionMany(C);
  return R;
}
function FromUnion4(T) {
  const C = FromRest3(T);
  const R = SetIntersectMany(C);
  return R;
}
function FromTuple2(T) {
  return T.map((_, I) => I.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(T) {
  return IsIntersect(T) ? FromIntersect2(T.allOf) : IsUnion(T) ? FromUnion4(T.anyOf) : IsTuple(T) ? FromTuple2(T.items ?? []) : IsArray3(T) ? FromArray2(T.items) : IsObject3(T) ? FromProperties5(T.properties) : IsRecord(T) ? FromPatternProperties(T.patternProperties) : [];
}
var includePatternProperties = false;
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern2 = keys.map((key) => `(${key})`);
  return `^(${pattern2.join("|")})$`;
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest(T) {
  return T.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(T, options = {}) {
  if (IsMappedResult(T)) {
    return KeyOfFromMappedResult(T, options);
  } else {
    const K = KeyOfPropertyKeys(T);
    const S = KeyOfPropertyKeysToRest(K);
    const U = UnionEvaluated(S);
    return CloneType(U, options);
  }
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = KeyOf(K[K2], options);
  return Acc;
}
function FromMappedResult5(R, options) {
  return FromProperties6(R.properties, options);
}
function KeyOfFromMappedResult(R, options) {
  const P = FromMappedResult5(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
  const keys = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys);
  return keys.map((_, index) => [keys[index], schemas[index]]);
}
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error2) {
  switch (error2.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error2.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error2.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error2.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error2.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error2.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error2.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error2.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error2.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error2.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error2.schema.const === "string" ? `'${error2.schema.const}'` : error2.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error2.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error2.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error2.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error2.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error2.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error2.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error2.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error2.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error2.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error2.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error2.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
var errorFunction = DefaultErrorFunction;
function GetErrorFunction() {
  return errorFunction;
}

// node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
class TypeDereferenceError extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with $id '${schema.$id}'`);
    this.schema = schema;
  }
}
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === undefined)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}
// node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
class ValueHashError extends TypeBoxError {
  constructor(value) {
    super(`Unable to hash value`);
    this.value = value;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value) {
  const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value >> 8 * (byteCount - 1 - i) & 255;
  }
}
function ArrayType2(value) {
  FNV1A64(ByteMarker.Array);
  for (const item of value) {
    Visit3(item);
  }
}
function BooleanType(value) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType2(value) {
  FNV1A64(ByteMarker.Date);
  Visit3(value.getTime());
}
function NullType(value) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType2(value) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
    Visit3(key);
    Visit3(value[key]);
  }
}
function StringType(value) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value.length; i++) {
    for (const byte of NumberToBytes(value.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value) {
  FNV1A64(ByteMarker.Symbol);
  Visit3(value.description);
}
function Uint8ArrayType2(value) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value.length; i++) {
    FNV1A64(value[i]);
  }
}
function UndefinedType(value) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit3(value) {
  if (IsArray(value))
    return ArrayType2(value);
  if (IsBoolean(value))
    return BooleanType(value);
  if (IsBigInt(value))
    return BigIntType(value);
  if (IsDate(value))
    return DateType2(value);
  if (IsNull(value))
    return NullType(value);
  if (IsNumber(value))
    return NumberType(value);
  if (IsStandardObject(value))
    return ObjectType2(value);
  if (IsString(value))
    return StringType(value);
  if (IsSymbol(value))
    return SymbolType(value);
  if (IsUint8Array(value))
    return Uint8ArrayType2(value);
  if (IsUndefined(value))
    return UndefinedType(value);
  throw new ValueHashError(value);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value) {
  Accumulator = BigInt("14695981039346656037");
  Visit3(value);
  return Accumulator;
}
// node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined(value) {
  return value !== undefined;
}

class ValueErrorIterator {
  constructor(iterator2) {
    this.iterator = iterator2;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
function Create(errorType, schema, path, value) {
  return { type: errorType, schema, path, value, message: GetErrorFunction()({ errorType, path, schema, value }) };
}
function* FromAny(schema, references, path, value) {
}
function* FromArray3(schema, references, path, value) {
  if (!IsArray(value)) {
    return yield Create(ValueErrorType.Array, schema, path, value);
  }
  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
  }
  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
  }
  for (let i = 0;i < value.length; i++) {
    yield* Visit4(schema.items, references, `${path}/${i}`, value[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set3 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set3.has(hashed)) {
        return false;
      } else {
        set3.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
  }
  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2, index) => Visit4(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value);
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
  }
}
function* FromAsyncIterator(schema, references, path, value) {
  if (!IsAsyncIterator(value))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value);
}
function* FromBigInt(schema, references, path, value) {
  if (!IsBigInt(value))
    return yield Create(ValueErrorType.BigInt, schema, path, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
  }
}
function* FromBoolean(schema, references, path, value) {
  if (!IsBoolean(value))
    yield Create(ValueErrorType.Boolean, schema, path, value);
}
function* FromConstructor(schema, references, path, value) {
  yield* Visit4(schema.returns, references, path, value.prototype);
}
function* FromDate(schema, references, path, value) {
  if (!IsDate(value))
    return yield Create(ValueErrorType.Date, schema, path, value);
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
  }
}
function* FromFunction(schema, references, path, value) {
  if (!IsFunction(value))
    yield Create(ValueErrorType.Function, schema, path, value);
}
function* FromInteger(schema, references, path, value) {
  if (!IsInteger(value))
    return yield Create(ValueErrorType.Integer, schema, path, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
  }
}
function* FromIntersect3(schema, references, path, value) {
  for (const inner of schema.allOf) {
    const next = Visit4(inner, references, path, value).next();
    if (!next.done) {
      yield Create(ValueErrorType.Intersect, schema, path, value);
      yield next.value;
    }
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit4(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator(schema, references, path, value) {
  if (!IsIterator(value))
    yield Create(ValueErrorType.Iterator, schema, path, value);
}
function* FromLiteral2(schema, references, path, value) {
  if (!(value === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value);
}
function* FromNever(schema, references, path, value) {
  yield Create(ValueErrorType.Never, schema, path, value);
}
function* FromNot(schema, references, path, value) {
  if (Visit4(schema.not, references, path, value).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value);
}
function* FromNull(schema, references, path, value) {
  if (!IsNull(value))
    yield Create(ValueErrorType.Null, schema, path, value);
}
function* FromNumber(schema, references, path, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return yield Create(ValueErrorType.Number, schema, path, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
  }
}
function* FromObject(schema, references, path, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
        yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      }
    }
  }
}
function* FromPromise(schema, references, path, value) {
  if (!IsPromise(value))
    yield Create(ValueErrorType.Promise, schema, path, value);
}
function* FromRecord(schema, references, path, value) {
  if (!TypeSystemPolicy.IsRecordLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value)) {
    if (regex.test(propertyKey))
      yield* Visit4(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (!regex.test(propertyKey))
        yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef(schema, references, path, value) {
  yield* Visit4(Deref(schema, references), references, path, value);
}
function* FromRegExp(schema, references, path, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value);
  }
}
function* FromString(schema, references, path, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  if (IsString(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  if (IsString(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
    } else {
      const format3 = exports_format.Get(schema.format);
      if (!format3(value)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value);
      }
    }
  }
}
function* FromSymbol(schema, references, path, value) {
  if (!IsSymbol(value))
    yield Create(ValueErrorType.Symbol, schema, path, value);
}
function* FromTemplateLiteral2(schema, references, path, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value);
  }
}
function* FromThis(schema, references, path, value) {
  yield* Visit4(Deref(schema, references), references, path, value);
}
function* FromTuple3(schema, references, path, value) {
  if (!IsArray(value))
    return yield Create(ValueErrorType.Tuple, schema, path, value);
  if (schema.items === undefined && !(value.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!(value.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit4(schema.items[i], references, `${path}/${i}`, value[i]);
  }
}
function* FromUndefined(schema, references, path, value) {
  if (!IsUndefined(value))
    yield Create(ValueErrorType.Undefined, schema, path, value);
}
function* FromUnion5(schema, references, path, value) {
  let count = 0;
  for (const subschema of schema.anyOf) {
    const errors = [...Visit4(subschema, references, path, value)];
    if (errors.length === 0)
      return;
    count += errors.length;
  }
  if (count > 0) {
    yield Create(ValueErrorType.Union, schema, path, value);
  }
}
function* FromUint8Array(schema, references, path, value) {
  if (!IsUint8Array(value))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value);
  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
  }
  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
  }
}
function* FromUnknown(schema, references, path, value) {
}
function* FromVoid(schema, references, path, value) {
  if (!TypeSystemPolicy.IsVoidLike(value))
    yield Create(ValueErrorType.Void, schema, path, value);
}
function* FromKind(schema, references, path, value) {
  const check = exports_type.Get(schema[Kind]);
  if (!check(schema, value))
    yield Create(ValueErrorType.Kind, schema, path, value);
}
function* Visit4(schema, references, path, value) {
  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny(schema_, references_, path, value);
    case "Array":
      return yield* FromArray3(schema_, references_, path, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator(schema_, references_, path, value);
    case "BigInt":
      return yield* FromBigInt(schema_, references_, path, value);
    case "Boolean":
      return yield* FromBoolean(schema_, references_, path, value);
    case "Constructor":
      return yield* FromConstructor(schema_, references_, path, value);
    case "Date":
      return yield* FromDate(schema_, references_, path, value);
    case "Function":
      return yield* FromFunction(schema_, references_, path, value);
    case "Integer":
      return yield* FromInteger(schema_, references_, path, value);
    case "Intersect":
      return yield* FromIntersect3(schema_, references_, path, value);
    case "Iterator":
      return yield* FromIterator(schema_, references_, path, value);
    case "Literal":
      return yield* FromLiteral2(schema_, references_, path, value);
    case "Never":
      return yield* FromNever(schema_, references_, path, value);
    case "Not":
      return yield* FromNot(schema_, references_, path, value);
    case "Null":
      return yield* FromNull(schema_, references_, path, value);
    case "Number":
      return yield* FromNumber(schema_, references_, path, value);
    case "Object":
      return yield* FromObject(schema_, references_, path, value);
    case "Promise":
      return yield* FromPromise(schema_, references_, path, value);
    case "Record":
      return yield* FromRecord(schema_, references_, path, value);
    case "Ref":
      return yield* FromRef(schema_, references_, path, value);
    case "RegExp":
      return yield* FromRegExp(schema_, references_, path, value);
    case "String":
      return yield* FromString(schema_, references_, path, value);
    case "Symbol":
      return yield* FromSymbol(schema_, references_, path, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral2(schema_, references_, path, value);
    case "This":
      return yield* FromThis(schema_, references_, path, value);
    case "Tuple":
      return yield* FromTuple3(schema_, references_, path, value);
    case "Undefined":
      return yield* FromUndefined(schema_, references_, path, value);
    case "Union":
      return yield* FromUnion5(schema_, references_, path, value);
    case "Uint8Array":
      return yield* FromUint8Array(schema_, references_, path, value);
    case "Unknown":
      return yield* FromUnknown(schema_, references_, path, value);
    case "Void":
      return yield* FromVoid(schema_, references_, path, value);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind(schema_, references_, path, value);
  }
}
function Errors(...args) {
  const iterator2 = args.length === 3 ? Visit4(args[0], args[1], "", args[2]) : Visit4(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator2);
}
// node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options = {}) {
  return { ...options, [Kind]: "Any" };
}
// node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options = {}) {
  return {
    ...options,
    [Kind]: "Unknown"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError,
  IsVoid: () => IsVoid2,
  IsUnsafe: () => IsUnsafe2,
  IsUnknown: () => IsUnknown2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnion: () => IsUnion2,
  IsUndefined: () => IsUndefined4,
  IsUint8Array: () => IsUint8Array4,
  IsTuple: () => IsTuple2,
  IsTransform: () => IsTransform2,
  IsThis: () => IsThis2,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsSymbol: () => IsSymbol4,
  IsString: () => IsString4,
  IsSchema: () => IsSchema2,
  IsRegExp: () => IsRegExp3,
  IsRef: () => IsRef2,
  IsRecursive: () => IsRecursive,
  IsRecord: () => IsRecord2,
  IsReadonly: () => IsReadonly2,
  IsProperties: () => IsProperties,
  IsPromise: () => IsPromise3,
  IsOptional: () => IsOptional2,
  IsObject: () => IsObject4,
  IsNumber: () => IsNumber4,
  IsNull: () => IsNull4,
  IsNot: () => IsNot2,
  IsNever: () => IsNever2,
  IsMappedResult: () => IsMappedResult2,
  IsMappedKey: () => IsMappedKey2,
  IsLiteralValue: () => IsLiteralValue,
  IsLiteralString: () => IsLiteralString,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteral: () => IsLiteral2,
  IsKindOf: () => IsKindOf2,
  IsKind: () => IsKind2,
  IsIterator: () => IsIterator4,
  IsIntersect: () => IsIntersect2,
  IsInteger: () => IsInteger3,
  IsFunction: () => IsFunction4,
  IsDate: () => IsDate4,
  IsConstructor: () => IsConstructor2,
  IsBoolean: () => IsBoolean4,
  IsBigInt: () => IsBigInt4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsArray: () => IsArray4,
  IsAny: () => IsAny2
});
class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString2(value))
    return false;
  for (let i = 0;i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined2(value) || IsBigInt2(value);
}
function IsOptionalNumber(value) {
  return IsUndefined2(value) || IsNumber2(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined2(value) || IsBoolean2(value);
}
function IsOptionalString(value) {
  return IsUndefined2(value) || IsString2(value);
}
function IsOptionalPattern(value) {
  return IsUndefined2(value) || IsString2(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined2(value) || IsString2(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined2(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject2(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject2(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArray4(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator4(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt4(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean4(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray2(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate4(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction4(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray2(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsInteger3(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject2(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString2(value.type) && value.type !== "object" ? false : true) && IsArray2(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator4(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject2(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString2(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber2(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean2(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue(value.const);
}
function IsLiteralValue(value) {
  return IsBoolean2(value) || IsNumber2(value) || IsString2(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray2(value.keys) && value.keys.every((key) => IsNumber2(key) || IsString2(key));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject2(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject4(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise3(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject2(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject2(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject2(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString2(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString2(value.source) && IsString2(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString4(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol4(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString2(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString2(value.$ref);
}
function IsTransform2(value) {
  return IsObject2(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber2(value.minItems) && IsNumber2(value.maxItems) && value.minItems === value.maxItems && (IsUndefined2(value.items) && IsUndefined2(value.additionalItems) && value.minItems === 0 || IsArray2(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject2(value) && IsArray2(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject2(value) && Kind in value && IsString2(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject2(value) && (IsAny2(value) || IsArray4(value) || IsBoolean4(value) || IsBigInt4(value) || IsAsyncIterator4(value) || IsConstructor2(value) || IsDate4(value) || IsFunction4(value) || IsInteger3(value) || IsIntersect2(value) || IsIterator4(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull4(value) || IsNumber4(value) || IsObject4(value) || IsPromise3(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString4(value) || IsSymbol4(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined4(value) || IsUnion2(value) || IsUint8Array4(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right2) {
  return exports_type2.IsNever(right2) || exports_type2.IsIntersect(right2) || exports_type2.IsUnion(right2) || exports_type2.IsUnknown(right2) || exports_type2.IsAny(right2);
}
function StructuralRight(left2, right2) {
  return exports_type2.IsNever(right2) ? FromNeverRight(left2, right2) : exports_type2.IsIntersect(right2) ? FromIntersectRight(left2, right2) : exports_type2.IsUnion(right2) ? FromUnionRight(left2, right2) : exports_type2.IsUnknown(right2) ? FromUnknownRight(left2, right2) : exports_type2.IsAny(right2) ? FromAnyRight(left2, right2) : Throw("StructuralRight");
}
function FromAnyRight(left2, right2) {
  return ExtendsResult.True;
}
function FromAny2(left2, right2) {
  return exports_type2.IsIntersect(right2) ? FromIntersectRight(left2, right2) : exports_type2.IsUnion(right2) && right2.anyOf.some((schema) => exports_type2.IsAny(schema) || exports_type2.IsUnknown(schema)) ? ExtendsResult.True : exports_type2.IsUnion(right2) ? ExtendsResult.Union : exports_type2.IsUnknown(right2) ? ExtendsResult.True : exports_type2.IsAny(right2) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left2, right2) {
  return exports_type2.IsUnknown(left2) ? ExtendsResult.False : exports_type2.IsAny(left2) ? ExtendsResult.Union : exports_type2.IsNever(left2) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left2, right2) {
  return exports_type2.IsObject(right2) && IsObjectArrayLike(right2) ? ExtendsResult.True : IsStructuralRight(right2) ? StructuralRight(left2, right2) : !exports_type2.IsArray(right2) ? ExtendsResult.False : IntoBooleanResult(Visit5(left2.items, right2.items));
}
function FromAsyncIterator2(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : !exports_type2.IsAsyncIterator(right2) ? ExtendsResult.False : IntoBooleanResult(Visit5(left2.items, right2.items));
}
function FromBigInt2(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsObject(right2) ? FromObjectRight(left2, right2) : exports_type2.IsRecord(right2) ? FromRecordRight(left2, right2) : exports_type2.IsBigInt(right2) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left2, right2) {
  return exports_type2.IsLiteralBoolean(left2) ? ExtendsResult.True : exports_type2.IsBoolean(left2) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean2(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsObject(right2) ? FromObjectRight(left2, right2) : exports_type2.IsRecord(right2) ? FromRecordRight(left2, right2) : exports_type2.IsBoolean(right2) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor2(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsObject(right2) ? FromObjectRight(left2, right2) : !exports_type2.IsConstructor(right2) ? ExtendsResult.False : left2.parameters.length > right2.parameters.length ? ExtendsResult.False : !left2.parameters.every((schema, index) => IntoBooleanResult(Visit5(right2.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left2.returns, right2.returns));
}
function FromDate2(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsObject(right2) ? FromObjectRight(left2, right2) : exports_type2.IsRecord(right2) ? FromRecordRight(left2, right2) : exports_type2.IsDate(right2) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction2(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsObject(right2) ? FromObjectRight(left2, right2) : !exports_type2.IsFunction(right2) ? ExtendsResult.False : left2.parameters.length > right2.parameters.length ? ExtendsResult.False : !left2.parameters.every((schema, index) => IntoBooleanResult(Visit5(right2.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left2.returns, right2.returns));
}
function FromIntegerRight(left2, right2) {
  return exports_type2.IsLiteral(left2) && exports_value.IsNumber(left2.const) ? ExtendsResult.True : exports_type2.IsNumber(left2) || exports_type2.IsInteger(left2) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger2(left2, right2) {
  return exports_type2.IsInteger(right2) || exports_type2.IsNumber(right2) ? ExtendsResult.True : IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsObject(right2) ? FromObjectRight(left2, right2) : exports_type2.IsRecord(right2) ? FromRecordRight(left2, right2) : ExtendsResult.False;
}
function FromIntersectRight(left2, right2) {
  return right2.allOf.every((schema) => Visit5(left2, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left2, right2) {
  return left2.allOf.some((schema) => Visit5(schema, right2) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator2(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : !exports_type2.IsIterator(right2) ? ExtendsResult.False : IntoBooleanResult(Visit5(left2.items, right2.items));
}
function FromLiteral3(left2, right2) {
  return exports_type2.IsLiteral(right2) && right2.const === left2.const ? ExtendsResult.True : IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsObject(right2) ? FromObjectRight(left2, right2) : exports_type2.IsRecord(right2) ? FromRecordRight(left2, right2) : exports_type2.IsString(right2) ? FromStringRight(left2, right2) : exports_type2.IsNumber(right2) ? FromNumberRight(left2, right2) : exports_type2.IsInteger(right2) ? FromIntegerRight(left2, right2) : exports_type2.IsBoolean(right2) ? FromBooleanRight(left2, right2) : ExtendsResult.False;
}
function FromNeverRight(left2, right2) {
  return ExtendsResult.False;
}
function FromNever2(left2, right2) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type2.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot2(left2, right2) {
  return exports_type2.IsNot(left2) ? Visit5(UnwrapTNot(left2), right2) : exports_type2.IsNot(right2) ? Visit5(left2, UnwrapTNot(right2)) : Throw("Invalid fallthrough for Not");
}
function FromNull2(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsObject(right2) ? FromObjectRight(left2, right2) : exports_type2.IsRecord(right2) ? FromRecordRight(left2, right2) : exports_type2.IsNull(right2) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left2, right2) {
  return exports_type2.IsLiteralNumber(left2) ? ExtendsResult.True : exports_type2.IsNumber(left2) || exports_type2.IsInteger(left2) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber2(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsObject(right2) ? FromObjectRight(left2, right2) : exports_type2.IsRecord(right2) ? FromRecordRight(left2, right2) : exports_type2.IsInteger(right2) || exports_type2.IsNumber(right2) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type2.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type2.IsString(schema.properties.description.anyOf[0]) && exports_type2.IsUndefined(schema.properties.description.anyOf[1]) || exports_type2.IsString(schema.properties.description.anyOf[1]) && exports_type2.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit5(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left2, right2) {
  return Visit5(left2, right2) === ExtendsResult.False ? ExtendsResult.False : exports_type2.IsOptional(left2) && !exports_type2.IsOptional(right2) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left2, right2) {
  return exports_type2.IsUnknown(left2) ? ExtendsResult.False : exports_type2.IsAny(left2) ? ExtendsResult.Union : exports_type2.IsNever(left2) || exports_type2.IsLiteralString(left2) && IsObjectStringLike(right2) || exports_type2.IsLiteralNumber(left2) && IsObjectNumberLike(right2) || exports_type2.IsLiteralBoolean(left2) && IsObjectBooleanLike(right2) || exports_type2.IsSymbol(left2) && IsObjectSymbolLike(right2) || exports_type2.IsBigInt(left2) && IsObjectBigIntLike(right2) || exports_type2.IsString(left2) && IsObjectStringLike(right2) || exports_type2.IsSymbol(left2) && IsObjectSymbolLike(right2) || exports_type2.IsNumber(left2) && IsObjectNumberLike(right2) || exports_type2.IsInteger(left2) && IsObjectNumberLike(right2) || exports_type2.IsBoolean(left2) && IsObjectBooleanLike(right2) || exports_type2.IsUint8Array(left2) && IsObjectUint8ArrayLike(right2) || exports_type2.IsDate(left2) && IsObjectDateLike(right2) || exports_type2.IsConstructor(left2) && IsObjectConstructorLike(right2) || exports_type2.IsFunction(left2) && IsObjectFunctionLike(right2) ? ExtendsResult.True : exports_type2.IsRecord(left2) && exports_type2.IsString(RecordKey(left2)) ? (() => {
    return right2[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type2.IsRecord(left2) && exports_type2.IsNumber(RecordKey(left2)) ? (() => {
    return IsObjectPropertyCount(right2, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject2(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsRecord(right2) ? FromRecordRight(left2, right2) : !exports_type2.IsObject(right2) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right2.properties)) {
      if (!(key in left2.properties) && !exports_type2.IsOptional(right2.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type2.IsOptional(right2.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left2.properties[key], right2.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsObject(right2) && IsObjectPromiseLike(right2) ? ExtendsResult.True : !exports_type2.IsPromise(right2) ? ExtendsResult.False : IntoBooleanResult(Visit5(left2.item, right2.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left2, right2) {
  const [Key, Value] = [RecordKey(right2), RecordValue(right2)];
  return exports_type2.IsLiteralString(left2) && exports_type2.IsNumber(Key) && IntoBooleanResult(Visit5(left2, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type2.IsUint8Array(left2) && exports_type2.IsNumber(Key) ? Visit5(left2, Value) : exports_type2.IsString(left2) && exports_type2.IsNumber(Key) ? Visit5(left2, Value) : exports_type2.IsArray(left2) && exports_type2.IsNumber(Key) ? Visit5(left2, Value) : exports_type2.IsObject(left2) ? (() => {
    for (const key of Object.getOwnPropertyNames(left2.properties)) {
      if (Property(Value, left2.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord2(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsObject(right2) ? FromObjectRight(left2, right2) : !exports_type2.IsRecord(right2) ? ExtendsResult.False : Visit5(RecordValue(left2), RecordValue(right2));
}
function FromRegExp2(left2, right2) {
  const L = exports_type2.IsRegExp(left2) ? String2() : left2;
  const R = exports_type2.IsRegExp(right2) ? String2() : right2;
  return Visit5(L, R);
}
function FromStringRight(left2, right2) {
  return exports_type2.IsLiteral(left2) && exports_value.IsString(left2.const) ? ExtendsResult.True : exports_type2.IsString(left2) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString2(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsObject(right2) ? FromObjectRight(left2, right2) : exports_type2.IsRecord(right2) ? FromRecordRight(left2, right2) : exports_type2.IsString(right2) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol2(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsObject(right2) ? FromObjectRight(left2, right2) : exports_type2.IsRecord(right2) ? FromRecordRight(left2, right2) : exports_type2.IsSymbol(right2) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral3(left2, right2) {
  return exports_type2.IsTemplateLiteral(left2) ? Visit5(TemplateLiteralToUnion(left2), right2) : exports_type2.IsTemplateLiteral(right2) ? Visit5(left2, TemplateLiteralToUnion(right2)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left2, right2) {
  return exports_type2.IsArray(right2) && left2.items !== undefined && left2.items.every((schema) => Visit5(schema, right2.items) === ExtendsResult.True);
}
function FromTupleRight(left2, right2) {
  return exports_type2.IsNever(left2) ? ExtendsResult.True : exports_type2.IsUnknown(left2) ? ExtendsResult.False : exports_type2.IsAny(left2) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple4(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsObject(right2) && IsObjectArrayLike(right2) ? ExtendsResult.True : exports_type2.IsArray(right2) && IsArrayOfTuple(left2, right2) ? ExtendsResult.True : !exports_type2.IsTuple(right2) ? ExtendsResult.False : exports_value.IsUndefined(left2.items) && !exports_value.IsUndefined(right2.items) || !exports_value.IsUndefined(left2.items) && exports_value.IsUndefined(right2.items) ? ExtendsResult.False : exports_value.IsUndefined(left2.items) && !exports_value.IsUndefined(right2.items) ? ExtendsResult.True : left2.items.every((schema, index) => Visit5(schema, right2.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array2(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsObject(right2) ? FromObjectRight(left2, right2) : exports_type2.IsRecord(right2) ? FromRecordRight(left2, right2) : exports_type2.IsUint8Array(right2) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined2(left2, right2) {
  return IsStructuralRight(right2) ? StructuralRight(left2, right2) : exports_type2.IsObject(right2) ? FromObjectRight(left2, right2) : exports_type2.IsRecord(right2) ? FromRecordRight(left2, right2) : exports_type2.IsVoid(right2) ? FromVoidRight(left2, right2) : exports_type2.IsUndefined(right2) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left2, right2) {
  return right2.anyOf.some((schema) => Visit5(left2, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left2, right2) {
  return left2.anyOf.every((schema) => Visit5(schema, right2) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left2, right2) {
  return ExtendsResult.True;
}
function FromUnknown2(left2, right2) {
  return exports_type2.IsNever(right2) ? FromNeverRight(left2, right2) : exports_type2.IsIntersect(right2) ? FromIntersectRight(left2, right2) : exports_type2.IsUnion(right2) ? FromUnionRight(left2, right2) : exports_type2.IsAny(right2) ? FromAnyRight(left2, right2) : exports_type2.IsString(right2) ? FromStringRight(left2, right2) : exports_type2.IsNumber(right2) ? FromNumberRight(left2, right2) : exports_type2.IsInteger(right2) ? FromIntegerRight(left2, right2) : exports_type2.IsBoolean(right2) ? FromBooleanRight(left2, right2) : exports_type2.IsArray(right2) ? FromArrayRight(left2, right2) : exports_type2.IsTuple(right2) ? FromTupleRight(left2, right2) : exports_type2.IsObject(right2) ? FromObjectRight(left2, right2) : exports_type2.IsUnknown(right2) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left2, right2) {
  return exports_type2.IsUndefined(left2) ? ExtendsResult.True : exports_type2.IsUndefined(left2) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid2(left2, right2) {
  return exports_type2.IsIntersect(right2) ? FromIntersectRight(left2, right2) : exports_type2.IsUnion(right2) ? FromUnionRight(left2, right2) : exports_type2.IsUnknown(right2) ? FromUnknownRight(left2, right2) : exports_type2.IsAny(right2) ? FromAnyRight(left2, right2) : exports_type2.IsObject(right2) ? FromObjectRight(left2, right2) : exports_type2.IsVoid(right2) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit5(left2, right2) {
  return exports_type2.IsTemplateLiteral(left2) || exports_type2.IsTemplateLiteral(right2) ? FromTemplateLiteral3(left2, right2) : exports_type2.IsRegExp(left2) || exports_type2.IsRegExp(right2) ? FromRegExp2(left2, right2) : exports_type2.IsNot(left2) || exports_type2.IsNot(right2) ? FromNot2(left2, right2) : exports_type2.IsAny(left2) ? FromAny2(left2, right2) : exports_type2.IsArray(left2) ? FromArray4(left2, right2) : exports_type2.IsBigInt(left2) ? FromBigInt2(left2, right2) : exports_type2.IsBoolean(left2) ? FromBoolean2(left2, right2) : exports_type2.IsAsyncIterator(left2) ? FromAsyncIterator2(left2, right2) : exports_type2.IsConstructor(left2) ? FromConstructor2(left2, right2) : exports_type2.IsDate(left2) ? FromDate2(left2, right2) : exports_type2.IsFunction(left2) ? FromFunction2(left2, right2) : exports_type2.IsInteger(left2) ? FromInteger2(left2, right2) : exports_type2.IsIntersect(left2) ? FromIntersect4(left2, right2) : exports_type2.IsIterator(left2) ? FromIterator2(left2, right2) : exports_type2.IsLiteral(left2) ? FromLiteral3(left2, right2) : exports_type2.IsNever(left2) ? FromNever2(left2, right2) : exports_type2.IsNull(left2) ? FromNull2(left2, right2) : exports_type2.IsNumber(left2) ? FromNumber2(left2, right2) : exports_type2.IsObject(left2) ? FromObject2(left2, right2) : exports_type2.IsRecord(left2) ? FromRecord2(left2, right2) : exports_type2.IsString(left2) ? FromString2(left2, right2) : exports_type2.IsSymbol(left2) ? FromSymbol2(left2, right2) : exports_type2.IsTuple(left2) ? FromTuple4(left2, right2) : exports_type2.IsPromise(left2) ? FromPromise2(left2, right2) : exports_type2.IsUint8Array(left2) ? FromUint8Array2(left2, right2) : exports_type2.IsUndefined(left2) ? FromUndefined2(left2, right2) : exports_type2.IsUnion(left2) ? FromUnion6(left2, right2) : exports_type2.IsUnknown(left2) ? FromUnknown2(left2, right2) : exports_type2.IsVoid(left2) ? FromVoid2(left2, right2) : Throw(`Unknown left type operand '${left2[Kind]}'`);
}
function ExtendsCheck(left2, right2) {
  return Visit5(left2, right2);
}
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties7(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, options);
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties7(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left2, right2, trueType, falseType) {
  const R = ExtendsCheck(left2, right2);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options = {}) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) : CloneType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, options)
  };
}
function FromPropertyKeys(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
class ValueCheckUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined2(value) {
  return value !== undefined;
}
function FromAny3(schema, references, value) {
  return true;
}
function FromArray5(schema, references, value) {
  if (!IsArray(value))
    return false;
  if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems)) {
    return false;
  }
  if (!value.every((value2) => Visit6(schema.items, references, value2))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set3 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set3.has(hashed)) {
        return false;
      } else {
        set3.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined2(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2) => Visit6(containsSchema, references, value2) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator3(schema, references, value) {
  return IsAsyncIterator(value);
}
function FromBigInt3(schema, references, value) {
  if (!IsBigInt(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean3(schema, references, value) {
  return IsBoolean(value);
}
function FromConstructor3(schema, references, value) {
  return Visit6(schema.returns, references, value.prototype);
}
function FromDate3(schema, references, value) {
  if (!IsDate(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction3(schema, references, value) {
  return IsFunction(value);
}
function FromInteger3(schema, references, value) {
  if (!IsInteger(value)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect5(schema, references, value) {
  const check1 = schema.allOf.every((schema2) => Visit6(schema2, references, value));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema2(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit6(schema.unevaluatedProperties, references, value[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator3(schema, references, value) {
  return IsIterator(value);
}
function FromLiteral4(schema, references, value) {
  return value === schema.const;
}
function FromNever3(schema, references, value) {
  return false;
}
function FromNot3(schema, references, value) {
  return !Visit6(schema.not, references, value);
}
function FromNull3(schema, references, value) {
  return IsNull(value);
}
function FromNumber3(schema, references, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject3(schema, references, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return false;
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit6(property, references, value[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit6(property, references, value[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit6(schema.additionalProperties, references, value[key]));
  } else {
    return true;
  }
}
function FromPromise3(schema, references, value) {
  return IsPromise(value);
}
function FromRecord3(schema, references, value) {
  if (!TypeSystemPolicy.IsRecordLike(value)) {
    return false;
  }
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value).every(([key, value2]) => {
    return regex.test(key) ? Visit6(patternSchema, references, value2) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
    return !regex.test(key) ? Visit6(schema.additionalProperties, references, value2) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef2(schema, references, value) {
  return Visit6(Deref(schema, references), references, value);
}
function FromRegExp3(schema, references, value) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined2(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  return regex.test(value);
}
function FromString3(schema, references, value) {
  if (!IsString(value)) {
    return false;
  }
  if (IsDefined2(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  if (IsDefined2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value))
      return false;
  }
  if (IsDefined2(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value);
  }
  return true;
}
function FromSymbol3(schema, references, value) {
  return IsSymbol(value);
}
function FromTemplateLiteral4(schema, references, value) {
  return IsString(value) && new RegExp(schema.pattern).test(value);
}
function FromThis2(schema, references, value) {
  return Visit6(Deref(schema, references), references, value);
}
function FromTuple5(schema, references, value) {
  if (!IsArray(value)) {
    return false;
  }
  if (schema.items === undefined && !(value.length === 0)) {
    return false;
  }
  if (!(value.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit6(schema.items[i], references, value[i]))
      return false;
  }
  return true;
}
function FromUndefined3(schema, references, value) {
  return IsUndefined(value);
}
function FromUnion7(schema, references, value) {
  return schema.anyOf.some((inner) => Visit6(inner, references, value));
}
function FromUint8Array3(schema, references, value) {
  if (!IsUint8Array(value)) {
    return false;
  }
  if (IsDefined2(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined2(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown3(schema, references, value) {
  return true;
}
function FromVoid3(schema, references, value) {
  return TypeSystemPolicy.IsVoidLike(value);
}
function FromKind2(schema, references, value) {
  if (!exports_type.Has(schema[Kind]))
    return false;
  const func = exports_type.Get(schema[Kind]);
  return func(schema, value);
}
function Visit6(schema, references, value) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny3(schema_, references_, value);
    case "Array":
      return FromArray5(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator3(schema_, references_, value);
    case "BigInt":
      return FromBigInt3(schema_, references_, value);
    case "Boolean":
      return FromBoolean3(schema_, references_, value);
    case "Constructor":
      return FromConstructor3(schema_, references_, value);
    case "Date":
      return FromDate3(schema_, references_, value);
    case "Function":
      return FromFunction3(schema_, references_, value);
    case "Integer":
      return FromInteger3(schema_, references_, value);
    case "Intersect":
      return FromIntersect5(schema_, references_, value);
    case "Iterator":
      return FromIterator3(schema_, references_, value);
    case "Literal":
      return FromLiteral4(schema_, references_, value);
    case "Never":
      return FromNever3(schema_, references_, value);
    case "Not":
      return FromNot3(schema_, references_, value);
    case "Null":
      return FromNull3(schema_, references_, value);
    case "Number":
      return FromNumber3(schema_, references_, value);
    case "Object":
      return FromObject3(schema_, references_, value);
    case "Promise":
      return FromPromise3(schema_, references_, value);
    case "Record":
      return FromRecord3(schema_, references_, value);
    case "Ref":
      return FromRef2(schema_, references_, value);
    case "RegExp":
      return FromRegExp3(schema_, references_, value);
    case "String":
      return FromString3(schema_, references_, value);
    case "Symbol":
      return FromSymbol3(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value);
    case "This":
      return FromThis2(schema_, references_, value);
    case "Tuple":
      return FromTuple5(schema_, references_, value);
    case "Undefined":
      return FromUndefined3(schema_, references_, value);
    case "Union":
      return FromUnion7(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array3(schema_, references_, value);
    case "Unknown":
      return FromUnknown3(schema_, references_, value);
    case "Void":
      return FromVoid3(schema_, references_, value);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind2(schema_, references_, value);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit6(args[0], args[1], args[2]) : Visit6(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function ObjectType3(value) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    Acc[key] = Clone2(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    Acc[key] = Clone2(value[key]);
  }
  return Acc;
}
function ArrayType3(value) {
  return value.map((element) => Clone2(element));
}
function TypedArrayType(value) {
  return value.slice();
}
function DateType3(value) {
  return new Date(value.toISOString());
}
function ValueType(value) {
  return value;
}
function Clone2(value) {
  if (IsArray(value))
    return ArrayType3(value);
  if (IsDate(value))
    return DateType3(value);
  if (IsStandardObject(value))
    return ObjectType3(value);
  if (IsTypedArray(value))
    return TypedArrayType(value);
  if (IsValueType(value))
    return ValueType(value);
  throw new Error("ValueClone: Unable to clone value");
}
// node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
class ValueCreateError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function FromDefault(value) {
  return typeof value === "function" ? value : Clone2(value);
}
function FromAny4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromArray6(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
}
function FromBigInt4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
}
function FromConstructor4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = Visit7(schema.returns, references);
    if (typeof value === "object" && !Array.isArray(value)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value)) {
            const self = this;
            self[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
}
function FromFunction4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
}
function FromInteger4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect6(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value;
  }
}
function FromIterator4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
}
function FromLiteral5(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
}
function FromNull4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
}
function FromNumber4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required.has(key))
        continue;
      Acc[key] = Visit7(subschema, references);
    }
    return Acc;
  }
}
function FromPromise4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
}
function FromRecord4(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    const Acc = {};
    for (const key of propertyKeys)
      Acc[key] = Visit7(valueSchema, references);
    return Acc;
  } else {
    return {};
  }
}
function FromRef3(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromRegExp4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString4(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral5(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
}
function FromThis3(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromTuple6(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
}
function FromUndefined4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromUnion8(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
}
function FromUint8Array4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromVoid4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromKind3(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit7(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Array":
      return FromArray6(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor4(schema_, references_);
    case "Date":
      return FromDate4(schema_, references_);
    case "Function":
      return FromFunction4(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect6(schema_, references_);
    case "Iterator":
      return FromIterator4(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject4(schema_, references_);
    case "Promise":
      return FromPromise4(schema_, references_);
    case "Record":
      return FromRecord4(schema_, references_);
    case "Ref":
      return FromRef3(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral5(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple6(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion8(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}
// node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
class ValueCastError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function ScoreUnion(schema, references, value) {
  if (schema[Kind] === "Object" && typeof value === "object" && !IsNull(value)) {
    const object2 = schema;
    const keys = Object.getOwnPropertyNames(value);
    const entries = Object.entries(object2.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal2 = schema2[Kind] === "Literal" && schema2.const === value[key] ? max : 0;
      const checks = Check(schema2, references, value[key]) ? point : 0;
      const exists2 = keys.includes(key) ? point : 0;
      return acc + (literal2 + checks + exists2);
    }, 0);
  } else {
    return Check(schema, references, value) ? 1 : 0;
  }
}
function SelectUnion(union4, references, value) {
  const schemas = union4.anyOf.map((schema) => Deref(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion(union4, references, value) {
  if ("default" in union4) {
    return typeof value === "function" ? union4.default : Clone2(union4.default);
  } else {
    const schema = SelectUnion(union4, references, value);
    return Cast(schema, references, value);
  }
}
function DefaultClone(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : Create2(schema, references);
}
function Default(schema, references, value) {
  return Check(schema, references, value) ? value : Create2(schema, references);
}
function FromArray7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  const created = IsArray(value) ? Clone2(value) : Create2(schema, references);
  const minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value2) => Visit8(schema.items, references, value2));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor5(schema, references, value) {
  if (Check(schema, references, value))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value.prototype[key]);
  }
  return result;
}
function FromIntersect7(schema, references, value) {
  const created = Create2(schema, references);
  const mapped2 = IsStandardObject(created) && IsStandardObject(value) ? { ...created, ...value } : value;
  return Check(schema, references, mapped2) ? mapped2 : Create2(schema, references);
}
function FromNever5(schema, references, value) {
  throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject5(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  if (value === null || typeof value !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value[propertyName]);
    }
  }
  return result;
}
function FromRecord5(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
}
function FromRef4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromThis4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromTuple7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (!IsArray(value))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value[index]));
}
function FromUnion9(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : CastUnion(schema, references, value);
}
function Visit8(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray7(schema_, references_, value);
    case "Constructor":
      return FromConstructor5(schema_, references_, value);
    case "Intersect":
      return FromIntersect7(schema_, references_, value);
    case "Never":
      return FromNever5(schema_, references_, value);
    case "Object":
      return FromObject5(schema_, references_, value);
    case "Record":
      return FromRecord5(schema_, references_, value);
    case "Ref":
      return FromRef4(schema_, references_, value);
    case "This":
      return FromThis4(schema_, references_, value);
    case "Tuple":
      return FromTuple7(schema_, references_, value);
    case "Union":
      return FromUnion9(schema_, references_, value);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value);
    default:
      return Default(schema_, references_, value);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable(schema) {
  return IsSchema2(schema) && schema[Kind] !== "Unsafe";
}
function FromArray8(schema, references, value) {
  if (!IsArray(value))
    return value;
  return value.map((value2) => Visit9(schema.items, references, value2));
}
function FromIntersect8(schema, references, value) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value)));
  const composite = intersections.reduce((acc, value2) => IsObject(value2) ? { ...acc, ...value2 } : value2, {});
  if (!IsObject(value) || !IsObject(composite) || !IsSchema2(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value[key]);
    }
  }
  return composite;
}
function FromObject6(schema, references, value) {
  if (!IsObject(value) || IsArray(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value)) {
    if (key in schema.properties) {
      value[key] = Visit9(schema.properties[key], references, value[key]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRecord6(schema, references, value) {
  if (!IsObject(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value[key] = Visit9(propertySchema, references, value[key]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRef5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromThis5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromTuple8(schema, references, value) {
  if (!IsArray(value))
    return value;
  if (IsUndefined(schema.items))
    return [];
  const length = Math.min(value.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value[i] = Visit9(schema.items[i], references, value[i]);
  }
  return value.length > length ? value.slice(0, length) : value;
}
function FromUnion10(schema, references, value) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value)) {
      return Visit9(inner, references, value);
    }
  }
  return value;
}
function Visit9(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray8(schema_, references_, value);
    case "Intersect":
      return FromIntersect8(schema_, references_, value);
    case "Object":
      return FromObject6(schema_, references_, value);
    case "Record":
      return FromRecord6(schema_, references_, value);
    case "Ref":
      return FromRef5(schema_, references_, value);
    case "This":
      return FromThis5(schema_, references_, value);
    case "Tuple":
      return FromTuple8(schema_, references_, value);
    case "Union":
      return FromUnion10(schema_, references_, value);
    default:
      return value;
  }
}
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric(value) {
  return IsString(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNumber(value);
}
function IsValueTrue(value) {
  return value === true || IsNumber(value) && value === 1 || IsBigInt(value) && value === BigInt("1") || IsString(value) && (value.toLowerCase() === "true" || value === "1");
}
function IsValueFalse(value) {
  return value === false || IsNumber(value) && (value === 0 || Object.is(value, -0)) || IsBigInt(value) && value === BigInt("0") || IsString(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
}
function IsTimeStringWithTimeZone(value) {
  return IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsTimeStringWithoutTimeZone(value) {
  return IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsDateTimeStringWithoutTimeZone(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateString(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString(value, target) {
  const conversion = TryConvertString(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
  const conversion = TryConvertNumber(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
  const conversion = TryConvertBoolean(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteral(schema, value) {
  return IsString(schema.const) ? TryConvertLiteralString(value, schema.const) : IsNumber(schema.const) ? TryConvertLiteralNumber(value, schema.const) : IsBoolean(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : Clone2(value);
}
function TryConvertBoolean(value) {
  return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
}
function TryConvertBigInt(value) {
  return IsStringNumeric(value) ? BigInt(parseInt(value)) : IsNumber(value) ? BigInt(value | 0) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
}
function TryConvertString(value) {
  return IsValueToString(value) ? value.toString() : IsSymbol(value) && value.description !== undefined ? value.description.toString() : value;
}
function TryConvertNumber(value) {
  return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertInteger(value) {
  return IsStringNumeric(value) ? parseInt(value) : IsNumber(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertNull(value) {
  return IsString(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined(value) {
  return IsString(value) && value === "undefined" ? undefined : value;
}
function TryConvertDate(value) {
  return IsDate(value) ? value : IsNumber(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
}
function Default2(value) {
  return value;
}
function FromArray9(schema, references, value) {
  const elements = IsArray(value) ? value : [value];
  return elements.map((element) => Visit10(schema.items, references, element));
}
function FromBigInt5(schema, references, value) {
  return TryConvertBigInt(value);
}
function FromBoolean5(schema, references, value) {
  return TryConvertBoolean(value);
}
function FromDate5(schema, references, value) {
  return TryConvertDate(value);
}
function FromInteger5(schema, references, value) {
  return TryConvertInteger(value);
}
function FromIntersect9(schema, references, value) {
  return schema.allOf.reduce((value2, schema2) => Visit10(schema2, references, value2), value);
}
function FromLiteral6(schema, references, value) {
  return TryConvertLiteral(schema, value);
}
function FromNull5(schema, references, value) {
  return TryConvertNull(value);
}
function FromNumber5(schema, references, value) {
  return TryConvertNumber(value);
}
function FromObject7(schema, references, value) {
  const isConvertable = IsObject(value);
  if (!isConvertable)
    return value;
  const result = {};
  for (const key of Object.keys(value)) {
    result[key] = HasPropertyKey(schema.properties, key) ? Visit10(schema.properties[key], references, value[key]) : value[key];
  }
  return result;
}
function FromRecord7(schema, references, value) {
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit10(property, references, propValue);
  }
  return result;
}
function FromRef6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromString5(schema, references, value) {
  return TryConvertString(value);
}
function FromSymbol5(schema, references, value) {
  return IsString(value) || IsNumber(value) ? Symbol(value) : value;
}
function FromThis6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromTuple9(schema, references, value) {
  const isConvertable = IsArray(value) && !IsUndefined(schema.items);
  if (!isConvertable)
    return value;
  return value.map((value2, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value2) : value2;
  });
}
function FromUndefined5(schema, references, value) {
  return TryConvertUndefined(value);
}
function FromUnion11(schema, references, value) {
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, value);
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value;
}
function Visit10(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, value);
    case "BigInt":
      return FromBigInt5(schema_, references_, value);
    case "Boolean":
      return FromBoolean5(schema_, references_, value);
    case "Date":
      return FromDate5(schema_, references_, value);
    case "Integer":
      return FromInteger5(schema_, references_, value);
    case "Intersect":
      return FromIntersect9(schema_, references_, value);
    case "Literal":
      return FromLiteral6(schema_, references_, value);
    case "Null":
      return FromNull5(schema_, references_, value);
    case "Number":
      return FromNumber5(schema_, references_, value);
    case "Object":
      return FromObject7(schema_, references_, value);
    case "Record":
      return FromRecord7(schema_, references_, value);
    case "Ref":
      return FromRef6(schema_, references_, value);
    case "String":
      return FromString5(schema_, references_, value);
    case "Symbol":
      return FromSymbol5(schema_, references_, value);
    case "This":
      return FromThis6(schema_, references_, value);
    case "Tuple":
      return FromTuple9(schema_, references_, value);
    case "Undefined":
      return FromUndefined5(schema_, references_, value);
    case "Union":
      return FromUnion11(schema_, references_, value);
    default:
      return Default2(value);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault(schema, value) {
  return value === undefined && "default" in schema ? Clone2(schema.default) : value;
}
function IsCheckable2(schema) {
  return IsSchema2(schema) && schema[Kind] !== "Unsafe";
}
function IsDefaultSchema(value) {
  return IsSchema2(value) && "default" in value;
}
function FromArray10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit11(schema.items, references, defaulted[i]);
  }
  return defaulted;
}
function FromIntersect10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit11(schema2, references, defaulted);
    return IsObject(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject8(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    if (!IsDefaultSchema(schema.properties[key]))
      continue;
    defaulted[key] = Visit11(schema.properties[key], references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord8(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))
      continue;
    defaulted[key] = Visit11(propertySchema, references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef7(schema, references, value) {
  return Visit11(Deref(schema, references), references, ValueOrDefault(schema, value));
}
function FromThis7(schema, references, value) {
  return Visit11(Deref(schema, references), references, value);
}
function FromTuple10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray(defaulted) || IsUndefined(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit11(items[i], references, defaulted[i]);
  }
  return defaulted;
}
function FromUnion12(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  for (const inner of schema.anyOf) {
    const result = Visit11(inner, references, defaulted);
    if (IsCheckable2(inner) && Check(inner, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit11(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, value);
    case "Intersect":
      return FromIntersect10(schema_, references_, value);
    case "Object":
      return FromObject8(schema_, references_, value);
    case "Record":
      return FromRecord8(schema_, references_, value);
    case "Ref":
      return FromRef7(schema_, references_, value);
    case "This":
      return FromThis7(schema_, references_, value);
    case "Tuple":
      return FromTuple10(schema_, references_, value);
    case "Union":
      return FromUnion12(schema_, references_, value);
    default:
      return ValueOrDefault(schema_, value);
  }
}
function Default3(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => ValuePointerRootSetError,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  Set: () => Set4,
  Has: () => Has3,
  Get: () => Get3,
  Format: () => Format,
  Delete: () => Delete3
});
class ValuePointerRootSetError extends TypeBoxError {
  constructor(value, path, update) {
    super("Cannot set root value");
    this.value = value;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  constructor(value, path) {
    super("Cannot delete root value");
    this.value = value;
    this.path = path;
  }
}
function Escape2(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value, pointer, update);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value, pointer);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value, pointer) {
  if (pointer === "")
    return value;
  let current = value;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}
// node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDeltaError extends TypeBoxError {
  constructor(value, message) {
    super(message);
    this.value = value;
  }
}

class ValueDeltaSymbolError extends ValueDeltaError {
  constructor(value) {
    super(value, "Cannot diff objects with symbol keys");
    this.value = value;
  }
}
function CreateUpdate(path, value) {
  return { type: "update", path, value };
}
function CreateInsert(path, value) {
  return { type: "insert", path, value };
}
function CreateDelete(path) {
  return { type: "delete", path };
}
function* ObjectType4(path, current, next) {
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
  const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
  for (const key of currentKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && nextKeys.includes(key))
      yield CreateUpdate(`${path}/${globalThis.String(key)}`, undefined);
  }
  for (const key of nextKeys) {
    if (IsUndefined(current[key]) || IsUndefined(next[key]))
      continue;
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    yield* Visit12(`${path}/${globalThis.String(key)}`, current[key], next[key]);
  }
  for (const key of nextKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(current[key]))
      yield CreateInsert(`${path}/${globalThis.String(key)}`, next[key]);
  }
  for (const key of currentKeys.reverse()) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && !nextKeys.includes(key))
      yield CreateDelete(`${path}/${globalThis.String(key)}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit12(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
}
function Diff(current, next) {
  return [...Visit12("", current, next)];
}
function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
  return edits.length === 0;
}
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone2 = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone2, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone2, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone2, edit.path);
        break;
      }
    }
  }
  return clone2;
}
// node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType5(left2, right2) {
  if (!IsStandardObject(right2))
    return false;
  const leftKeys = [...Object.keys(left2), ...Object.getOwnPropertySymbols(left2)];
  const rightKeys = [...Object.keys(right2), ...Object.getOwnPropertySymbols(right2)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left2[key], right2[key]));
}
function DateType4(left2, right2) {
  return IsDate(right2) && left2.getTime() === right2.getTime();
}
function ArrayType5(left2, right2) {
  if (!IsArray(right2) || left2.length !== right2.length)
    return false;
  return left2.every((value, index) => Equal(value, right2[index]));
}
function TypedArrayType3(left2, right2) {
  if (!IsTypedArray(right2) || left2.length !== right2.length || Object.getPrototypeOf(left2).constructor.name !== Object.getPrototypeOf(right2).constructor.name)
    return false;
  return left2.every((value, index) => Equal(value, right2[index]));
}
function ValueType3(left2, right2) {
  return left2 === right2;
}
function Equal(left2, right2) {
  if (IsStandardObject(left2))
    return ObjectType5(left2, right2);
  if (IsDate(left2))
    return DateType4(left2, right2);
  if (IsTypedArray(left2))
    return TypedArrayType3(left2, right2);
  if (IsArray(left2))
    return ArrayType5(left2, right2);
  if (IsValueType(left2))
    return ValueType3(left2, right2);
  throw new Error("ValueEquals: Unable to compare value");
}
// node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
function ObjectType6(root, path, current, next) {
  if (!IsStandardObject(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit13(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType6(root, path, current, next) {
  if (!IsArray(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit13(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType4(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
}
function ValueType4(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
}
function Visit13(root, path, current, next) {
  if (IsArray(next))
    return ArrayType6(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType4(root, path, current, next);
  if (IsStandardObject(next))
    return ObjectType6(root, path, current, next);
  if (IsValueType(next))
    return ValueType4(root, path, current, next);
}
function IsNonMutableValue(value) {
  return IsTypedArray(value) || IsValueType(value);
}
function IsMismatchedValue(current, next) {
  return IsStandardObject(current) && IsArray(next) || IsArray(current) && IsStandardObject(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit13(current, "", current, next);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
class TransformDecodeCheckError extends TypeBoxError {
  constructor(schema, value, error2) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error2;
  }
}

class TransformDecodeError extends TypeBoxError {
  constructor(schema, path, value, error2) {
    super(error2 instanceof Error ? error2.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error2;
  }
}
function Default4(schema, path, value) {
  try {
    return IsTransform2(schema) ? schema[TransformKind].Decode(value) : value;
  } catch (error2) {
    throw new TransformDecodeError(schema, path, value, error2);
  }
}
function FromArray11(schema, references, path, value) {
  return IsArray(value) ? Default4(schema, path, value.map((value2, index) => Visit14(schema.items, references, `${path}/${index}`, value2))) : Default4(schema, path, value);
}
function FromIntersect11(schema, references, path, value) {
  if (!IsStandardObject(value) || IsValueType(value))
    return Default4(schema, path, value);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit14(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default4(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromNot5(schema, references, path, value) {
  return Default4(schema, path, Visit14(schema.not, references, path, value));
}
function FromObject9(schema, references, path, value) {
  if (!IsStandardObject(value))
    return Default4(schema, path, value);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value };
  for (const key of knownKeys)
    if (key in knownProperties) {
      knownProperties[key] = Visit14(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default4(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromRecord9(schema, references, path, value) {
  if (!IsStandardObject(value))
    return Default4(schema, path, value);
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern2);
  const knownProperties = { ...value };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit14(schema.patternProperties[pattern2], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default4(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromRef8(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default4(schema, path, Visit14(target, references, path, value));
}
function FromThis8(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default4(schema, path, Visit14(target, references, path, value));
}
function FromTuple11(schema, references, path, value) {
  return IsArray(value) && IsArray(schema.items) ? Default4(schema, path, schema.items.map((schema2, index) => Visit14(schema2, references, `${path}/${index}`, value[index]))) : Default4(schema, path, value);
}
function FromUnion13(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const decoded = Visit14(subschema, references, path, value);
    return Default4(schema, path, decoded);
  }
  return Default4(schema, path, value);
}
function Visit14(schema, references, path, value) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect11(schema_, references_, path, value);
    case "Not":
      return FromNot5(schema_, references_, path, value);
    case "Object":
      return FromObject9(schema_, references_, path, value);
    case "Record":
      return FromRecord9(schema_, references_, path, value);
    case "Ref":
      return FromRef8(schema_, references_, path, value);
    case "Symbol":
      return Default4(schema_, path, value);
    case "This":
      return FromThis8(schema_, references_, path, value);
    case "Tuple":
      return FromTuple11(schema_, references_, path, value);
    case "Union":
      return FromUnion13(schema_, references_, path, value);
    default:
      return Default4(schema_, path, value);
  }
}
function TransformDecode(schema, references, value) {
  return Visit14(schema, references, "", value);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
class TransformEncodeCheckError extends TypeBoxError {
  constructor(schema, value, error2) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error2;
  }
}

class TransformEncodeError extends TypeBoxError {
  constructor(schema, path, value, error2) {
    super(`${error2 instanceof Error ? error2.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error2;
  }
}
function Default5(schema, path, value) {
  try {
    return IsTransform2(schema) ? schema[TransformKind].Encode(value) : value;
  } catch (error2) {
    throw new TransformEncodeError(schema, path, value, error2);
  }
}
function FromArray12(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  return IsArray(defaulted) ? defaulted.map((value2, index) => Visit15(schema.items, references, `${path}/${index}`, value2)) : defaulted;
}
function FromIntersect12(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  if (!IsStandardObject(value) || IsValueType(value))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit15(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default5(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default5(unevaluatedProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot6(schema, references, path, value) {
  return Default5(schema.not, path, Default5(schema, path, value));
}
function FromObject10(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  if (!IsStandardObject(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys)
    if (key in knownProperties) {
      knownProperties[key] = Visit15(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default5(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord10(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  if (!IsStandardObject(value))
    return defaulted;
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern2);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit15(schema.patternProperties[pattern2], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default5(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default5(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef9(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path, value);
  return Default5(schema, path, resolved);
}
function FromThis9(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path, value);
  return Default5(schema, path, resolved);
}
function FromTuple12(schema, references, path, value) {
  const value1 = Default5(schema, path, value);
  return IsArray(schema.items) ? schema.items.map((schema2, index) => Visit15(schema2, references, `${path}/${index}`, value1[index])) : [];
}
function FromUnion14(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const value1 = Visit15(subschema, references, path, value);
    return Default5(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit15(subschema, references, path, value);
    if (!Check(schema, references, value1))
      continue;
    return Default5(schema, path, value1);
  }
  return Default5(schema, path, value);
}
function Visit15(schema, references, path, value) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect12(schema_, references_, path, value);
    case "Not":
      return FromNot6(schema_, references_, path, value);
    case "Object":
      return FromObject10(schema_, references_, path, value);
    case "Record":
      return FromRecord10(schema_, references_, path, value);
    case "Ref":
      return FromRef9(schema_, references_, path, value);
    case "This":
      return FromThis9(schema_, references_, path, value);
    case "Tuple":
      return FromTuple12(schema_, references_, path, value);
    case "Union":
      return FromUnion14(schema_, references_, path, value);
    default:
      return Default5(schema_, path, value);
  }
}
function TransformEncode(schema, references, value) {
  return Visit15(schema, references, "", value);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray13(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromAsyncIterator5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromConstructor6(schema, references) {
  return IsTransform2(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
}
function FromFunction5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
}
function FromIntersect13(schema, references) {
  return IsTransform2(schema) || IsTransform2(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit16(schema2, references));
}
function FromIterator5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromNot7(schema, references) {
  return IsTransform2(schema) || Visit16(schema.not, references);
}
function FromObject11(schema, references) {
  return IsTransform2(schema) || Object.values(schema.properties).some((schema2) => Visit16(schema2, references)) || IsSchema2(schema.additionalProperties) && Visit16(schema.additionalProperties, references);
}
function FromPromise5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.item, references);
}
function FromRecord11(schema, references) {
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern2];
  return IsTransform2(schema) || Visit16(property, references) || IsSchema2(schema.additionalProperties) && IsTransform2(schema.additionalProperties);
}
function FromRef10(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit16(Deref(schema, references), references);
}
function FromThis10(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit16(Deref(schema, references), references);
}
function FromTuple13(schema, references) {
  return IsTransform2(schema) || !IsUndefined(schema.items) && schema.items.some((schema2) => Visit16(schema2, references));
}
function FromUnion15(schema, references) {
  return IsTransform2(schema) || schema.anyOf.some((schema2) => Visit16(schema2, references));
}
function Visit16(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator5(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator5(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise5(schema_, references_);
    case "Record":
      return FromRecord11(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "This":
      return FromThis10(schema_, references_);
    case "Tuple":
      return FromTuple13(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform2(schema);
  }
}
var visited = new Set;
function HasTransform(schema, references) {
  visited.clear();
  return Visit16(schema, references);
}
// node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  Patch: () => Patch2,
  Mutate: () => Mutate2,
  Hash: () => Hash2,
  Errors: () => Errors2,
  Equal: () => Equal2,
  Encode: () => Encode,
  Diff: () => Diff2,
  Default: () => Default6,
  Decode: () => Decode,
  Create: () => Create3,
  Convert: () => Convert2,
  Clone: () => Clone3,
  Clean: () => Clean2,
  Check: () => Check2,
  Cast: () => Cast2
});
function Cast2(...args) {
  return Cast.apply(Cast, args);
}
function Create3(...args) {
  return Create2.apply(Create2, args);
}
function Check2(...args) {
  return Check.apply(Check, args);
}
function Clean2(...args) {
  return Clean.apply(Clean, args);
}
function Convert2(...args) {
  return Convert.apply(Convert, args);
}
function Clone3(value) {
  return Clone2(value);
}
function Decode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check2(schema, references, value))
    throw new TransformDecodeCheckError(schema, value, Errors2(schema, references, value).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;
}
function Default6(...args) {
  return Default3.apply(Default3, args);
}
function Encode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value) : value;
  if (!Check2(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors2(schema, references, encoded).First());
  return encoded;
}
function Errors2(...args) {
  return Errors.apply(Errors, args);
}
function Equal2(left2, right2) {
  return Equal(left2, right2);
}
function Diff2(current, next) {
  return Diff(current, next);
}
function Hash2(value) {
  return Hash(value);
}
function Patch2(current, edits) {
  return Patch(current, edits);
}
function Mutate2(current, next) {
  Mutate(current, next);
}
// node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromRest4(T) {
  return T.map((L) => AwaitedResolve(L));
}
function FromIntersect14(T) {
  return Intersect(FromRest4(T));
}
function FromUnion16(T) {
  return Union(FromRest4(T));
}
function FromPromise6(T) {
  return AwaitedResolve(T);
}
function AwaitedResolve(T) {
  return IsIntersect(T) ? FromIntersect14(T.allOf) : IsUnion(T) ? FromUnion16(T.anyOf) : IsPromise2(T) ? FromPromise6(T.item) : T;
}
function Awaited(T, options = {}) {
  return CloneType(AwaitedResolve(T), options);
}
// node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite(T, options = {}) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}
// node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options = {}) {
  return {
    ...options,
    [Kind]: "Date",
    type: "Date"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options = {}) {
  return {
    ...options,
    [Kind]: "Null",
    type: "null"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return { ...options, [Kind]: "Symbol", type: "symbol" };
}
// node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options = {}) {
  return { ...options, [Kind]: "Undefined", type: "undefined" };
}
// node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options = {}) {
  return { ...options, [Kind]: "Uint8Array", type: "Uint8Array" };
}
// node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray14(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties8(value2) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value2))
    Acc[K] = Readonly(FromValue(value2[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value2, root) {
  return IsAsyncIterator2(value2) ? ConditionalReadonly(Any(), root) : IsIterator2(value2) ? ConditionalReadonly(Any(), root) : IsArray2(value2) ? Readonly(Tuple(FromArray14(value2))) : IsUint8Array2(value2) ? Uint8Array2() : IsDate2(value2) ? Date2() : IsObject2(value2) ? ConditionalReadonly(Object2(FromProperties8(value2)), root) : IsFunction2(value2) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined2(value2) ? Undefined() : IsNull2(value2) ? Null() : IsSymbol2(value2) ? Symbol2() : IsBigInt2(value2) ? BigInt2() : IsNumber2(value2) ? Literal(value2) : IsBoolean2(value2) ? Literal(value2) : IsString2(value2) ? Literal(value2) : Object2({});
}
function Const(T, options = {}) {
  return CloneType(FromValue(T, true), options);
}
// node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/esm/type/deref/deref.mjs
function FromRest5(schema, references) {
  return schema.map((schema2) => Deref2(schema2, references));
}
function FromProperties9(properties, references) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties)) {
    Acc[K] = Deref2(properties[K], references);
  }
  return Acc;
}
function FromConstructor7(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
}
function FromFunction6(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
}
function FromIntersect15(schema, references) {
  schema.allOf = FromRest5(schema.allOf, references);
  return schema;
}
function FromUnion17(schema, references) {
  schema.anyOf = FromRest5(schema.anyOf, references);
  return schema;
}
function FromTuple14(schema, references) {
  if (IsUndefined2(schema.items))
    return schema;
  schema.items = FromRest5(schema.items, references);
  return schema;
}
function FromArray15(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromObject12(schema, references) {
  schema.properties = FromProperties9(schema.properties, references);
  return schema;
}
function FromPromise7(schema, references) {
  schema.item = Deref2(schema.item, references);
  return schema;
}
function FromAsyncIterator6(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromIterator6(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromRef11(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === undefined)
    throw Error(`Unable to dereference schema with $id ${schema.$ref}`);
  const discard2 = Discard(target, ["$id"]);
  return Deref2(discard2, references);
}
function DerefResolve(schema, references) {
  return IsConstructor(schema) ? FromConstructor7(schema, references) : IsFunction3(schema) ? FromFunction6(schema, references) : IsIntersect(schema) ? FromIntersect15(schema, references) : IsUnion(schema) ? FromUnion17(schema, references) : IsTuple(schema) ? FromTuple14(schema, references) : IsArray3(schema) ? FromArray15(schema, references) : IsObject3(schema) ? FromObject12(schema, references) : IsPromise2(schema) ? FromPromise7(schema, references) : IsAsyncIterator3(schema) ? FromAsyncIterator6(schema, references) : IsIterator3(schema) ? FromIterator6(schema, references) : IsRef(schema) ? FromRef11(schema, references) : schema;
}
function Deref2(schema, references) {
  return DerefResolve(CloneType(schema), CloneRest(references));
}
// node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options = {}) {
  if (IsUndefined2(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value2) => Literal(value2));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}
// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExcludeFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties10(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties10(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExtractFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties11(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties11(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options = {}) {
  return {
    ...options,
    [Kind]: "Integer",
    type: "integer"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, options)
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value2) {
  const [first, rest] = [value2.slice(0, 1), value2.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value2) {
  const [first, rest] = [value2.slice(0, 1), value2.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value2) {
  return value2.toUpperCase();
}
function ApplyLowercase(value2) {
  return value2.toLowerCase();
}
function FromTemplateLiteral6(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite2 = IsTemplateLiteralExpressionFinite(expression);
  if (!finite2)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value2) => Literal(value2));
  const mapped2 = FromRest6(literals, mode);
  const union4 = Union(mapped2);
  return TemplateLiteral([union4], options);
}
function FromLiteralValue(value2, mode) {
  return typeof value2 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value2) : mode === "Capitalize" ? ApplyCapitalize(value2) : mode === "Uppercase" ? ApplyUppercase(value2) : mode === "Lowercase" ? ApplyLowercase(value2) : value2 : value2.toString();
}
function FromRest6(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral6(schema, mode, schema) : IsUnion(schema) ? Union(FromRest6(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema;
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}
// node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(schema, options) {
  return {
    ...options,
    [Kind]: "Not",
    not: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Omit(P[K2], K, options);
  return Acc;
}
function FromMappedResult9(R, K, options) {
  return FromProperties12(R.properties, K, options);
}
function OmitFromMappedResult(R, K, options) {
  const P = FromMappedResult9(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect16(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromUnion18(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromProperty2(T, K) {
  const { [K]: _, ...R } = T;
  return R;
}
function FromProperties13(T, K) {
  return K.reduce((T2, K2) => FromProperty2(T2, K2), T);
}
function OmitResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect16(T.allOf, K)) : IsUnion(T) ? Union(FromUnion18(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties13(T.properties, K)) : Object2({});
}
function Omit(T, K, options = {}) {
  if (IsMappedKey(K))
    return OmitFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return OmitFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(OmitResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(T, K, options) {
  return {
    [K]: Omit(T, [K], options)
  };
}
function FromPropertyKeys2(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(T, LK, options) };
  }, {});
}
function FromMappedKey3(T, K, options) {
  return FromPropertyKeys2(T, K.keys, options);
}
function OmitFromMappedKey(T, K, options) {
  const P = FromMappedKey3(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromRest7(T) {
  return T.map((L) => PartialResolve(L));
}
function FromProperties14(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Optional(T[K]);
  return Acc;
}
function PartialResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest7(T.allOf)) : IsUnion(T) ? Union(FromRest7(T.anyOf)) : IsObject3(T) ? Object2(FromProperties14(T.properties)) : Object2({});
}
function Partial(T, options = {}) {
  if (IsMappedResult(T))
    return PartialFromMappedResult(T, options);
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PartialResolve(T), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties15(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], options);
  return Acc;
}
function FromMappedResult10(R, options) {
  return FromProperties15(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult10(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties16(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Pick(P[K2], K, options);
  return Acc;
}
function FromMappedResult11(R, K, options) {
  return FromProperties16(R.properties, K, options);
}
function PickFromMappedResult(R, K, options) {
  const P = FromMappedResult11(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect17(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromUnion19(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromProperties17(T, K) {
  const Acc = {};
  for (const K2 of K)
    if (K2 in T)
      Acc[K2] = T[K2];
  return Acc;
}
function PickResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect17(T.allOf, K)) : IsUnion(T) ? Union(FromUnion19(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties17(T.properties, K)) : Object2({});
}
function Pick(T, K, options = {}) {
  if (IsMappedKey(K))
    return PickFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return PickFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PickResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(T, K, options) {
  return {
    [K]: Pick(T, [K], options)
  };
}
function FromPropertyKeys3(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey3(T, LK, options) };
  }, {});
}
function FromMappedKey4(T, K, options) {
  return FromPropertyKeys3(T, K.keys, options);
}
function PickFromMappedKey(T, K, options) {
  const P = FromMappedKey4(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}
// node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern2, T, options) {
  return {
    ...options,
    [Kind]: "Record",
    type: "object",
    patternProperties: { [pattern2]: CloneType(T) }
  };
}
function RecordCreateFromKeys(K, T, options) {
  const Acc = {};
  for (const K2 of K)
    Acc[K2] = CloneType(T);
  return Object2(Acc, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(K, T, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);
}
function FromLiteralKey(K, T, options) {
  return RecordCreateFromKeys([K.toString()], T, options);
}
function FromRegExpKey(K, T, options) {
  return RecordCreateFromPattern(K.source, T, options);
}
function FromStringKey(K, T, options) {
  const pattern2 = IsUndefined2(K.pattern) ? PatternStringExact : K.pattern;
  return RecordCreateFromPattern(pattern2, T, options);
}
function FromIntegerKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function FromNumberKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function Record(K, T, options = {}) {
  return IsUnion(K) ? FromUnionKey(K.anyOf, T, options) : IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) : IsLiteral(K) ? FromLiteralKey(K.const, T, options) : IsInteger2(K) ? FromIntegerKey(K, T, options) : IsNumber3(K) ? FromNumberKey(K, T, options) : IsRegExp2(K) ? FromRegExpKey(K, T, options) : IsString3(K) ? FromStringKey(K, T, options) : Never(options);
}
// node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined2(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = callback({ [Kind]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType({ ...options, [Hint]: "Recursive", ...thisType });
}
// node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(unresolved, options = {}) {
  if (IsString2(unresolved))
    return { ...options, [Kind]: "Ref", $ref: unresolved };
  if (IsUndefined2(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind]: "Ref",
    $ref: unresolved.$id
  };
}
// node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options = {}) {
  const expr = IsString2(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}
// node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromRest8(T) {
  return T.map((L) => RequiredResolve(L));
}
function FromProperties18(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Discard(T[K], [OptionalKind]);
  return Acc;
}
function RequiredResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest8(T.allOf)) : IsUnion(T) ? Union(FromRest8(T.anyOf)) : IsObject3(T) ? Object2(FromProperties18(T.properties)) : Object2({});
}
function Required(T, options = {}) {
  if (IsMappedResult(T)) {
    return RequiredFromMappedResult(T, options);
  } else {
    const D = Discard(T, [TransformKind, "$id", "required"]);
    const R = CloneType(RequiredResolve(T), options);
    return { ...D, ...R };
  }
}

// node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? CloneRest(T.allOf) : IsUnion(T) ? CloneRest(T.anyOf) : IsTuple(T) ? CloneRest(T.items ?? []) : [];
}
function Rest(T) {
  return CloneRest(RestResolve(T));
}
// node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/esm/type/strict/strict.mjs
function Strict(schema2) {
  return JSON.parse(JSON.stringify(schema2));
}
// node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
class TransformDecodeBuilder {
  constructor(schema2) {
    this.schema = schema2;
  }
  Decode(decode2) {
    return new TransformEncodeBuilder(this.schema, decode2);
  }
}

class TransformEncodeBuilder {
  constructor(schema2, decode2) {
    this.schema = schema2;
    this.decode = decode2;
  }
  EncodeTransform(encode2, schema2) {
    const Encode2 = (value2) => schema2[TransformKind].Encode(encode2(value2));
    const Decode2 = (value2) => this.decode(schema2[TransformKind].Decode(value2));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  EncodeSchema(encode2, schema2) {
    const Codec = { Decode: this.decode, Encode: encode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  Encode(encode2) {
    const schema2 = CloneType(this.schema);
    return IsTransform(schema2) ? this.EncodeTransform(encode2, schema2) : this.EncodeSchema(encode2, schema2);
  }
}
function Transform(schema2) {
  return new TransformDecodeBuilder(schema2);
}
// node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options = {}) {
  return {
    ...options,
    [Kind]: "Void",
    type: "void"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => Void,
  Uppercase: () => Uppercase,
  Unsafe: () => Unsafe,
  Unknown: () => Unknown,
  Union: () => Union,
  Undefined: () => Undefined,
  Uncapitalize: () => Uncapitalize,
  Uint8Array: () => Uint8Array2,
  Tuple: () => Tuple,
  Transform: () => Transform,
  TemplateLiteral: () => TemplateLiteral,
  Symbol: () => Symbol2,
  String: () => String2,
  Strict: () => Strict,
  ReturnType: () => ReturnType,
  Rest: () => Rest,
  Required: () => Required,
  RegExp: () => RegExp2,
  Ref: () => Ref,
  Recursive: () => Recursive,
  Record: () => Record,
  ReadonlyOptional: () => ReadonlyOptional,
  Readonly: () => Readonly,
  Promise: () => Promise2,
  Pick: () => Pick,
  Partial: () => Partial,
  Parameters: () => Parameters,
  Optional: () => Optional,
  Omit: () => Omit,
  Object: () => Object2,
  Number: () => Number2,
  Null: () => Null,
  Not: () => Not2,
  Never: () => Never,
  Mapped: () => Mapped,
  Lowercase: () => Lowercase,
  Literal: () => Literal,
  KeyOf: () => KeyOf,
  Iterator: () => Iterator,
  Intersect: () => Intersect,
  Integer: () => Integer,
  InstanceType: () => InstanceType,
  Index: () => Index,
  Function: () => Function2,
  Extract: () => Extract,
  Extends: () => Extends,
  Exclude: () => Exclude,
  Enum: () => Enum,
  Deref: () => Deref2,
  Date: () => Date2,
  ConstructorParameters: () => ConstructorParameters,
  Constructor: () => Constructor,
  Const: () => Const,
  Composite: () => Composite,
  Capitalize: () => Capitalize,
  Boolean: () => Boolean2,
  BigInt: () => BigInt2,
  Awaited: () => Awaited,
  AsyncIterator: () => AsyncIterator,
  Array: () => Array2,
  Any: () => Any
});

// node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = exports_type3;
// node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
class TypeCheck {
  constructor(schema3, references, checkFunc, code) {
    this.schema = schema3;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema3, references);
  }
  Code() {
    return this.code;
  }
  Errors(value2) {
    return Errors(this.schema, this.references, value2);
  }
  Check(value2) {
    return this.checkFunc(value2);
  }
  Decode(value2) {
    if (!this.checkFunc(value2))
      throw new TransformDecodeCheckError(this.schema, value2, this.Errors(value2).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value2) : value2;
  }
  Encode(value2) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value2) : value2;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value2, this.Errors(value2).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value2) {
    if (value2.length === 0)
      return false;
    return Character.IsNumeric(value2.charCodeAt(0));
  }
  function IsAccessor(value2) {
    if (IsFirstCharacterNumeric(value2))
      return false;
    for (let i = 0;i < value2.length; i++) {
      const code = value2.charCodeAt(i);
      const check3 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check3)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object3, key) {
    return IsAccessor(key) ? `${object3}.${key}` : `${object3}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  constructor(schema3) {
    super("Unknown type");
    this.schema = schema3;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  constructor(schema3) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema3;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value2, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value2} ? ${expression} : true)` : `(${MemberExpression.Encode(value2, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value2) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value2} === 'object' && ${value2} !== null && !Array.isArray(${value2}))` : `(typeof ${value2} === 'object' && ${value2} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value2) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value2} === 'object' && ${value2} !== null && !Array.isArray(${value2}) && !(${value2} instanceof Date) && !(${value2} instanceof Uint8Array))` : `(typeof ${value2} === 'object' && ${value2} !== null && !(${value2} instanceof Date) && !(${value2} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value2) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value2} === 'number'` : `Number.isFinite(${value2})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value2) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value2} === undefined || ${value2} === null)` : `${value2} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema3) {
    return schema3[Kind] === "Any" || schema3[Kind] === "Unknown";
  }
  function* FromAny5(schema3, references, value2) {
    yield "true";
  }
  function* FromArray16(schema3, references, value2) {
    yield `Array.isArray(${value2})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber(schema3.maxItems))
      yield `${value2}.length <= ${schema3.maxItems}`;
    if (IsNumber(schema3.minItems))
      yield `${value2}.length >= ${schema3.minItems}`;
    const elementExpression = CreateExpression(schema3.items, references, "value");
    yield `${value2}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema3.contains) || IsNumber(schema3.minContains) || IsNumber(schema3.maxContains)) {
      const containsSchema = IsSchema2(schema3.contains) ? schema3.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber(schema3.minContains) ? [`(count >= ${schema3.minContains})`] : [];
      const checkMaxContains = IsNumber(schema3.maxContains) ? [`(count <= ${schema3.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check3 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check3}})(${value2})`;
    }
    if (schema3.uniqueItems === true) {
      const check3 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check3} }`;
      yield `((${parameter}) => { ${block} )(${value2})`;
    }
  }
  function* FromAsyncIterator7(schema3, references, value2) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value2})`;
  }
  function* FromBigInt6(schema3, references, value2) {
    yield `(typeof ${value2} === 'bigint')`;
    if (IsBigInt(schema3.exclusiveMaximum))
      yield `${value2} < BigInt(${schema3.exclusiveMaximum})`;
    if (IsBigInt(schema3.exclusiveMinimum))
      yield `${value2} > BigInt(${schema3.exclusiveMinimum})`;
    if (IsBigInt(schema3.maximum))
      yield `${value2} <= BigInt(${schema3.maximum})`;
    if (IsBigInt(schema3.minimum))
      yield `${value2} >= BigInt(${schema3.minimum})`;
    if (IsBigInt(schema3.multipleOf))
      yield `(${value2} % BigInt(${schema3.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema3, references, value2) {
    yield `(typeof ${value2} === 'boolean')`;
  }
  function* FromConstructor8(schema3, references, value2) {
    yield* Visit17(schema3.returns, references, `${value2}.prototype`);
  }
  function* FromDate6(schema3, references, value2) {
    yield `(${value2} instanceof Date) && Number.isFinite(${value2}.getTime())`;
    if (IsNumber(schema3.exclusiveMaximumTimestamp))
      yield `${value2}.getTime() < ${schema3.exclusiveMaximumTimestamp}`;
    if (IsNumber(schema3.exclusiveMinimumTimestamp))
      yield `${value2}.getTime() > ${schema3.exclusiveMinimumTimestamp}`;
    if (IsNumber(schema3.maximumTimestamp))
      yield `${value2}.getTime() <= ${schema3.maximumTimestamp}`;
    if (IsNumber(schema3.minimumTimestamp))
      yield `${value2}.getTime() >= ${schema3.minimumTimestamp}`;
    if (IsNumber(schema3.multipleOfTimestamp))
      yield `(${value2}.getTime() % ${schema3.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction7(schema3, references, value2) {
    yield `(typeof ${value2} === 'function')`;
  }
  function* FromInteger6(schema3, references, value2) {
    yield `Number.isInteger(${value2})`;
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value2} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value2} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value2} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value2} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value2} % ${schema3.multipleOf}) === 0`;
  }
  function* FromIntersect18(schema3, references, value2) {
    const check1 = schema3.allOf.map((schema4) => CreateExpression(schema4, references, value2)).join(" && ");
    if (schema3.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value2}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check22})`;
    } else if (IsSchema2(schema3.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value2}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema3.unevaluatedProperties, references, `${value2}[key]`)})`;
      yield `(${check1} && ${check22})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator7(schema3, references, value2) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value2})`;
  }
  function* FromLiteral7(schema3, references, value2) {
    if (typeof schema3.const === "number" || typeof schema3.const === "boolean") {
      yield `(${value2} === ${schema3.const})`;
    } else {
      yield `(${value2} === '${LiteralString.Escape(schema3.const)}')`;
    }
  }
  function* FromNever6(schema3, references, value2) {
    yield `false`;
  }
  function* FromNot8(schema3, references, value2) {
    const expression = CreateExpression(schema3.not, references, value2);
    yield `(!${expression})`;
  }
  function* FromNull6(schema3, references, value2) {
    yield `(${value2} === null)`;
  }
  function* FromNumber6(schema3, references, value2) {
    yield Policy.IsNumberLike(value2);
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value2} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value2} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value2} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value2} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value2} % ${schema3.multipleOf}) === 0`;
  }
  function* FromObject13(schema3, references, value2) {
    yield Policy.IsObjectLike(value2);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value2}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value2}).length <= ${schema3.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema3.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value2, knownKey);
      const property = schema3.properties[knownKey];
      if (schema3.required && schema3.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value2})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value2, knownKey, expression);
      }
    }
    if (schema3.additionalProperties === false) {
      if (schema3.required && schema3.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value2}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value2}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema3.additionalProperties === "object") {
      const expression = CreateExpression(schema3.additionalProperties, references, `${value2}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value2}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema3, references, value2) {
    yield `(typeof value === 'object' && typeof ${value2}.then === 'function')`;
  }
  function* FromRecord12(schema3, references, value2) {
    yield Policy.IsRecordLike(value2);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value2}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value2}).length <= ${schema3.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema3.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check22 = IsSchema2(schema3.additionalProperties) ? CreateExpression(schema3.additionalProperties, references, value2) : schema3.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
    yield `(Object.entries(${value2}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef12(schema3, references, value2) {
    const target = Deref(schema3, references);
    if (state.functions.has(schema3.$ref))
      return yield `${CreateFunctionName(schema3.$ref)}(${value2})`;
    yield* Visit17(target, references, value2);
  }
  function* FromRegExp5(schema3, references, value2) {
    const variable = CreateVariable(`${new RegExp(schema3.source, schema3.flags)};`);
    yield `(typeof ${value2} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value2}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value2}.length >= ${schema3.minLength}`;
    yield `${variable}.test(${value2})`;
  }
  function* FromString6(schema3, references, value2) {
    yield `(typeof ${value2} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value2}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value2}.length >= ${schema3.minLength}`;
    if (schema3.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
      yield `${variable}.test(${value2})`;
    }
    if (schema3.format !== undefined) {
      yield `format('${schema3.format}', ${value2})`;
    }
  }
  function* FromSymbol6(schema3, references, value2) {
    yield `(typeof ${value2} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema3, references, value2) {
    yield `(typeof ${value2} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
    yield `${variable}.test(${value2})`;
  }
  function* FromThis11(schema3, references, value2) {
    yield `${CreateFunctionName(schema3.$ref)}(${value2})`;
  }
  function* FromTuple15(schema3, references, value2) {
    yield `Array.isArray(${value2})`;
    if (schema3.items === undefined)
      return yield `${value2}.length === 0`;
    yield `(${value2}.length === ${schema3.maxItems})`;
    for (let i = 0;i < schema3.items.length; i++) {
      const expression = CreateExpression(schema3.items[i], references, `${value2}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema3, references, value2) {
    yield `${value2} === undefined`;
  }
  function* FromUnion20(schema3, references, value2) {
    const expressions = schema3.anyOf.map((schema4) => CreateExpression(schema4, references, value2));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema3, references, value2) {
    yield `${value2} instanceof Uint8Array`;
    if (IsNumber(schema3.maxByteLength))
      yield `(${value2}.length <= ${schema3.maxByteLength})`;
    if (IsNumber(schema3.minByteLength))
      yield `(${value2}.length >= ${schema3.minByteLength})`;
  }
  function* FromUnknown5(schema3, references, value2) {
    yield "true";
  }
  function* FromVoid5(schema3, references, value2) {
    yield Policy.IsVoidLike(value2);
  }
  function* FromKind4(schema3, references, value2) {
    const instance = state.instances.size;
    state.instances.set(instance, schema3);
    yield `kind('${schema3[Kind]}', ${instance}, ${value2})`;
  }
  function* Visit17(schema3, references, value2, useHoisting = true) {
    const references_ = IsString(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    if (useHoisting && IsString(schema3.$id)) {
      const functionName = CreateFunctionName(schema3.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value2})`;
      } else {
        const functionCode = CreateFunction(functionName, schema3, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value2})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value2);
      case "Array":
        return yield* FromArray16(schema_, references_, value2);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, value2);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value2);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value2);
      case "Constructor":
        return yield* FromConstructor8(schema_, references_, value2);
      case "Date":
        return yield* FromDate6(schema_, references_, value2);
      case "Function":
        return yield* FromFunction7(schema_, references_, value2);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value2);
      case "Intersect":
        return yield* FromIntersect18(schema_, references_, value2);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, value2);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value2);
      case "Never":
        return yield* FromNever6(schema_, references_, value2);
      case "Not":
        return yield* FromNot8(schema_, references_, value2);
      case "Null":
        return yield* FromNull6(schema_, references_, value2);
      case "Number":
        return yield* FromNumber6(schema_, references_, value2);
      case "Object":
        return yield* FromObject13(schema_, references_, value2);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value2);
      case "Record":
        return yield* FromRecord12(schema_, references_, value2);
      case "Ref":
        return yield* FromRef12(schema_, references_, value2);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value2);
      case "String":
        return yield* FromString6(schema_, references_, value2);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value2);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value2);
      case "This":
        return yield* FromThis11(schema_, references_, value2);
      case "Tuple":
        return yield* FromTuple15(schema_, references_, value2);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value2);
      case "Union":
        return yield* FromUnion20(schema_, references_, value2);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value2);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value2);
      case "Void":
        return yield* FromVoid5(schema_, references_, value2);
      default:
        if (!exports_type.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema3);
        return yield* FromKind4(schema_, references_, value2);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema3, references, value2, useHoisting = true) {
    return `(${[...Visit17(schema3, references, value2, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema3, references, value2, useHoisting = true) {
    const [newline, pad] = [`
`, (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema3, references, value2, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
  }
  function CreateParameter(name, type3) {
    const annotation = state.language === "typescript" ? `: ${type3}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type3) {
    return state.language === "typescript" ? `: ${type3}` : "";
  }
  function Build(schema3, references, options) {
    const functionCode = CreateFunction("check", schema3, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString(schema3.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema3.$id)}(value)
}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join(`
`);
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema3, references, options] = args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema3))
      throw new TypeCompilerTypeGuardError(schema3);
    for (const schema4 of references)
      if (!IsSchema2(schema4))
        throw new TypeCompilerTypeGuardError(schema4);
    return Build(schema3, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema3, references = []) {
    const generatedCode = Code(schema3, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value2) {
      if (!exports_type.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type.Get(kind);
      const schema4 = instances.get(instance);
      return checkFunc(schema4, value2);
    }
    function formatRegistryFunction(format3, value2) {
      if (!exports_format.Has(format3))
        return false;
      const checkFunc = exports_format.Get(format3);
      return checkFunc(value2);
    }
    function hashFunction(value2) {
      return Hash(value2);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema3, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));
// node_modules/elysia/dist/bun/index.js
var H2 = Object.create;
var { getPrototypeOf: R2, defineProperty: f1, getOwnPropertyNames: b2 } = Object;
var x2 = Object.prototype.hasOwnProperty;
var k0 = ($, W, X) => {
  X = $ != null ? H2(R2($)) : {};
  let Z = W || !$ || !$.__esModule ? f1(X, "default", { value: $, enumerable: true }) : X;
  for (let J of b2($))
    if (!x2.call(Z, J))
      f1(Z, J, { get: () => $[J], enumerable: true });
  return Z;
};
var y1 = ($, W) => () => (W || $((W = { exports: {} }).exports, W), W.exports);
var z1 = y1((e1) => {
  Object.defineProperty(e1, "__esModule", { value: true });
  e1.parse = F3;
  e1.serialize = z3;
  var G3 = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/, B3 = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/, K3 = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, U3 = /^[\u0020-\u003A\u003D-\u007E]*$/, w3 = Object.prototype.toString, _3 = (() => {
    let $ = function() {
    };
    return $.prototype = Object.create(null), $;
  })();
  function F3($, W) {
    let X = new _3, Z = $.length;
    if (Z < 2)
      return X;
    let J = W?.decode || M3, j = 0;
    do {
      let Y = $.indexOf("=", j);
      if (Y === -1)
        break;
      let G = $.indexOf(";", j), K = G === -1 ? Z : G;
      if (Y > K) {
        j = $.lastIndexOf(";", Y - 1) + 1;
        continue;
      }
      let B = a1($, j, Y), U = o1($, Y, B), w = $.slice(B, U);
      if (X[w] === undefined) {
        let F = a1($, Y + 1, K), Q = o1($, K, F), M = J($.slice(F, Q));
        X[w] = M;
      }
      j = K + 1;
    } while (j < Z);
    return X;
  }
  function a1($, W, X) {
    do {
      let Z = $.charCodeAt(W);
      if (Z !== 32 && Z !== 9)
        return W;
    } while (++W < X);
    return X;
  }
  function o1($, W, X) {
    while (W > X) {
      let Z = $.charCodeAt(--W);
      if (Z !== 32 && Z !== 9)
        return W + 1;
    }
    return X;
  }
  function z3($, W, X) {
    let Z = X?.encode || encodeURIComponent;
    if (!G3.test($))
      throw new TypeError(`argument name is invalid: ${$}`);
    let J = Z(W);
    if (!B3.test(J))
      throw new TypeError(`argument val is invalid: ${W}`);
    let j = $ + "=" + J;
    if (!X)
      return j;
    if (X.maxAge !== undefined) {
      if (!Number.isInteger(X.maxAge))
        throw new TypeError(`option maxAge is invalid: ${X.maxAge}`);
      j += "; Max-Age=" + X.maxAge;
    }
    if (X.domain) {
      if (!K3.test(X.domain))
        throw new TypeError(`option domain is invalid: ${X.domain}`);
      j += "; Domain=" + X.domain;
    }
    if (X.path) {
      if (!U3.test(X.path))
        throw new TypeError(`option path is invalid: ${X.path}`);
      j += "; Path=" + X.path;
    }
    if (X.expires) {
      if (!D3(X.expires) || !Number.isFinite(X.expires.valueOf()))
        throw new TypeError(`option expires is invalid: ${X.expires}`);
      j += "; Expires=" + X.expires.toUTCString();
    }
    if (X.httpOnly)
      j += "; HttpOnly";
    if (X.secure)
      j += "; Secure";
    if (X.partitioned)
      j += "; Partitioned";
    if (X.priority)
      switch (typeof X.priority === "string" ? X.priority.toLowerCase() : X.sameSite) {
        case "low":
          j += "; Priority=Low";
          break;
        case "medium":
          j += "; Priority=Medium";
          break;
        case "high":
          j += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${X.priority}`);
      }
    if (X.sameSite)
      switch (typeof X.sameSite === "string" ? X.sameSite.toLowerCase() : X.sameSite) {
        case true:
        case "strict":
          j += "; SameSite=Strict";
          break;
        case "lax":
          j += "; SameSite=Lax";
          break;
        case "none":
          j += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${X.sameSite}`);
      }
    return j;
  }
  function M3($) {
    if ($.indexOf("%") === -1)
      return $;
    try {
      return decodeURIComponent($);
    } catch (W) {
      return $;
    }
  }
  function D3($) {
    return w3.call($) === "[object Date]";
  }
});
var o0 = y1((D8, X2) => {
  var $2 = 12, I3 = 0, M1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7];
  function A3($) {
    var W = $.indexOf("%");
    if (W === -1)
      return $;
    var X = $.length, Z = "", J = 0, j = 0, Y = W, G = $2;
    while (W > -1 && W < X) {
      var K = W2($[W + 1], 4), B = W2($[W + 2], 0), U = K | B, w = M1[U];
      if (G = M1[256 + G + w], j = j << 6 | U & M1[364 + w], G === $2)
        Z += $.slice(J, Y), Z += j <= 65535 ? String.fromCharCode(j) : String.fromCharCode(55232 + (j >> 10), 56320 + (j & 1023)), j = 0, J = W + 3, W = Y = $.indexOf("%", J);
      else if (G === I3)
        return null;
      else {
        if (W += 3, W < X && $.charCodeAt(W) === 37)
          continue;
        return null;
      }
    }
    return Z + $.slice(J);
  }
  var O3 = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  function W2($, W) {
    var X = O3[$];
    return X === undefined ? 255 : X << W;
  }
  X2.exports = A3;
});
var T0 = ($, W) => {
  let X = W?.length ? {} : null;
  if (X)
    for (let Z of W)
      X[Z.part.charCodeAt(0)] = Z;
  return { part: $, store: null, inert: X, params: null, wildcardStore: null };
};
var k1 = ($, W) => ({ ...$, part: W });
var v1 = ($) => ({ name: $, store: null, inert: null });

class z0 {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g, optionalParams: /:.+?\?(?=\/|$)/g };
  add($, W, X, { ignoreError: Z = false, ignoreHistory: J = false } = {}) {
    if (typeof W !== "string")
      throw new TypeError("Route path must be a string");
    if (W === "")
      W = "/";
    else if (W[0] !== "/")
      W = `/${W}`;
    let j = W[W.length - 1] === "*", Y = W.match(z0.regex.optionalParams);
    if (Y) {
      let w = W.replaceAll("?", "");
      this.add($, w, X, { ignoreError: Z });
      for (let F = 0;F < Y.length; F++) {
        let Q = W.replace("/" + Y[F], "");
        this.add($, Q, X, { ignoreError: true });
      }
      return X;
    }
    if (Y)
      W = W.replaceAll("?", "");
    if (this.history.find(([w, F, Q]) => w === $ && F === W))
      return X;
    if (j || Y && W.charCodeAt(W.length - 1) === 63)
      W = W.slice(0, -1);
    if (!J)
      this.history.push([$, W, X]);
    let G = W.split(z0.regex.static), K = W.match(z0.regex.params) || [];
    if (G[G.length - 1] === "")
      G.pop();
    let B;
    if (!this.root[$])
      B = this.root[$] = T0("/");
    else
      B = this.root[$];
    let U = 0;
    for (let w = 0;w < G.length; ++w) {
      let F = G[w];
      if (w > 0) {
        let Q = K[U++].slice(1);
        if (B.params === null)
          B.params = v1(Q);
        else if (B.params.name !== Q)
          if (Z)
            return X;
          else
            throw new Error(`Cannot create route "${W}" with parameter "${Q}" because a route already exists with a different parameter name ("${B.params.name}") in the same location`);
        let M = B.params;
        if (M.inert === null) {
          B = M.inert = T0(F);
          continue;
        }
        B = M.inert;
      }
      for (let Q = 0;; ) {
        if (Q === F.length) {
          if (Q < B.part.length) {
            let M = k1(B, B.part.slice(Q));
            Object.assign(B, T0(F, [M]));
          }
          break;
        }
        if (Q === B.part.length) {
          if (B.inert === null)
            B.inert = {};
          let M = B.inert[F.charCodeAt(Q)];
          if (M) {
            B = M, F = F.slice(Q), Q = 0;
            continue;
          }
          let D = T0(F.slice(Q));
          B.inert[F.charCodeAt(Q)] = D, B = D;
          break;
        }
        if (F[Q] !== B.part[Q]) {
          let M = k1(B, B.part.slice(Q)), D = T0(F.slice(Q));
          Object.assign(B, T0(B.part.slice(0, Q), [M, D])), B = D;
          break;
        }
        ++Q;
      }
    }
    if (U < K.length) {
      let w = K[U].slice(1);
      if (B.params === null)
        B.params = v1(w);
      else if (B.params.name !== w)
        if (Z)
          return X;
        else
          throw new Error(`Cannot create route "${W}" with parameter "${w}" because a route already exists with a different parameter name ("${B.params.name}") in the same location`);
      if (B.params.store === null)
        B.params.store = X;
      return B.params.store;
    }
    if (j) {
      if (B.wildcardStore === null)
        B.wildcardStore = X;
      return B.wildcardStore;
    }
    if (B.store === null)
      B.store = X;
    return B.store;
  }
  find($, W) {
    let X = this.root[$];
    if (!X)
      return null;
    return U1(W, W.length, X, 0);
  }
}
var U1 = ($, W, X, Z) => {
  let J = X.part, j = J.length, Y = Z + j;
  if (j > 1) {
    if (Y > W)
      return null;
    if (j < 15) {
      for (let G = 1, K = Z + 1;G < j; ++G, ++K)
        if (J.charCodeAt(G) !== $.charCodeAt(K))
          return null;
    } else if ($.slice(Z, Y) !== J)
      return null;
  }
  if (Y === W) {
    if (X.store !== null)
      return { store: X.store, params: {} };
    if (X.wildcardStore !== null)
      return { store: X.wildcardStore, params: { "*": "" } };
    return null;
  }
  if (X.inert !== null) {
    let G = X.inert[$.charCodeAt(Y)];
    if (G !== undefined) {
      let K = U1($, W, G, Y);
      if (K !== null)
        return K;
    }
  }
  if (X.params !== null) {
    let { store: G, name: K, inert: B } = X.params, U = $.indexOf("/", Y);
    if (U !== Y) {
      if (U === -1 || U >= W) {
        if (G !== null) {
          let w = {};
          return w[K] = $.substring(Y, W), { store: G, params: w };
        }
      } else if (B !== null) {
        let w = U1($, W, B, U);
        if (w !== null)
          return w.params[K] = $.substring(Y, U), w;
      }
    }
  }
  if (X.wildcardStore !== null)
    return { store: X.wildcardStore, params: { "*": $.substring(Y, W) } };
  return null;
};
var E0 = ($) => {
  let W = typeof $ === "object" ? $.fn.toString() : typeof $ === "string" ? $.toString() : $, X = W.indexOf(")");
  if (W.charCodeAt(X + 2) === 61 && W.charCodeAt(X + 5) !== 123)
    return true;
  return W.includes("return");
};
var g2 = ($) => {
  if ($.startsWith("async"))
    $ = $.slice(5);
  $ = $.trimStart();
  let W = -1;
  if ($.charCodeAt(0) === 40) {
    if (W = $.indexOf("=>", $.indexOf(")")), W !== -1) {
      let J = W;
      while (J > 0)
        if ($.charCodeAt(--J) === 41)
          break;
      let j = $.slice(W + 2);
      if (j.charCodeAt(0) === 32)
        j = j.trimStart();
      return [$.slice(1, J), j, { isArrowReturn: j.charCodeAt(0) !== 123 }];
    }
  }
  if ($.startsWith("function")) {
    W = $.indexOf("(");
    let J = $.indexOf(")");
    return [$.slice(W + 1, J), $.slice(J + 2), { isArrowReturn: false }];
  }
  let X = $.indexOf("(");
  if (X !== -1) {
    let J = $.indexOf(`
`, 2), j = $.slice(0, J), Y = j.lastIndexOf(")") + 1, G = $.slice(J + 1);
    return [j.slice(X, Y), "{" + G, { isArrowReturn: false }];
  }
  let Z = $.split(`
`, 2);
  return [Z[0], Z[1], { isArrowReturn: false }];
};
var f2 = ($) => {
  let W = $.indexOf("{");
  if (W === -1)
    return [-1, 0];
  let X = W + 1, Z = 1;
  for (;X < $.length; X++) {
    let J = $.charCodeAt(X);
    if (J === 123)
      Z++;
    else if (J === 125)
      Z--;
    if (Z === 0)
      break;
  }
  if (Z !== 0)
    return [0, $.length];
  return [W, X + 1];
};
var y2 = ($) => {
  let W = $.lastIndexOf("}");
  if (W === -1)
    return [-1, 0];
  let X = W - 1, Z = 1;
  for (;X >= 0; X--) {
    let J = $.charCodeAt(X);
    if (J === 125)
      Z++;
    else if (J === 123)
      Z--;
    if (Z === 0)
      break;
  }
  if (Z !== 0)
    return [-1, 0];
  return [X, W + 1];
};
var u1 = ($) => {
  while (true) {
    let W = $.indexOf(":");
    if (W === -1)
      break;
    let X = $.indexOf(",", W);
    if (X === -1)
      X = $.indexOf("}", W) - 1;
    if (X === -2)
      X = $.length;
    $ = $.slice(0, W) + $.slice(X);
  }
  return $;
};
var h1 = ($) => {
  let W = false;
  if ($.charCodeAt(0) === 40)
    $ = $.slice(1, -1);
  if ($.charCodeAt(0) === 123)
    W = true, $ = $.slice(1, -1);
  $ = $.replace(/( |\t|\n)/g, "").trim();
  let X = [];
  while (true) {
    let [J, j] = f2($);
    if (J === -1)
      break;
    if (X.push($.slice(0, J - 1)), $.charCodeAt(j) === 44)
      j++;
    $ = $.slice(j);
  }
  if ($ = u1($), $)
    X = X.concat($.split(","));
  let Z = [];
  for (let J of X) {
    if (J.indexOf(",") === -1) {
      Z.push(J);
      continue;
    }
    for (let j of J.split(","))
      Z.push(j.trim());
  }
  return X = Z, { hasParenthesis: W, parameters: X };
};
var k2 = ($, W) => {
  let { parameters: X, hasParenthesis: Z } = h1($);
  if (!W.query && X.includes("query"))
    W.query = true;
  if (!W.headers && X.includes("headers"))
    W.headers = true;
  if (!W.body && X.includes("body"))
    W.body = true;
  if (!W.cookie && X.includes("cookie"))
    W.cookie = true;
  if (!W.set && X.includes("set"))
    W.set = true;
  if (!W.server && X.includes("server"))
    W.server = true;
  if (Z)
    return `{ ${X.join(", ")} }`;
  return X.join(", ");
};
var v2 = ($, W, X) => {
  let Z = W.indexOf($ + `
`, X), J = W.indexOf($ + "\t", X), j = W.indexOf($ + ",", X), Y = W.indexOf($ + ";", X), G = W.indexOf($ + " ", X);
  return [Z, J, j, Y, G].filter((K) => K > 0).sort((K, B) => K - B)[0] || -1;
};
var m1 = ($, W, X = 0) => {
  if (X > 5)
    return [];
  let Z = [], J = W;
  while (true) {
    let j = v2(" = " + $, J);
    if (j === -1) {
      let K = J.indexOf(" = " + $);
      if (K + 3 + $.length !== J.length)
        break;
      j = K;
    }
    let Y = J.slice(0, j), G = Y.slice(Y.lastIndexOf(" ") + 1);
    if (G === "}") {
      let [K, B] = y2(Y);
      Z.push(u1(J.slice(K, B))), J = J.slice(j + 3 + $.length);
      continue;
    }
    while (G.charCodeAt(0) === 44)
      G = G.slice(1);
    while (G.charCodeAt(0) === 9)
      G = G.slice(1);
    if (!G.includes("("))
      Z.push(G);
    J = J.slice(j + 3 + $.length);
  }
  for (let j of Z) {
    if (j.charCodeAt(0) === 123)
      continue;
    let Y = m1(j, W);
    if (Y.length > 0)
      Z.push(...Y);
  }
  return Z;
};
var u2 = ($) => {
  if (!$)
    return;
  if ($.charCodeAt(0) !== 123)
    return $;
  if ($ = $.slice(2, -2), !$.includes(",")) {
    if ($.includes("..."))
      return $.slice($.indexOf("...") + 3);
    return;
  }
  let X = $.indexOf("...");
  if (X === -1)
    return;
  return $.slice(X + 3).trimEnd();
};
var h2 = ($, W, X) => {
  let Z = (J, j) => $.includes(j + "." + J) || $.includes(j + '["' + J + '"]') || $.includes(j + "['" + J + "']");
  for (let J of W) {
    if (!J)
      continue;
    if (J.charCodeAt(0) === 123) {
      let j = h1(J).parameters;
      if (!X.query && j.includes("query"))
        X.query = true;
      if (!X.headers && j.includes("headers"))
        X.headers = true;
      if (!X.body && j.includes("body"))
        X.body = true;
      if (!X.cookie && j.includes("cookie"))
        X.cookie = true;
      if (!X.set && j.includes("set"))
        X.set = true;
      if (!X.query && j.includes("server"))
        X.server = true;
      continue;
    }
    if (!X.query && Z("query", J))
      X.query = true;
    if ($.includes("return " + J) || $.includes("return " + J + ".query"))
      X.query = true;
    if (!X.headers && Z("headers", J))
      X.headers = true;
    if (!X.body && Z("body", J))
      X.body = true;
    if (!X.cookie && Z("cookie", J))
      X.cookie = true;
    if (!X.set && Z("set", J))
      X.set = true;
    if (!X.server && Z("server", J))
      X.server = true;
    if (X.query && X.headers && X.body && X.cookie && X.set && X.server)
      break;
  }
  return W;
};
var m2 = ($, W, X) => {
  try {
    let Z = new RegExp(`(?:\\w)\\((?:.*)?${$}`, "gs");
    Z.test(W);
    let J = W.charCodeAt(Z.lastIndex);
    if (J === 41 || J === 44)
      return X.query = true, X.headers = true, X.body = true, X.cookie = true, X.set = true, X.server = true, true;
    return false;
  } catch (Z) {
    return console.log("[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:"), console.log("--- body ---"), console.log(W), console.log("--- context ---"), console.log($), true;
  }
};
var s0 = ($, W = { query: false, headers: false, body: false, cookie: false, set: false, server: false }) => {
  let X = [];
  if ($.handler && typeof $.handler === "function")
    X.push($.handler);
  if ($.request?.length)
    X.push(...$.request);
  if ($.beforeHandle?.length)
    X.push(...$.beforeHandle);
  if ($.parse?.length)
    X.push(...$.parse);
  if ($.error?.length)
    X.push(...$.error);
  if ($.transform?.length)
    X.push(...$.transform);
  if ($.afterHandle?.length)
    X.push(...$.afterHandle);
  if ($.mapResponse?.length)
    X.push(...$.mapResponse);
  if ($.afterResponse?.length)
    X.push(...$.afterResponse);
  for (let Z of X) {
    if (!Z)
      continue;
    let J = "fn" in Z ? Z.fn : Z, [j, Y, { isArrowReturn: G }] = g2(J.toString()), K = k2(j, W), B = u2(K);
    if (B) {
      let U = m1(B, Y);
      if (U.splice(0, -1, B), !m2(B, Y, W))
        h2(Y, U, W);
      if (!W.query && Y.includes("return " + B + ".query"))
        W.query = true;
    }
    if (W.query && W.headers && W.body && W.cookie && W.set && W.server)
      break;
  }
  return W;
};
var a0 = { date: p1, time: w1(true), "date-time": d1(true), "iso-time": w1(false), "iso-date-time": d1(false), duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/, uri: r2, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, regex: X3, uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/, "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, byte: s2, int32: { type: "number", validate: e2 }, int64: { type: "number", validate: $3 }, float: { type: "number", validate: l1 }, double: { type: "number", validate: l1 }, password: true, binary: true };
function d2($) {
  return $ % 4 === 0 && ($ % 100 !== 0 || $ % 400 === 0);
}
var c2 = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var l2 = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function p1($) {
  let W = c2.exec($);
  if (!W)
    return false;
  let X = +W[1], Z = +W[2], J = +W[3];
  return Z >= 1 && Z <= 12 && J >= 1 && J <= (Z === 2 && d2(X) ? 29 : l2[Z]);
}
var p2 = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
function w1($) {
  return function W(X) {
    let Z = p2.exec(X);
    if (!Z)
      return false;
    let J = +Z[1], j = +Z[2], Y = +Z[3], G = Z[4], K = Z[5] === "-" ? -1 : 1, B = +(Z[6] || 0), U = +(Z[7] || 0);
    if (B > 23 || U > 59 || $ && !G)
      return false;
    if (J <= 23 && j <= 59 && Y < 60)
      return true;
    let w = j - U * K, F = J - B * K - (w < 0 ? 1 : 0);
    return (F === 23 || F === -1) && (w === 59 || w === -1) && Y < 61;
  };
}
var i2 = /t|\s/i;
function d1($) {
  let W = w1($);
  return function X(Z) {
    let J = Z.split(i2);
    return J.length === 2 && p1(J[0]) && W(J[1]);
  };
}
var n2 = /\/|:/;
var t2 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function r2($) {
  return n2.test($) && t2.test($);
}
var c1 = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
function s2($) {
  return c1.lastIndex = 0, c1.test($);
}
var a2 = -2147483648;
var o2 = 2147483647;
function e2($) {
  return Number.isInteger($) && $ <= o2 && $ >= a2;
}
function $3($) {
  return Number.isInteger($);
}
function l1() {
  return true;
}
var W3 = /[^\\]\\Z/;
function X3($) {
  if (W3.test($))
    return false;
  try {
    return new RegExp($), true;
  } catch (W) {
    return false;
  }
}
var t1 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var r1 = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var s1 = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var J3 = a0.date;
var j3 = a0["date-time"];
if (!exports_format.Has("date"))
  TypeSystem.Format("date", ($) => {
    let W = $.replace(/"/g, "");
    if (t1.test(W) || r1.test(W) || s1.test(W) || J3(W)) {
      let X = new Date(W);
      if (!Number.isNaN(X.getTime()))
        return true;
    }
    return false;
  });
if (!exports_format.Has("date-time"))
  TypeSystem.Format("date-time", ($) => {
    let W = $.replace(/"/g, "");
    if (t1.test(W) || r1.test(W) || s1.test(W) || j3(W)) {
      let X = new Date(W);
      if (!Number.isNaN(X.getTime()))
        return true;
    }
    return false;
  });
Object.entries(a0).forEach(($) => {
  let [W, X] = $;
  if (!exports_format.Has(W)) {
    if (X instanceof RegExp)
      TypeSystem.Format(W, (Z) => X.test(Z));
    else if (typeof X === "function")
      TypeSystem.Format(W, X);
  }
});
var V = Object.assign({}, Type);
var n1 = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var _1 = ($, W) => {
  if (!(W instanceof Blob))
    return false;
  if ($.minSize && W.size < n1($.minSize))
    return false;
  if ($.maxSize && W.size > n1($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!W.type.startsWith($.extension))
        return false;
    } else {
      for (let X = 0;X < $.extension.length; X++)
        if (W.type.startsWith($.extension[X]))
          return true;
      return false;
    }
  return true;
};
var Q3 = exports_type.Get("Files") ?? TypeSystem.Type("File", _1);
var Y3 = exports_type.Get("Files") ?? TypeSystem.Type("Files", ($, W) => {
  if (!Array.isArray(W))
    return _1($, W);
  if ($.minItems && W.length < $.minItems)
    return false;
  if ($.maxItems && W.length > $.maxItems)
    return false;
  for (let X = 0;X < W.length; X++)
    if (!_1($, W[X]))
      return false;
  return true;
});
if (!exports_format.Has("numeric"))
  exports_format.Set("numeric", ($) => !!$ && !isNaN(+$));
if (!exports_format.Has("boolean"))
  exports_format.Set("boolean", ($) => $ === "true" || $ === "false");
if (!exports_format.Has("ObjectString"))
  exports_format.Set("ObjectString", ($) => {
    let W = $.charCodeAt(0);
    if (W === 9 || W === 10 || W === 32)
      W = $.trimStart().charCodeAt(0);
    if (W !== 123 && W !== 91)
      return false;
    try {
      return JSON.parse($), true;
    } catch {
      return false;
    }
  });
if (!exports_format.Has("ArrayString"))
  exports_format.Set("ArrayString", ($) => {
    let W = $.charCodeAt(0);
    if (W === 9 || W === 10 || W === 32)
      W = $.trimStart().charCodeAt(0);
    if (W !== 123 && W !== 91)
      return false;
    try {
      return JSON.parse($), true;
    } catch {
      return false;
    }
  });
exports_type.Set("UnionEnum", ($, W) => {
  return (typeof W === "number" || typeof W === "string" || W === null) && $.enum.includes(W);
});
var X0 = { Numeric: ($) => {
  let W = Type.Number($);
  return V.Transform(V.Union([V.String({ format: "numeric", default: 0 }), V.Number($)], $)).Decode((X) => {
    let Z = +X;
    if (isNaN(Z))
      return X;
    if ($ && !exports_value2.Check(W, Z))
      throw new q("property", W, Z);
    return Z;
  }).Encode((X) => X);
}, Date: ($) => {
  let W = Type.Date($);
  return V.Transform(V.Union([Type.Date($), V.String({ format: "date", default: new Date().toISOString() }), V.String({ format: "date-time", default: new Date().toISOString() })], $)).Decode((X) => {
    if (X instanceof Date)
      return X;
    let Z = new Date(X);
    if (!exports_value2.Check(W, Z))
      throw new q("property", W, Z);
    return Z;
  }).Encode((X) => {
    if (typeof X === "string")
      return new Date(X);
    return X;
  });
}, BooleanString: ($) => {
  let W = Type.Boolean($);
  return V.Transform(V.Union([V.String({ format: "boolean", default: false }), V.Boolean($)], $)).Decode((X) => {
    if (typeof X === "string")
      return X === "true";
    if ($ && !exports_value2.Check(W, X))
      throw new q("property", W, X);
    return X;
  }).Encode((X) => X);
}, ObjectString: ($, W) => {
  let X = V.Object($, W), Z = JSON.stringify(exports_value2.Create(X)), J;
  try {
    J = TypeCompiler.Compile(X);
  } catch {
  }
  return V.Transform(V.Union([V.String({ format: "ObjectString", default: Z }), X])).Decode((j) => {
    if (typeof j === "string") {
      if (j.charCodeAt(0) !== 123)
        throw new q("property", X, j);
      try {
        j = JSON.parse(j);
      } catch {
        throw new q("property", X, j);
      }
      if (J) {
        if (!J.Check(j))
          throw new q("property", X, j);
        return J.Decode(j);
      }
      if (!exports_value2.Check(X, j))
        throw new q("property", X, j);
      return exports_value2.Decode(X, j);
    }
    return j;
  }).Encode((j) => {
    if (typeof j === "string")
      try {
        j = JSON.parse(j);
      } catch {
        throw new q("property", X, j);
      }
    if (!exports_value2.Check(X, j))
      throw new q("property", X, j);
    return JSON.stringify(j);
  });
}, ArrayString: ($ = {}, W) => {
  let X = V.Array($, W), Z = JSON.stringify(exports_value2.Create(X)), J;
  try {
    J = TypeCompiler.Compile(X);
  } catch {
  }
  return V.Transform(V.Union([V.String({ format: "ArrayString", default: Z }), X])).Decode((j) => {
    if (typeof j === "string") {
      if (j.charCodeAt(0) !== 91)
        throw new q("property", X, j);
      try {
        j = JSON.parse(j);
      } catch {
        throw new q("property", X, j);
      }
      if (J) {
        if (!J.Check(j))
          throw new q("property", X, j);
        return J.Decode(j);
      }
      if (!exports_value2.Check(X, j))
        throw new q("property", X, j);
      return exports_value2.Decode(X, j);
    }
    return j;
  }).Encode((j) => {
    if (typeof j === "string")
      try {
        j = JSON.parse(j);
      } catch {
        throw new q("property", X, j);
      }
    if (!exports_value2.Check(X, j))
      throw new q("property", X, j);
    return JSON.stringify(j);
  });
}, File: Q3, Files: ($ = {}) => V.Transform(Y3($)).Decode((W) => {
  if (Array.isArray(W))
    return W;
  return [W];
}).Encode((W) => W), Nullable: ($) => V.Union([$, V.Null()]), MaybeEmpty: ($) => V.Union([$, V.Null(), V.Undefined()]), Cookie: ($, { domain: W, expires: X, httpOnly: Z, maxAge: J, path: j, priority: Y, sameSite: G, secure: K, secrets: B, sign: U, ...w } = {}) => {
  let F = V.Object($, w);
  return F.config = { domain: W, expires: X, httpOnly: Z, maxAge: J, path: j, priority: Y, sameSite: G, secure: K, secrets: B, sign: U }, F;
}, UnionEnum: ($, W = {}) => {
  let X = $.every((Z) => typeof Z === "string") ? { type: "string" } : $.every((Z) => typeof Z === "number") ? { type: "number" } : $.every((Z) => Z === null) ? { type: "null" } : {};
  if ($.some((Z) => typeof Z === "object" && Z !== null))
    throw new Error("This type does not support objects or arrays");
  return { default: $[0], ...W, [Kind]: "UnionEnum", ...X, enum: $ };
} };
V.BooleanString = X0.BooleanString;
V.ObjectString = X0.ObjectString;
V.ArrayString = X0.ArrayString;
V.Numeric = X0.Numeric;
V.File = ($ = {}) => X0.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
V.Files = ($ = {}) => X0.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
V.Nullable = ($) => X0.Nullable($);
V.MaybeEmpty = X0.MaybeEmpty;
V.Cookie = X0.Cookie;
V.Date = X0.Date;
V.UnionEnum = X0.UnionEnum;
var Q2 = k0(z1(), 1);
var J2 = k0(z1(), 1);
var j2 = k0(o0(), 1);

class w0 {
  $;
  W;
  X;
  constructor($, W, X = {}) {
    this.name = $;
    this.jar = W;
    this.initial = X;
  }
  get cookie() {
    return this.jar[this.name] ?? this.initial;
  }
  set cookie($) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name] = $;
  }
  get setCookie() {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    return this.jar[this.name];
  }
  set setCookie($) {
    this.cookie = $;
  }
  get value() {
    return this.cookie.value;
  }
  set value($) {
    this.setCookie.value = $;
  }
  get expires() {
    return this.cookie.expires;
  }
  set expires($) {
    this.setCookie.expires = $;
  }
  get maxAge() {
    return this.cookie.maxAge;
  }
  set maxAge($) {
    this.setCookie.maxAge = $;
  }
  get domain() {
    return this.cookie.domain;
  }
  set domain($) {
    this.setCookie.domain = $;
  }
  get path() {
    return this.cookie.path;
  }
  set path($) {
    this.setCookie.path = $;
  }
  get secure() {
    return this.cookie.secure;
  }
  set secure($) {
    this.setCookie.secure = $;
  }
  get httpOnly() {
    return this.cookie.httpOnly;
  }
  set httpOnly($) {
    this.setCookie.httpOnly = $;
  }
  get sameSite() {
    return this.cookie.sameSite;
  }
  set sameSite($) {
    this.setCookie.sameSite = $;
  }
  get priority() {
    return this.cookie.priority;
  }
  set priority($) {
    this.setCookie.priority = $;
  }
  get partitioned() {
    return this.cookie.partitioned;
  }
  set partitioned($) {
    this.setCookie.partitioned = $;
  }
  get secrets() {
    return this.cookie.secrets;
  }
  set secrets($) {
    this.setCookie.secrets = $;
  }
  update($) {
    return this.setCookie = Object.assign(this.cookie, typeof $ === "function" ? $(this.cookie) : $), this;
  }
  set($) {
    return this.setCookie = Object.assign({ ...this.initial, value: this.value }, typeof $ === "function" ? $(this.cookie) : $), this;
  }
  remove() {
    if (this.value === undefined)
      return;
    return this.set({ expires: new Date(0), maxAge: 0, value: "" }), this;
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
}
var Z2 = ($, W, X) => {
  if (!$.cookie)
    $.cookie = {};
  return new Proxy(W, { get(Z, J) {
    if (J in W)
      return new w0(J, $.cookie, Object.assign({}, X ?? {}, W[J]));
    return new w0(J, $.cookie, Object.assign({}, X));
  } });
};
var e0 = async ($, W, { secrets: X, sign: Z, ...J } = {}) => {
  if (!W)
    return Z2($, {}, J);
  let j = typeof X === "string";
  if (Z && Z !== true && !Array.isArray(Z))
    Z = [Z];
  let Y = {}, G = J2.parse(W);
  for (let [K, B] of Object.entries(G)) {
    let U = j2.default(B);
    if (Z === true || Z?.includes(K)) {
      if (!X)
        throw new Error("No secret is provided to cookie plugin");
      if (j) {
        let w = await D1(U, X);
        if (w === false)
          throw new u0(K);
        U = w;
      } else {
        let w = true;
        for (let F = 0;F < X.length; F++) {
          let Q = await D1(U, X[F]);
          if (Q !== false) {
            w = true, U = Q;
            break;
          }
        }
        if (!w)
          throw new u0(K);
      }
    }
    Y[K] = { value: U };
  }
  return Z2($, Y, J);
};
var Y2 = "toJSON" in new Headers;
var c = ($) => {
  if (!$)
    return false;
  for (let W in $)
    return true;
  return false;
};
var h0 = ($, W) => {
  let X = $.size;
  if (!W && X || X && W && W.status !== 206 && W.status !== 304 && W.status !== 412 && W.status !== 416) {
    if (W && c(W.headers)) {
      if (W.headers instanceof Headers) {
        if (Y2)
          W.headers = W.headers.toJSON();
        else
          for (let [Z, J] of W.headers.entries())
            if (Z in W.headers)
              W.headers[Z] = J;
      }
      return new Response($, { status: W.status, headers: Object.assign({ "accept-ranges": "bytes", "content-range": `bytes 0-${X - 1}/${X}` }, W.headers) });
    }
    return new Response($, { headers: { "accept-ranges": "bytes", "content-range": `bytes 0-${X - 1}/${X}`, "transfer-encoding": "chunked" } });
  }
  return new Response($);
};
var G2 = ($, W) => {
  if (!$)
    return $;
  $.delete("set-cookie");
  for (let X = 0;X < W.length; X++) {
    let Z = W[X].indexOf("=");
    $.append("set-cookie", `${W[X].slice(0, Z)}=${W[X].slice(Z + 1) || ""}`);
  }
  return $;
};
var B2 = ($) => {
  if (!$ || !c($))
    return;
  let W = [];
  for (let [X, Z] of Object.entries($)) {
    if (!X || !Z)
      continue;
    let J = Z.value;
    if (J === undefined || J === null)
      continue;
    W.push(Q2.serialize(X, typeof J === "object" ? JSON.stringify(J) : J + "", Z));
  }
  if (W.length === 0)
    return;
  if (W.length === 1)
    return W[0];
  return W;
};
var B0 = async ($, W, X) => {
  let Z = $.next();
  if (Z instanceof Promise)
    Z = await Z;
  if (Z.done) {
    if (W)
      return x(Z.value, W, X);
    return Z0(Z.value, X);
  }
  return new Response(new ReadableStream({ async start(J) {
    let j = false;
    if (X?.signal.addEventListener("abort", () => {
      j = true;
      try {
        J.close();
      } catch {
      }
    }), Z.value !== undefined && Z.value !== null)
      if (typeof Z.value === "object")
        try {
          J.enqueue(Buffer.from(JSON.stringify(Z.value)));
        } catch {
          J.enqueue(Buffer.from(Z.value.toString()));
        }
      else
        J.enqueue(Buffer.from(Z.value.toString()));
    for await (let Y of $) {
      if (j)
        break;
      if (Y === undefined || Y === null)
        continue;
      if (typeof Y === "object")
        try {
          J.enqueue(Buffer.from(JSON.stringify(Y)));
        } catch {
          J.enqueue(Buffer.from(Y.toString()));
        }
      else
        J.enqueue(Buffer.from(Y.toString()));
      await new Promise((G) => setTimeout(() => G(), 0));
    }
    try {
      J.close();
    } catch {
    }
  } }), { ...W, headers: { "transfer-encoding": "chunked", "content-type": "text/event-stream; charset=utf-8", ...W?.headers } });
};
async function* m0($) {
  let W = $.body;
  if (!W)
    return;
  let X = W.getReader(), Z = new TextDecoder;
  try {
    while (true) {
      let { done: J, value: j } = await X.read();
      if (J)
        break;
      yield Z.decode(j);
    }
  } finally {
    X.releaseLock();
  }
}
var x = ($, W, X) => {
  if (c(W.headers) || W.status !== 200 || W.redirect || W.cookie) {
    if (typeof W.status === "string")
      W.status = _0[W.status];
    if (W.redirect) {
      if (W.headers.Location = W.redirect, !W.status || W.status < 300 || W.status >= 400)
        W.status = 302;
    }
    if (W.cookie && c(W.cookie)) {
      let Z = B2(W.cookie);
      if (Z)
        W.headers["set-cookie"] = Z;
    }
    if (W.headers["set-cookie"] && Array.isArray(W.headers["set-cookie"]))
      W.headers = G2(new Headers(W.headers), W.headers["set-cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, W);
      case "Blob":
        return h0($, W);
      case "Array":
        return Response.json($, W);
      case "Object":
        return Response.json($, W);
      case "ElysiaCustomStatusResponse":
        return W.status = $.code, x($.response, W, X);
      case "ReadableStream":
        if (!W.headers["content-type"]?.startsWith("text/event-stream"))
          W.headers["content-type"] = "text/event-stream; charset=utf-8";
        return X?.signal.addEventListener("abort", { handleEvent() {
          if (!X?.signal.aborted)
            $.cancel(X);
        } }, { once: true }), new Response($, W);
      case undefined:
        if (!$)
          return new Response("", W);
        return Response.json($, W);
      case "Response":
        let Z = false;
        if (W.headers instanceof Headers)
          for (let J of W.headers.keys())
            if (J === "set-cookie") {
              if (Z)
                continue;
              Z = true;
              for (let j of W.headers.getSetCookie())
                $.headers.append("set-cookie", j);
            } else
              $.headers.append(J, W.headers?.get(J) ?? "");
        else
          for (let J in W.headers)
            $.headers.append(J, W.headers[J]);
        if ($.status !== W.status)
          W.status = $.status;
        if ($.headers.get("transfer-encoding") === "chunked")
          return B0(m0($), W, X);
        return $;
      case "Error":
        return K0($, W);
      case "Promise":
        return $.then((J) => x(J, W));
      case "Function":
        return x($(), W);
      case "Number":
      case "Boolean":
        return new Response($.toString(), W);
      case "Cookie":
        if ($ instanceof w0)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      case "FormData":
        return new Response($, W);
      default:
        if ($ instanceof Response) {
          let J = false;
          if (W.headers instanceof Headers)
            for (let j of W.headers.keys())
              if (j === "set-cookie") {
                if (J)
                  continue;
                J = true;
                for (let Y of W.headers.getSetCookie())
                  $.headers.append("set-cookie", Y);
              } else
                $.headers.append(j, W.headers?.get(j) ?? "");
          else
            for (let j in W.headers)
              $.headers.append(j, W.headers[j]);
          if (Y2)
            W.headers = $.headers.toJSON();
          else
            for (let [j, Y] of $.headers.entries())
              if (j in W.headers)
                W.headers[j] = Y;
          return $;
        }
        if ($ instanceof Promise)
          return $.then((J) => x(J, W));
        if ($ instanceof Error)
          return K0($, W);
        if ($ instanceof l)
          return W.status = $.code, x($.response, W, X);
        if (typeof $?.next === "function")
          return B0($, W, X);
        if (typeof $?.then === "function")
          return $.then((J) => x(J, W));
        if (typeof $?.toResponse === "function")
          return x($.toResponse(), W);
        if ("charCodeAt" in $) {
          let J = $.charCodeAt(0);
          if (J === 123 || J === 91) {
            if (!W.headers["Content-Type"])
              W.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify($), W);
          }
        }
        return new Response($, W);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return h0($, W);
      case "Array":
        return Response.json($);
      case "Object":
        return Response.json($, W);
      case "ElysiaCustomStatusResponse":
        return W.status = $.code, x($.response, W, X);
      case "ReadableStream":
        return X?.signal.addEventListener("abort", { handleEvent() {
          if (!X?.signal.aborted)
            $.cancel(X);
        } }, { once: true }), new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        if ($.headers.get("transfer-encoding") === "chunked")
          return B0(m0($), W, X);
        return $;
      case "Error":
        return K0($, W);
      case "Promise":
        return $.then((Z) => {
          let J = Z0(Z, X);
          if (J !== undefined)
            return J;
          return new Response("");
        });
      case "Function":
        return Z0($(), X);
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof w0)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      case "FormData":
        return new Response($, W);
      default:
        if ($ instanceof Response)
          return $;
        if ($ instanceof Promise)
          return $.then((Z) => x(Z, W));
        if ($ instanceof Error)
          return K0($, W);
        if ($ instanceof l)
          return W.status = $.code, x($.response, W, X);
        if (typeof $?.next === "function")
          return B0($, W, X);
        if (typeof $?.then === "function")
          return $.then((Z) => x(Z, W));
        if (typeof $?.toResponse === "function")
          return x($.toResponse(), W);
        if ("charCodeAt" in $) {
          let Z = $.charCodeAt(0);
          if (Z === 123 || Z === 91) {
            if (!W.headers["Content-Type"])
              W.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify($), W);
          }
        }
        return new Response($);
    }
};
var g = ($, W, X) => {
  if ($ === undefined || $ === null)
    return;
  if (c(W.headers) || W.status !== 200 || W.redirect || W.cookie) {
    if (typeof W.status === "string")
      W.status = _0[W.status];
    if (W.redirect) {
      if (W.headers.Location = W.redirect, !W.status || W.status < 300 || W.status >= 400)
        W.status = 302;
    }
    if (W.cookie && c(W.cookie)) {
      let Z = B2(W.cookie);
      if (Z)
        W.headers["set-cookie"] = Z;
    }
    if (W.headers["set-cookie"] && Array.isArray(W.headers["set-cookie"]))
      W.headers = G2(new Headers(W.headers), W.headers["set-cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, W);
      case "Blob":
        return h0($, W);
      case "Array":
        return Response.json($, W);
      case "Object":
        return Response.json($, W);
      case "ElysiaCustomStatusResponse":
        return W.status = $.code, g($.response, W, X);
      case "ReadableStream":
        if (!W.headers["content-type"]?.startsWith("text/event-stream"))
          W.headers["content-type"] = "text/event-stream; charset=utf-8";
        return X?.signal.addEventListener("abort", { handleEvent() {
          if (!X?.signal.aborted)
            $.cancel(X);
        } }, { once: true }), new Response($, W);
      case undefined:
        if (!$)
          return;
        return Response.json($, W);
      case "Response":
        let Z = false;
        if (W.headers instanceof Headers)
          for (let J of W.headers.keys())
            if (J === "set-cookie") {
              if (Z)
                continue;
              Z = true;
              for (let j of W.headers.getSetCookie())
                $.headers.append("set-cookie", j);
            } else
              $.headers.append(J, W.headers?.get(J) ?? "");
        else
          for (let J in W.headers)
            $.headers.append(J, W.headers[J]);
        if ($.status !== W.status)
          W.status = $.status;
        if ($.headers.get("transfer-encoding") === "chunked")
          return B0(m0($), W, X);
        return $;
      case "Promise":
        return $.then((J) => {
          let j = g(J, W);
          if (j !== undefined)
            return j;
        });
      case "Error":
        return K0($, W);
      case "Function":
        return g($(), W);
      case "Number":
      case "Boolean":
        return new Response($.toString(), W);
      case "FormData":
        return new Response($);
      case "Cookie":
        if ($ instanceof w0)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      default:
        if ($ instanceof Response) {
          let J = false;
          if (W.headers instanceof Headers)
            for (let j of W.headers.keys())
              if (j === "set-cookie") {
                if (J)
                  continue;
                J = true;
                for (let Y of W.headers.getSetCookie())
                  $.headers.append("set-cookie", Y);
              } else
                $.headers.append(j, W.headers?.get(j) ?? "");
          else
            for (let j in W.headers)
              $.headers.append(j, W.headers[j]);
          if ($.status !== W.status)
            W.status = $.status;
          return $;
        }
        if ($ instanceof Promise)
          return $.then((J) => g(J, W));
        if ($ instanceof Error)
          return K0($, W);
        if ($ instanceof l)
          return W.status = $.code, g($.response, W, X);
        if (typeof $?.next === "function")
          return B0($, W, X);
        if (typeof $?.then === "function")
          return $.then((J) => g(J, W));
        if (typeof $?.toResponse === "function")
          return g($.toResponse(), W);
        if ("charCodeAt" in $) {
          let J = $.charCodeAt(0);
          if (J === 123 || J === 91) {
            if (!W.headers["Content-Type"])
              W.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify($), W);
          }
        }
        return new Response($, W);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return h0($, W);
      case "Array":
        return Response.json($);
      case "Object":
        return Response.json($, W);
      case "ElysiaCustomStatusResponse":
        return W.status = $.code, g($.response, W, X);
      case "ReadableStream":
        return X?.signal.addEventListener("abort", { handleEvent() {
          if (!X?.signal.aborted)
            $.cancel(X);
        } }, { once: true }), new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        if ($.headers.get("transfer-encoding") === "chunked")
          return B0(m0($));
        return $;
      case "Promise":
        return $.then((Z) => {
          let J = g(Z, W);
          if (J !== undefined)
            return J;
        });
      case "Error":
        return K0($, W);
      case "Function":
        return Z0($(), X);
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof w0)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      case "FormData":
        return new Response($);
      default:
        if ($ instanceof Response)
          return $;
        if ($ instanceof Promise)
          return $.then((Z) => g(Z, W));
        if ($ instanceof Error)
          return K0($, W);
        if ($ instanceof l)
          return W.status = $.code, g($.response, W, X);
        if (typeof $?.next === "function")
          return B0($, W, X);
        if (typeof $?.then === "function")
          return $.then((Z) => g(Z, W));
        if (typeof $?.toResponse === "function")
          return g($.toResponse(), W);
        if ("charCodeAt" in $) {
          let Z = $.charCodeAt(0);
          if (Z === 123 || Z === 91) {
            if (!W.headers["Content-Type"])
              W.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify($), W);
          }
        }
        return new Response($);
    }
};
var Z0 = ($, W) => {
  switch ($?.constructor?.name) {
    case "String":
      return new Response($);
    case "Blob":
      return h0($);
    case "Array":
      return Response.json($);
    case "Object":
      return Response.json($);
    case "ElysiaCustomStatusResponse":
      return x($.response, { status: $.code, headers: {} });
    case "ReadableStream":
      return W?.signal.addEventListener("abort", { handleEvent() {
        if (!W?.signal.aborted)
          $.cancel(W);
      } }, { once: true }), new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      if ($.headers.get("transfer-encoding") === "chunked")
        return B0(m0($));
      return $;
    case "Error":
      return K0($);
    case "Promise":
      return $.then((X) => Z0(X, W));
    case "Function":
      return Z0($(), W);
    case "Number":
    case "Boolean":
      return new Response($.toString());
    case "FormData":
      return new Response($);
    default:
      if ($ instanceof Response)
        return $;
      if ($ instanceof Promise)
        return $.then((X) => Z0(X, W));
      if ($ instanceof Error)
        return K0($);
      if ($ instanceof l)
        return x($.response, { status: $.code, headers: {} });
      if (typeof $?.next === "function")
        return B0($, undefined, W);
      if (typeof $?.then === "function")
        return $.then((X) => x(X, set));
      if (typeof $?.toResponse === "function")
        return Z0($.toResponse());
      if ("charCodeAt" in $) {
        let X = $.charCodeAt(0);
        if (X === 123 || X === 91)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      }
      return new Response($);
  }
};
var K0 = ($, W) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: W?.status !== 200 ? W?.status ?? 500 : 500, headers: W?.headers });
var K2 = ($, W, X = {}) => {
  if (typeof $ === "function")
    return;
  let Z = x($, { headers: X });
  if (W.parse.length === 0 && W.transform.length === 0 && W.beforeHandle.length === 0 && W.afterHandle.length === 0)
    return Z.clone.bind(Z);
};
var U2 = ($, W, X = {}) => {
  if (typeof $ === "function" || $ instanceof Blob)
    return;
  let Z = x($, { headers: X });
  if (W.parse.length === 0 && W.transform.length === 0 && W.beforeHandle.length === 0 && W.afterHandle.length === 0) {
    if (!Z.headers.has("content-type"))
      Z.headers.append("content-type", "text/plain;charset=utf-8");
    return Z.clone.bind(Z);
  }
};
var R0 = ($, W) => {
  let X = new URL($);
  return X.pathname = W, X.toString();
};
var V3 = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString().startsWith("[object ") && $.toString() !== "[object Object]" || c(Object.getPrototypeOf($));
var N1 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var d = ($, W, { skipKeys: X, override: Z = true } = {}) => {
  if (!N1($) || !N1(W))
    return $;
  for (let [J, j] of Object.entries(W)) {
    if (X?.includes(J))
      continue;
    if (!N1(j) || !(J in $) || V3(j)) {
      if (Z || !(J in $))
        $[J] = j;
      continue;
    }
    $[J] = d($[J], j, { skipKeys: X, override: Z });
  }
  return $;
};
var S3 = ($, W) => {
  let { properties: X, ...Z } = $ ?? {}, { properties: J, ...j } = W ?? {};
  return d(Z, j);
};
var y = ($ = [], W = []) => {
  if (!$)
    return [];
  if (!W)
    return $;
  let X = [], Z = [];
  if (!Array.isArray($))
    $ = [$];
  if (!Array.isArray(W))
    W = [W];
  for (let J of $)
    if (X.push(J), J.checksum)
      Z.push(J.checksum);
  for (let J of W)
    if (!Z.includes(J.checksum))
      X.push(J);
  return X;
};
var C3 = ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "mapResponse", "afterResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
var L3 = C3.reduce(($, W) => ($[W] = true, $), {});
var z2 = ($, W) => {
  let X = (Z) => typeof Z === "object" && Object.keys(Z).every(Z1);
  if (X($) && X(W))
    return { ...$, ...W };
  else if ($ && !X($) && X(W))
    return { 200: $, ...W };
  return W ?? $;
};
var b0 = ($, W) => {
  return { body: W?.body ?? $?.body, headers: W?.headers ?? $?.headers, params: W?.params ?? $?.params, query: W?.query ?? $?.query, cookie: W?.cookie ?? $?.cookie, response: z2($?.response, W?.response) };
};
var i = ($, W) => {
  return { ...$, ...W, body: W?.body ?? $?.body, headers: W?.headers ?? $?.headers, params: W?.params ?? $?.params, query: W?.query ?? $?.query, cookie: W?.cookie ?? $?.cookie, response: z2($?.response, W?.response), type: $?.type || W?.type, detail: d(W?.detail ?? {}, $?.detail ?? {}), parse: y($?.parse, W?.parse), transform: y($?.transform, W?.transform), beforeHandle: y($?.beforeHandle, W?.beforeHandle), afterHandle: y($?.afterHandle, W?.afterHandle), mapResponse: y($?.mapResponse, W?.mapResponse), afterResponse: y($?.afterResponse, W?.afterResponse), trace: y($?.trace, W?.trace), error: y($?.error, W?.error) };
};
var A1 = ($, W, X = true) => {
  if (!Array.isArray(W))
    return h($, W, X);
  for (let Z of W)
    $ = h($, Z, X);
  return $;
};
var h = ($, W, X = true) => {
  if (!$)
    return $;
  if (W.untilObjectFound && !X && $.type === "object")
    return $;
  let Z = W.from[Kind];
  if ($.oneOf) {
    for (let Y = 0;Y < $.oneOf.length; Y++)
      $.oneOf[Y] = h($.oneOf[Y], W, X);
    return $;
  }
  if ($.anyOf) {
    for (let Y = 0;Y < $.anyOf.length; Y++)
      $.anyOf[Y] = h($.anyOf[Y], W, X);
    return $;
  }
  if ($.allOf) {
    for (let Y = 0;Y < $.allOf.length; Y++)
      $.allOf[Y] = h($.allOf[Y], W, X);
    return $;
  }
  if ($.not) {
    for (let Y = 0;Y < $.not.length; Y++)
      $.not[Y] = h($.not[Y], W, X);
    return $;
  }
  let J = X && !!W.excludeRoot;
  if ($[Kind] === Z) {
    let { anyOf: Y, oneOf: G, allOf: K, not: B, properties: U, items: w, ...F } = $, Q = W.to(F), M, D = (z) => {
      if (U && z.type === "object") {
        let O = {};
        for (let [P, b] of Object.entries(U))
          O[P] = h(b, W, false);
        return { ...F, ...z, properties: O };
      }
      if (w && z.type === "array")
        return { ...F, ...z, items: h(w, W, false) };
      let I = { ...F, ...z };
      if (delete I.required, U && z.type === "string" && z.format === "ObjectString" && z.default === "{}")
        M = V.ObjectString(U, F), I.default = JSON.stringify(exports_value2.Create(V.Object(U))), I.properties = U;
      if (w && z.type === "string" && z.format === "ArrayString" && z.default === "[]")
        M = V.ArrayString(w, F), I.default = JSON.stringify(exports_value2.Create(V.Array(w))), I.items = w;
      return I;
    };
    if (J) {
      if (U) {
        let z = {};
        for (let [I, O] of Object.entries(U))
          z[I] = h(O, W, false);
        return { ...F, properties: z };
      } else if (w?.map)
        return { ...F, items: w.map((z) => h(z, W, false)) };
      return F;
    }
    if (Q.anyOf)
      for (let z = 0;z < Q.anyOf.length; z++)
        Q.anyOf[z] = D(Q.anyOf[z]);
    else if (Q.oneOf)
      for (let z = 0;z < Q.oneOf.length; z++)
        Q.oneOf[z] = D(Q.oneOf[z]);
    else if (Q.allOf)
      for (let z = 0;z < Q.allOf.length; z++)
        Q.allOf[z] = D(Q.allOf[z]);
    else if (Q.not)
      for (let z = 0;z < Q.not.length; z++)
        Q.not[z] = D(Q.not[z]);
    if (M)
      Q[TransformKind] = M[TransformKind];
    if (Q.anyOf || Q.oneOf || Q.allOf || Q.not)
      return Q;
    if (U) {
      let z = {};
      for (let [I, O] of Object.entries(U))
        z[I] = h(O, W, false);
      return { ...F, ...Q, properties: z };
    } else if (w?.map)
      return { ...F, ...Q, items: w.map((z) => h(z, W, false)) };
    return { ...F, ...Q };
  }
  let j = $?.properties;
  if (j && X && W.rootOnly !== true)
    for (let [Y, G] of Object.entries(j))
      switch (G[Kind]) {
        case Z:
          let { anyOf: K, oneOf: B, allOf: U, not: w, type: F, ...Q } = G, M = W.to(Q);
          if (M.anyOf)
            for (let D = 0;D < M.anyOf.length; D++)
              M.anyOf[D] = { ...Q, ...M.anyOf[D] };
          else if (M.oneOf)
            for (let D = 0;D < M.oneOf.length; D++)
              M.oneOf[D] = { ...Q, ...M.oneOf[D] };
          else if (M.allOf)
            for (let D = 0;D < M.allOf.length; D++)
              M.allOf[D] = { ...Q, ...M.allOf[D] };
          else if (M.not)
            for (let D = 0;D < M.not.length; D++)
              M.not[D] = { ...Q, ...M.not[D] };
          j[Y] = { ...Q, ...h(Q, W, false) };
          break;
        case "Object":
        case "Union":
          j[Y] = h(G, W, false);
          break;
        default:
          if (G.items)
            for (let D = 0;D < G.items.length; D++)
              G.items[D] = h(G.items[D], W, false);
          else if (G.anyOf || G.oneOf || G.allOf || G.not)
            j[Y] = h(G, W, false);
          break;
      }
  return $;
};
var m = ($, { models: W = {}, dynamic: X = false, normalize: Z = false, additionalProperties: J = false, coerce: j = false, additionalCoerce: Y = [] } = {}) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in W))
    return;
  let G = typeof $ === "string" ? W[$] : $;
  if (j || Y)
    if (j)
      G = A1(G, [{ from: V.Number(), to: (U) => V.Numeric(U), untilObjectFound: true }, { from: V.Boolean(), to: (U) => V.BooleanString(U), untilObjectFound: true }, ...Array.isArray(Y) ? Y : [Y]]);
    else
      G = A1(G, [...Array.isArray(Y) ? Y : [Y]]);
  if (G.type === "object" && "additionalProperties" in G === false)
    G.additionalProperties = J;
  let K = (U) => exports_value2.Clean(G, U);
  if (X) {
    let U = { schema: G, references: "", checkFunc: () => {
    }, code: "", Check: (w) => exports_value2.Check(G, w), Errors: (w) => exports_value2.Errors(G, w), Code: () => "", Clean: K, Decode: (w) => exports_value2.Decode(G, w), Encode: (w) => exports_value2.Encode(G, w) };
    if (Z && G.additionalProperties === false)
      U.Clean = K;
    if (G.config) {
      if (U.config = G.config, U?.schema?.config)
        delete U.schema.config;
    }
    return U.parse = (w) => {
      try {
        return U.Decode(w);
      } catch (F) {
        throw [...U.Errors(w)].map(o);
      }
    }, U.safeParse = (w) => {
      try {
        return { success: true, data: U.Decode(w), error: null };
      } catch (F) {
        let Q = [...B.Errors(w)].map(o);
        return { success: false, data: null, error: Q[0]?.summary, errors: Q };
      }
    }, U;
  }
  let B = TypeCompiler.Compile(G, Object.values(W));
  if (B.Clean = K, G.config) {
    if (B.config = G.config, B?.schema?.config)
      delete B.schema.config;
  }
  return B.parse = (U) => {
    try {
      return B.Decode(U);
    } catch (w) {
      throw [...B.Errors(U)].map(o);
    }
  }, B.safeParse = (U) => {
    try {
      return { success: true, data: B.Decode(U), error: null };
    } catch (w) {
      let F = [...B.Errors(U)].map(o);
      return { success: false, data: null, error: F[0]?.summary, errors: F };
    }
  }, B;
};
var $1 = ($, { models: W = {}, dynamic: X = false, normalize: Z = false, additionalProperties: J = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in W))
    return;
  let j = typeof $ === "string" ? W[$] : $, Y = (K, B) => {
    let U = (F) => {
      if (!F || typeof F !== "object")
        return exports_value2.Clean(K, F);
      if (Array.isArray(F))
        F = exports_value2.Clean(K, F);
      else
        F = exports_value2.Clean(K, F);
      return F;
    };
    if (X)
      return { schema: K, references: "", checkFunc: () => {
      }, code: "", Check: (F) => exports_value2.Check(K, F), Errors: (F) => exports_value2.Errors(K, F), Code: () => "", Decode: (F) => exports_value2.Decode(K, F), Encode: (F) => exports_value2.Encode(K, F) };
    let w = TypeCompiler.Compile(K, B);
    if (Z && K.additionalProperties === false)
      w.Clean = U;
    return w;
  };
  if (Kind in j) {
    if ("additionalProperties" in j === false)
      j.additionalProperties = J;
    return { 200: Y(j, Object.values(W)) };
  }
  let G = {};
  return Object.keys(j).forEach((K) => {
    let B = j[+K];
    if (typeof B === "string") {
      if (B in W) {
        let U = W[B];
        U.type === "object" && "additionalProperties" in U, G[+K] = Kind in U ? Y(U, Object.values(W)) : U;
      }
      return;
    }
    if (B.type === "object" && "additionalProperties" in B === false)
      B.additionalProperties = J;
    G[+K] = Kind in B ? Y(B, Object.values(W)) : B;
  }), G;
};
var T3 = typeof Bun !== "undefined";
var E3 = T3 && typeof Bun.hash === "function";
var N0 = ($) => {
  if (E3)
    return Bun.hash($);
  let W = 9;
  for (let X = 0;X < $.length; )
    W = Math.imul(W ^ $.charCodeAt(X++), 387420489);
  return W = W ^ W >>> 9;
};
var P1;
var D0 = () => {
  if (!P1)
    P1 = [{ from: V.Object({}), to: () => V.ObjectString({}), excludeRoot: true }, { from: V.Array(V.Any()), to: () => V.ArrayString(V.Any()) }];
  return P1;
};
var I1;
var O1 = () => {
  if (!I1)
    I1 = [{ from: V.Number(), to: ($) => V.Numeric($), rootOnly: true }, { from: V.Boolean(), to: ($) => V.BooleanString($), rootOnly: true }];
  return I1;
};
var W1 = ({ validator: $, defaultConfig: W = {}, config: X, dynamic: Z, models: J }) => {
  let j = m($, { dynamic: Z, models: J, additionalProperties: true, coerce: true, additionalCoerce: D0() });
  if (c(W))
    if (j)
      j.config = S3(j.config, X);
    else
      j = m(V.Cookie({}), { dynamic: Z, models: J, additionalProperties: true }), j.config = W;
  return j;
};
var J0 = ($, W) => {
  if (!W)
    return;
  if (!Array.isArray(W)) {
    let Z = W;
    if ($ && !Z.checksum)
      Z.checksum = $;
    if (Z.scope === "scoped")
      Z.scope = "local";
    return Z;
  }
  let X = [...W];
  for (let Z of X) {
    if ($ && !Z.checksum)
      Z.checksum = $;
    if (Z.scope === "scoped")
      Z.scope = "local";
  }
  return X;
};
var V1 = ($, W, X) => {
  return { start: y($.start, J0(X, W?.start)), request: y($.request, J0(X, W?.request)), parse: y($.parse, J0(X, W?.parse)), transform: y($.transform, J0(X, W?.transform)), beforeHandle: y($.beforeHandle, J0(X, W?.beforeHandle)), afterHandle: y($.afterHandle, J0(X, W?.afterHandle)), mapResponse: y($.mapResponse, J0(X, W?.mapResponse)), afterResponse: y($.afterResponse, J0(X, W?.afterResponse)), trace: y($.trace, J0(X, W?.trace)), error: y($.error, J0(X, W?.error)), stop: y($.stop, J0(X, W?.stop)) };
};
var M2 = ($, W, { skipIfHasType: X = false } = {}) => {
  if (!$)
    return $;
  if (!Array.isArray($)) {
    if (X)
      $.scope ??= W;
    else
      $.scope = W;
    return $;
  }
  for (let Z of $)
    if (X)
      Z.scope ??= W;
    else
      Z.scope = W;
  return $;
};
var M0 = ($) => {
  if (!$)
    return $;
  if (!Array.isArray($))
    switch ($.scope) {
      case "global":
      case "scoped":
        return { ...$ };
      default:
        return { fn: $ };
    }
  let W = [];
  for (let X of $)
    switch (X.scope) {
      case "global":
      case "scoped":
        W.push({ ...X });
        break;
    }
  return W;
};
var S1 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: M0($?.parse), transform: M0($?.transform), beforeHandle: M0($?.beforeHandle), afterHandle: M0($?.afterHandle), mapResponse: M0($?.mapResponse), afterResponse: M0($?.afterResponse), error: M0($?.error), trace: M0($?.trace) };
};
var _0 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var X1 = Object.fromEntries(Object.entries(_0).map(([$, W]) => [W, $]));
function q3($) {
  let W = $;
  while (W.endsWith("="))
    W = W.slice(0, -1);
  return W;
}
var _2 = new TextEncoder;
var x0 = async ($, W) => {
  if (typeof $ !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (W === null)
    throw new TypeError("Secret key must be provided.");
  let X = await crypto.subtle.importKey("raw", _2.encode(W), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), Z = await crypto.subtle.sign("HMAC", X, _2.encode($));
  return $ + "." + q3(Buffer.from(Z).toString("base64"));
};
var D1 = async ($, W) => {
  if (typeof $ !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (W === null)
    throw new TypeError("Secret key must be provided.");
  let X = $.slice(0, $.lastIndexOf("."));
  return await x0(X, W) === $ ? X : false;
};
var D2 = ($, W) => {
  if (!$ || typeof $ !== "object" || !W)
    return;
  for (let [X, Z] of Object.entries(W)) {
    if (X in L3 || !(X in $))
      continue;
    let J = $[X];
    if (typeof J === "function")
      J(Z), delete W[X];
  }
};
var N2 = ({ globalHook: $, localHook: W }) => (X) => (Z, J) => {
  if (typeof Z === "function")
    Z = { fn: Z };
  if ("fn" in Z || Array.isArray(Z)) {
    if (!W[X])
      W[X] = [];
    if (typeof W[X] === "function")
      W[X] = [W[X]];
    if (Array.isArray(Z))
      W[X] = W[X].concat(Z);
    else
      W[X].push(Z);
    return;
  }
  let { insert: j = "after", stack: Y = "local" } = Z;
  if (typeof J === "function")
    J = { fn: J };
  if (Y === "global")
    if (!Array.isArray(J))
      if (j === "before")
        $[X].unshift(J);
      else
        $[X].push(J);
    else if (j === "before")
      $[X] = J.concat($[X]);
    else
      $[X] = $[X].concat(J);
  else {
    if (!W[X])
      W[X] = [];
    if (typeof W[X] === "function")
      W[X] = [W[X]];
    if (!Array.isArray(J))
      if (j === "before")
        W[X].unshift(J);
      else
        W[X].push(J);
    else if (j === "before")
      W[X] = J.concat(W[X]);
    else
      W[X] = W[X].concat(J);
  }
};
var H3 = ($) => {
  if (typeof $ === "number")
    return $;
  if ($.length < 16) {
    if ($.trim().length === 0)
      return null;
    let W = Number($);
    if (Number.isNaN(W))
      return null;
    return W;
  }
  if ($.length === 16) {
    if ($.trim().length === 0)
      return null;
    let W = Number($);
    if (Number.isNaN(W) || W.toString() !== $)
      return null;
    return W;
  }
  return null;
};
var Z1 = ($) => H3($) !== null;

class C1 {
  $;
  root = null;
  promises = [];
  constructor($ = console.error) {
    this.onError = $;
  }
  get size() {
    return this.promises.length;
  }
  add($) {
    return this.promises.push($), this.root ||= this.drain(), $;
  }
  async drain() {
    while (this.promises.length > 0) {
      try {
        await this.promises[0];
      } catch ($) {
        this.onError($);
      }
      this.promises.shift();
    }
    this.root = null;
  }
  then($, W) {
    return (this.root ?? Promise.resolve()).then($, W);
  }
}
var n = ($) => {
  if (!$)
    return $;
  if (!Array.isArray($)) {
    if (typeof $ === "function")
      return { fn: $ };
    else if ("fn" in $)
      return $;
  }
  let W = [];
  for (let X of $)
    if (typeof X === "function")
      W.push({ fn: X });
    else if ("fn" in X)
      W.push(X);
  return W;
};
var P2 = ($) => {
  return { ...$, start: n($?.start), request: n($?.request), parse: n($?.parse), transform: n($?.transform), beforeHandle: n($?.beforeHandle), afterHandle: n($?.afterHandle), mapResponse: n($?.mapResponse), afterResponse: n($?.afterResponse), trace: n($?.trace), error: n($?.error), stop: n($?.stop) };
};
var L1 = ($) => {
  return { ...$, start: $.start?.map((W) => W.fn), request: $.request?.map((W) => W.fn), parse: $.parse?.map((W) => W.fn), transform: $.transform?.map((W) => W.fn), beforeHandle: $.beforeHandle?.map((W) => W.fn), afterHandle: $.afterHandle?.map((W) => W.fn), afterResponse: $.afterResponse?.map((W) => W.fn), mapResponse: $.mapResponse?.map((W) => W.fn), trace: $.trace?.map((W) => W.fn), error: $.error?.map((W) => W.fn), stop: $.stop?.map((W) => W.fn) };
};
var d0 = ($) => ({ body: $.body, cookie: $.cookie, headers: $.headers, query: $.query, set: $.set, server: $.server });
var c0 = ($, W = 302) => Response.redirect($, W);
var R3 = Symbol("ElysiaFormData");
var P0 = Symbol("ElysiaRequestId");
var J1 = () => crypto.getRandomValues(new Uint32Array(1))[0];
var j1 = ($) => {
  let W = [];
  for (let X = 0;X < $.length; X++) {
    let Z = $[X];
    if (Z.checksum) {
      if (W.includes(Z.checksum))
        $.splice(X, 1), X--;
      W.push(Z.checksum);
    }
  }
  return $;
};
var v = ($, W = "scoped") => {
  if (W === "scoped") {
    for (let X of $)
      if ("scope" in X && X.scope === "local")
        X.scope = "scoped";
    return;
  }
  for (let X of $)
    if ("scope" in X)
      X.scope = "global";
};
var I2 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var I0 = Symbol("ElysiaErrorCode");
var p0 = (I2?.NODE_ENV ?? I2?.ENV) === "production";

class l {
  code;
  response;
  constructor($, W) {
    let X = W ?? ($ in X1 ? X1[$] : $);
    this.code = _0[$] ?? $, this.response = X;
  }
}
var T1 = ($, W) => new l($, W);

class Q1 extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class A0 extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}

class Y1 extends Error {
  code = "PARSE";
  status = 400;
  constructor() {
    super("Failed to parse body");
  }
}

class u0 extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, W) {
    super(W ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}
var o = ($) => {
  if (!$)
    return { summary: undefined };
  let { message: W, path: X, value: Z, type: J } = $, j = X.slice(1).replaceAll("/", "."), Y = X === "";
  switch (J) {
    case 42:
      return { ...$, summary: Y ? "Value should not be provided" : `Property '${j}' should not be provided` };
    case 45:
      return { ...$, summary: Y ? "Value is missing" : `Property '${j}' is missing` };
    case 50:
      let G = W.indexOf("'"), K = W.slice(G + 1, W.indexOf("'", G + 1));
      return { ...$, summary: Y ? "Value should be an email" : `Property '${j}' should be ${K}` };
    case 54:
      return { ...$, summary: `${W.slice(0, 9)} property '${j}' to be ${W.slice(8)} but found: ${Z}` };
    case 62:
      let B = $.schema.anyOf.map((U) => `'${U?.format ?? U.type}'`).join(", ");
      return { ...$, summary: Y ? `Value should be one of ${B}` : `Property '${j}' should be one of: ${B}` };
    default:
      return { summary: W, ...$ };
  }
};

class q extends Error {
  $;
  W;
  X;
  code = "VALIDATION";
  status = 422;
  constructor($, W, X) {
    if (X && typeof X === "object" && X instanceof l)
      X = X.response;
    let Z = p0 ? undefined : ("Errors" in W) ? W.Errors(X).First() : exports_value2.Errors(W, X).First(), J = Z?.schema.error !== undefined ? typeof Z.schema.error === "function" ? Z.schema.error({ type: $, validator: W, value: X, get errors() {
      return [...W.Errors(X)].map(o);
    } }) : Z.schema.error : undefined, j = Z?.path || "root", Y = "";
    if (J !== undefined)
      Y = typeof J === "object" ? JSON.stringify(J) : J + "";
    else if (p0)
      Y = JSON.stringify({ type: "validation", on: $, summary: o(Z).summary, message: Z?.message, found: X });
    else {
      let G = W?.schema ?? W, K = "Errors" in W ? [...W.Errors(X)].map(o) : [...exports_value2.Errors(W, X)].map(o), B;
      try {
        B = exports_value2.Create(G);
      } catch (U) {
        B = { type: "Could not create expected value", message: U?.message, error: U };
      }
      Y = JSON.stringify({ type: "validation", on: $, summary: K[0]?.summary, property: j, message: Z?.message, expected: B, found: X, errors: K }, null, 2);
    }
    super(Y);
    this.type = $;
    this.validator = W;
    this.value = X;
    Object.setPrototypeOf(this, q.prototype);
  }
  get all() {
    return "Errors" in this.validator ? [...this.validator.Errors(this.value)].map(o) : [...exports_value2.Errors(this.validator, this.value)].map(o);
  }
  static simplifyModel($) {
    let W = "schema" in $ ? $.schema : $;
    try {
      return exports_value2.Create(W);
    } catch {
      return W;
    }
  }
  get model() {
    return q.simplifyModel(this.validator);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: { ...$, "content-type": "application/json" } });
  }
}
var E1 = { open($) {
  $.data.open?.($);
}, message($, W) {
  $.data.message?.($, W);
}, drain($) {
  $.data.drain?.($);
}, close($, W, X) {
  $.data.close?.($, W, X);
} };

class g0 {
  $;
  W;
  validator;
  _validator;
  constructor($, W) {
    this.raw = $;
    this.data = W;
    if (this.validator = $.data.validator, $.data.id)
      this.id = $.data.id;
    else
      this.id = J1().toString();
  }
  get id() {
    return this.raw.data.id;
  }
  set id($) {
    this.raw.data.id = $;
  }
  get publish() {
    return ($, W = undefined, X) => {
      if (this.validator?.Check(W) === false)
        throw new q("message", this.validator, W);
      if (typeof W === "object")
        W = JSON.stringify(W);
      return this.raw.publish($, W, X), this;
    };
  }
  get send() {
    return ($) => {
      if (this.validator?.Check($) === false)
        throw new q("message", this.validator, $);
      if (Buffer.isBuffer($))
        return this.raw.send($), this;
      if (typeof $ === "object")
        $ = JSON.stringify($);
      return this.raw.send($), this;
    };
  }
  get subscribe() {
    return ($) => {
      return this.raw.subscribe($), this;
    };
  }
  get unsubscribe() {
    return ($) => {
      return this.raw.unsubscribe($), this;
    };
  }
  get cork() {
    return ($) => {
      return this.raw.cork($), this;
    };
  }
  get close() {
    return () => {
      return this.raw.close(), this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var q1 = "1.1.24";
var O0 = k0(o0(), 1);
var f0 = /\+/g;
function G1($) {
  let W = {};
  if (typeof $ !== "string")
    return W;
  let X = "", Z = "", J = -1, j = -1, Y = 0, G = $.length;
  for (let K = 0;K < G; K++)
    switch ($.charCodeAt(K)) {
      case 38:
        let B = j > J;
        if (!B)
          j = K;
        if (X = $.slice(J + 1, j), B || X.length > 0) {
          if (Y & 1)
            X = X.replace(f0, " ");
          if (Y & 2)
            X = O0.default(X) || X;
          if (!W[X]) {
            if (B) {
              if (Z = $.slice(j + 1, K), Y & 4)
                Z = Z.replace(f0, " ");
              if (Y & 8)
                Z = O0.default(Z) || Z;
            }
            W[X] = Z;
          }
        }
        X = "", Z = "", J = K, j = K, Y = 0;
        break;
      case 61:
        if (j <= J)
          j = K;
        else
          Y |= 8;
        break;
      case 43:
        if (j > J)
          Y |= 4;
        else
          Y |= 1;
        break;
      case 37:
        if (j > J)
          Y |= 8;
        else
          Y |= 2;
        break;
    }
  if (J < G) {
    let K = j > J;
    if (X = $.slice(J + 1, K ? j : G), K || X.length > 0) {
      if (Y & 1)
        X = X.replace(f0, " ");
      if (Y & 2)
        X = O0.default(X) || X;
      if (!W[X]) {
        if (K) {
          if (Z = $.slice(j + 1, G), Y & 4)
            Z = Z.replace(f0, " ");
          if (Y & 8)
            Z = O0.default(Z) || Z;
        }
        W[X] = Z;
      }
    }
  }
  return W;
}
var i0 = ($) => {
  let W = {};
  if (typeof $ !== "string")
    return W;
  let X = $.length, Z = "", J = "", j = -1, Y = -1, G = false, K = false, B = false, U = false, w = false, F = 0;
  for (let Q = 0;Q < X + 1; Q++) {
    if (Q !== X)
      F = $.charCodeAt(Q);
    else
      F = 38;
    switch (F) {
      case 38: {
        if (w = Y > j, !w)
          Y = Q;
        if (Z = $.slice(j + 1, Y), w || Z.length > 0) {
          if (B)
            Z = Z.replace(f0, " ");
          if (G)
            Z = O0.default(Z) || Z;
          if (w) {
            if (J = $.slice(Y + 1, Q), U)
              J = J.replace(f0, " ");
            if (K)
              J = O0.default(J) || J;
          }
          let M = W[Z];
          if (M === undefined)
            W[Z] = J;
          else if (M.pop)
            M.push(J);
          else
            W[Z] = [M, J];
        }
        J = "", j = Q, Y = Q, G = false, K = false, B = false, U = false;
        break;
      }
      case 61:
        if (Y <= j)
          Y = Q;
        else
          K = true;
        break;
      case 43:
        if (Y > j)
          U = true;
        else
          B = true;
        break;
      case 37:
        if (Y > j)
          K = true;
        else
          G = true;
        break;
    }
  }
  return W;
};
var O2 = k0(o0(), 1);
var n0 = Symbol("ElysiaTrace");
var F0 = () => {
  let { promise: $, resolve: W } = Promise.withResolvers(), { promise: X, resolve: Z } = Promise.withResolvers(), { promise: J, resolve: j } = Promise.withResolvers(), Y = [], G = [];
  return [(K) => {
    if (K)
      Y.push(K);
    return $;
  }, (K) => {
    let B = [], U = [], w = null;
    for (let Q = 0;Q < (K.total ?? 0); Q++) {
      let { promise: M, resolve: D } = Promise.withResolvers(), { promise: z, resolve: I } = Promise.withResolvers(), { promise: O, resolve: P } = Promise.withResolvers(), b = [], T = [];
      B.push((E) => {
        if (E)
          b.push(E);
        return M;
      }), U.push((E) => {
        let r = { ...E, end: z, error: O, index: Q, onStop(L) {
          if (L)
            T.push(L);
          return z;
        } };
        D(r);
        for (let L = 0;L < b.length; L++)
          b[L](r);
        return (L = null) => {
          let f = performance.now();
          if (L)
            w = L;
          let R = { end: f, error: L, get elapsed() {
            return f - E.begin;
          } };
          for (let Y0 = 0;Y0 < T.length; Y0++)
            T[Y0](R);
          I(f), P(L);
        };
      });
    }
    let F = { ...K, end: X, error: J, onEvent(Q) {
      for (let M = 0;M < B.length; M++)
        B[M](Q);
    }, onStop(Q) {
      if (Q)
        G.push(Q);
      return X;
    } };
    W(F);
    for (let Q = 0;Q < Y.length; Q++)
      Y[Q](F);
    return { resolveChild: U, resolve(Q = null) {
      let M = performance.now();
      if (!Q && w)
        Q = w;
      let D = { end: M, error: Q, get elapsed() {
        return M - K.begin;
      } };
      for (let z = 0;z < G.length; z++)
        G[z](D);
      Z(M), j(Q);
    } };
  }];
};
var A2 = ($) => {
  return (W) => {
    let [X, Z] = F0(), [J, j] = F0(), [Y, G] = F0(), [K, B] = F0(), [U, w] = F0(), [F, Q] = F0(), [M, D] = F0(), [z, I] = F0(), [O, P] = F0();
    return $({ id: W[P0], context: W, set: W.set, onRequest: X, onParse: J, onTransform: Y, onBeforeHandle: K, onHandle: U, onAfterHandle: F, onMapResponse: z, onAfterResponse: O, onError: M }), { request: Z, parse: j, transform: G, beforeHandle: B, handle: w, afterHandle: Q, error: D, mapResponse: I, afterResponse: P };
  };
};
var f3 = new Headers().toJSON;
var V2 = { optional: Symbol.for("TypeBox.Optional"), kind: Symbol.for("TypeBox.Kind") };
var t = ($) => {
  if (!$)
    return false;
  let W = $?.schema;
  return !!W && V2.optional in W;
};
var j0 = ($) => {
  if (!$)
    return false;
  let W = $?.schema ?? $;
  if (W.anyOf)
    return W.anyOf.some(j0);
  if (W.someOf)
    return W.someOf.some(j0);
  if (W.allOf)
    return W.allOf.some(j0);
  if (W.not)
    return W.not.some(j0);
  if (W.type === "object") {
    let X = W.properties;
    if ("additionalProperties" in W)
      return W.additionalProperties;
    if ("patternProperties" in W)
      return false;
    for (let Z of Object.keys(X)) {
      let J = X[Z];
      if (J.type === "object") {
        if (j0(J))
          return true;
      } else if (J.anyOf) {
        for (let j = 0;j < J.anyOf.length; j++)
          if (j0(J.anyOf[j]))
            return true;
      }
      return J.additionalProperties;
    }
    return false;
  }
  return false;
};
var R1 = ({ context: $ = "c", trace: W, addFn: X }) => {
  if (!W.length)
    return () => {
      return { resolveChild() {
        return () => {
        };
      }, resolve() {
      } };
    };
  for (let Z = 0;Z < W.length; Z++)
    X(`let report${Z}, reportChild${Z}, reportErr${Z}, reportErrChild${Z}; let trace${Z} = ${$}[ELYSIA_TRACE]?.[${Z}] ?? trace[${Z}](${$});
`);
  return (Z, { name: J, total: j = 0 } = {}) => {
    if (!J)
      J = "anonymous";
    let Y = Z === "error" ? "reportErr" : "report";
    for (let G = 0;G < W.length; G++)
      X(`
${Y}${G} = trace${G}.${Z}({id,event: '${Z}',name: '${J}',begin: performance.now(),total: ${j}})
`);
    return { resolve() {
      for (let G = 0;G < W.length; G++)
        X(`
${Y}${G}.resolve()
`);
    }, resolveChild(G) {
      for (let K = 0;K < W.length; K++)
        X(`${Y}Child${K} = ${Y}${K}.resolveChild?.shift()?.({id,event: '${Z}',name: '${G}',begin: performance.now()})
`);
      return (K) => {
        for (let B = 0;B < W.length; B++)
          if (K)
            X(`
                             \tif (${K} instanceof Error)
                    \t\t\t\t${Y}Child${B}?.(${K})
                           \t\telse
                             \t\t${Y}Child${B}?.()
`);
          else
            X(`${Y}Child${B}?.()
`);
      };
    } };
  };
};
var y3 = ({ injectResponse: $ = "", normalize: W = false, validator: X }) => ({ composeValidation: (Z, J = `c.${Z}`) => `c.set.status = 422; throw new ValidationError('${Z}', validator.${Z}, ${J})`, composeResponseValidation: (Z = "r") => {
  let J = `
` + $ + `
`;
  J += `if(${Z} instanceof ElysiaCustomStatusResponse) {
\t\t\tc.set.status = ${Z}.code
\t\t\t${Z} = ${Z}.response
\t\t}

\t\tconst isResponse = ${Z} instanceof Response

`, J += `switch(c.set.status) {
`;
  for (let [j, Y] of Object.entries(X.response)) {
    if (J += `\tcase ${j}:
\t\t\t\tif (!isResponse) {
`, W && "Clean" in Y && !j0(Y))
      J += `${Z} = validator.response['${j}'].Clean(${Z})
`;
    J += `if(validator.response['${j}'].Check(${Z}) === false) {
\t\t\t\t\tc.set.status = 422

\t\t\t\t\tthrow new ValidationError('response', validator.response['${j}'], ${Z})
\t\t\t\t}

\t\t\t\tc.set.status = ${j}
\t\t\t}

\t\t\tbreak

`;
  }
  return J += `
}
`, J;
} });
var $5 = Symbol.for("TypeBox.Kind");
var V0 = ($, W) => {
  if (!W)
    return;
  if (W.type === "object") {
    let X = W.properties;
    if (!X)
      return false;
    for (let Z of Object.keys(X)) {
      let J = X[Z];
      if ($ in J)
        return true;
      if (J.type === "object") {
        if (V0($, J))
          return true;
      } else if (J.anyOf) {
        for (let j = 0;j < J.anyOf.length; j++)
          if (V0($, J.anyOf[j]))
            return true;
      }
    }
    return false;
  }
  return $ in W;
};
var H1 = Symbol.for("TypeBox.Transform");
var S0 = ($) => {
  if (!$)
    return;
  if ($.type === "object" && $.properties) {
    let W = $.properties;
    for (let X of Object.keys(W)) {
      let Z = W[X];
      if (Z.type === "object") {
        if (S0(Z))
          return true;
      } else if (Z.anyOf) {
        for (let j = 0;j < Z.anyOf.length; j++)
          if (S0(Z.anyOf[j]))
            return true;
      }
      if (H1 in Z)
        return true;
    }
    return false;
  }
  return H1 in $ || $.properties && H1 in $.properties;
};
var k3 = /(?:return|=>) \S+\(/g;
var C0 = ($) => {
  return ($?.fn ?? $).constructor.name === "AsyncFunction";
};
var k = ($) => {
  let W = $?.fn ?? $;
  if (W.constructor.name === "AsyncFunction")
    return true;
  let X = W.toString();
  if (X.includes("=> response.clone("))
    return false;
  if (X.includes("await"))
    return true;
  if (X.includes("async"))
    return true;
  return !!X.match(k3);
};
var B1 = ($) => {
  let W = $?.fn ?? $;
  return W.constructor.name === "AsyncGeneratorFunction" || W.constructor.name === "GeneratorFunction";
};
var S2 = ({ app: $, path: W, method: X, localHook: Z, hooks: J, validator: j, handler: Y, allowMeta: G = false, inference: K }) => {
  let B = typeof Y === "function";
  if (!B) {
    if (Y = x(Y, { headers: $.setHeaders ?? {} }), J.parse.length === 0 && J.transform.length === 0 && J.beforeHandle.length === 0 && J.afterHandle.length === 0)
      return Function("a", "return function () { return a.clone() }")(Y);
  }
  let U = B ? "handler(c)" : "handler", w = J.afterResponse.length > 0, F = J.trace.length > 0, Q = "";
  if (K = s0(Object.assign(Z, { handler: Y }), K), K.server)
    Q += `
Object.defineProperty(c, 'server', {
\t\t\tget: function() { return getServer() }
\t\t})
`;
  if (K.body)
    Q += `let isParsing = false
`;
  j.createBody?.(), j.createQuery?.(), j.createHeaders?.(), j.createParams?.(), j.createCookie?.(), j.createResponse?.();
  let M = K.query || !!j.query, D = X !== "$INTERNALWS" && X !== "GET" && X !== "HEAD" && (K.body || !!j.body || J.parse.length), z = $.setHeaders, I = z && !!Object.keys(z).length, O = K.headers || j.headers, P = K.cookie || !!j.cookie, b = P ? W1({ validator: j.cookie, defaultConfig: $.config.cookie, dynamic: !!$.config.aot, config: j.cookie?.config ?? {}, models: $.definitions.type }) : undefined, T = b?.config, E = "";
  if (T?.sign) {
    if (!T.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${X}) ${W}.`);
    let N = !T.secrets ? undefined : typeof T.secrets === "string" ? T.secrets : T.secrets[0];
    if (E += `const _setCookie = c.set.cookie
\t\tif(_setCookie) {`, T.sign === true)
      E += `for(const [key, cookie] of Object.entries(_setCookie)) {
\t\t\t\tc.set.cookie[key].value = await signCookie(cookie.value, '${N}')
\t\t\t}`;
    else
      for (let _ of T.sign)
        E += `if(_setCookie['${_}']?.value) { c.set.cookie['${_}'].value = await signCookie(_setCookie['${_}'].value, '${N}') }
`;
    E += `}
`;
  }
  let r = $.config.normalize, { composeValidation: L, composeResponseValidation: f } = y3({ normalize: r, validator: j });
  if (O)
    Q += f3 ? `c.headers = c.request.headers.toJSON()
` : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
\t\t\t\t\tc.headers[key] = value
\t\t\t\t`;
  if (P) {
    let N = (A, S) => {
      let C = T?.[A] ?? S;
      if (!C)
        return typeof S === "string" ? `${A}: "${S}",` : `${A}: ${S},`;
      if (typeof C === "string")
        return `${A}: '${C}',`;
      if (C instanceof Date)
        return `${A}: new Date(${C.getTime()}),`;
      return `${A}: ${C},`;
    }, _ = T ? `{
\t\t\tsecrets: ${T.secrets !== undefined ? typeof T.secrets === "string" ? `'${T.secrets}'` : "[" + T.secrets.reduce((A, S) => A + `'${S}',`, "") + "]" : "undefined"},
\t\t\tsign: ${T.sign === true ? true : T.sign !== undefined ? "[" + T.sign.reduce((A, S) => A + `'${S}',`, "") + "]" : "undefined"},
\t\t\t${N("domain")}
\t\t\t${N("expires")}
\t\t\t${N("httpOnly")}
\t\t\t${N("maxAge")}
\t\t\t${N("path", "/")}
\t\t\t${N("priority")}
\t\t\t${N("sameSite")}
\t\t\t${N("secure")}
\t\t}` : "undefined";
    if (O)
      Q += `
c.cookie = await parseCookie(c.set, c.headers.cookie, ${_})
`;
    else
      Q += `
c.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${_})
`;
  }
  if (M) {
    let N = [];
    if (j.query && j.query.schema.type === "object") {
      let _ = j.query.schema.properties;
      if (!j0(j.query))
        for (let [A, S] of Object.entries(_)) {
          let C = S;
          if (C && V2.optional in C && C.type === "array" && C.items)
            C = C.items;
          let { type: a, anyOf: H } = C, U0 = a === "array" || H?.some((u) => u.type === "string" && u.format === "ArrayString");
          N.push({ key: A, isArray: U0, isNestedObjectArray: U0 && C.items?.type === "object" || !!C.items?.anyOf?.some((u) => u.type === "object" || u.type === "array"), isObject: a === "object" || H?.some((u) => u.type === "string" && u.format === "ArrayString"), anyOf: !!H });
        }
    }
    if (!N.length)
      Q += `if(c.qi === -1) {
\t\t\t\tc.query = {}
\t\t\t} else {
\t\t\t\tc.query = parseQueryFromURL(c.url.slice(c.qi + 1))
\t\t\t}`;
    else
      Q += `if(c.qi !== -1) {
\t\t\t\tlet url = '&' + c.url.slice(c.qi + 1)

\t\t\t\t${N.map(({ key: _, isArray: A, isObject: S, isNestedObjectArray: C, anyOf: a }, H) => {
        let U0 = `${H === 0 ? "let" : ""} memory = url.indexOf('&${_}=')
\t\t\t\t\t\t\tlet a${H}
`;
        if (A)
          return U0 + (C ? `while (memory !== -1) {
\t\t\t\t\t\t\t\t\t\t\tconst start = memory + ${_.length + 2}
\t\t\t\t\t\t\t\t\t\t\tmemory = url.indexOf('&', start)

\t\t\t\t\t\t\t\t\t\t\tif(a${H} === undefined)
\t\t\t\t\t\t\t\t\t\t\t\ta${H} = ''
\t\t\t\t\t\t\t\t\t\t\telse
\t\t\t\t\t\t\t\t\t\t\t\ta${H} += ','

\t\t\t\t\t\t\t\t\t\t\tlet temp

\t\t\t\t\t\t\t\t\t\t\tif(memory === -1) temp = decodeURIComponent(url.slice(start).replace(/\\+/g, ' '))
\t\t\t\t\t\t\t\t\t\t\telse temp = decodeURIComponent(url.slice(start, memory).replace(/\\+/g, ' '))

\t\t\t\t\t\t\t\t\t\t\tconst charCode = temp.charCodeAt(0)
\t\t\t\t\t\t\t\t\t\t\tif(charCode !== 91 && charCode !== 123)
\t\t\t\t\t\t\t\t\t\t\t\ttemp = '"' + temp + '"'

\t\t\t\t\t\t\t\t\t\t\ta${H} += temp

\t\t\t\t\t\t\t\t\t\t\tif(memory === -1) break

\t\t\t\t\t\t\t\t\t\t\tmemory = url.indexOf('&${_}=', memory)
\t\t\t\t\t\t\t\t\t\t\tif(memory === -1) break
\t\t\t\t\t\t\t\t\t\t}

\t\t\t\t\t\t\t\t\t\ttry {
\t\t\t\t\t\t\t\t\t\t    if(a${H}.charCodeAt(0) === 91)
\t\t\t\t\t\t\t\t\t\t\t\ta${H} = JSON.parse(a${H})
\t\t\t\t\t\t\t\t\t\t\telse
\t\t\t\t\t\t\t\t\t\t\t\ta${H} = JSON.parse('[' + a${H} + ']')
\t\t\t\t\t\t\t\t\t\t} catch {}
` : `while (memory !== -1) {
\t\t\t\t\t\t\t\t\t\t\tconst start = memory + ${_.length + 2}
\t\t\t\t\t\t\t\t\t\t\tmemory = url.indexOf('&', start)

\t\t\t\t\t\t\t\t\t\t\tif(a${H} === undefined)
\t\t\t\t\t\t\t\t\t\t\t\ta${H} = []

\t\t\t\t\t\t\t\t\t\t\tif(memory === -1) {
\t\t\t\t\t\t\t\t\t\t\t\ta${H}.push(decodeURIComponent(url.slice(start)).replace(/\\+/g, ' '))
\t\t\t\t\t\t\t\t\t\t\t\tbreak
\t\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t\t\telse a${H}.push(decodeURIComponent(url.slice(start, memory)).replace(/\\+/g, ' '))

\t\t\t\t\t\t\t\t\t\t\tmemory = url.indexOf('&${_}=', memory)
\t\t\t\t\t\t\t\t\t\t\tif(memory === -1) break
\t\t\t\t\t\t\t\t\t\t}
`);
        if (S)
          return U0 + `if (memory !== -1) {
\t\t\t\t\t\t\t\t\t\tconst start = memory + ${_.length + 2}
\t\t\t\t\t\t\t\t\t\tmemory = url.indexOf('&', start)

\t\t\t\t\t\t\t\t\t\tif(memory === -1) a${H} = decodeURIComponent(url.slice(start).replace(/\\+/g, ' '))
\t\t\t\t\t\t\t\t\t\telse a${H} = decodeURIComponent(url.slice(start, memory).replace(/\\+/g, ' '))

\t\t\t\t\t\t\t\t\t\tif (a${H} !== undefined) {
\t\t\t\t\t\t\t\t\t\t\ttry {
\t\t\t\t\t\t\t\t\t\t\t\ta${H} = JSON.parse(a${H})
\t\t\t\t\t\t\t\t\t\t\t} catch {}
\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t}`;
        return U0 + `if (memory !== -1) {
\t\t\t\t\t\t\t\t\t\tconst start = memory + ${_.length + 2}
\t\t\t\t\t\t\t\t\t\tmemory = url.indexOf('&', start)

\t\t\t\t\t\t\t\t\t\tif(memory === -1) a${H} = decodeURIComponent(url.slice(start).replace(/\\+/g, ' '))
\t\t\t\t\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\t\t\t\ta${H} = decodeURIComponent(url.slice(start, memory).replace(/\\+/g, ' '))

\t\t\t\t\t\t\t\t\t\t\t${a ? `
\t\t\t\t\t\t\t\t\t\t\tlet deepMemory = url.indexOf('&${_}=', memory)

\t\t\t\t\t\t\t\t\t\t\tif(deepMemory !== -1) {
\t\t\t\t\t\t\t\t\t\t\t\ta${H} = [a${H}]
\t\t\t\t\t\t\t\t\t\t\t\tlet first = true

\t\t\t\t\t\t\t\t\t\t\t\twhile(true) {
\t\t\t\t\t\t\t\t\t\t\t\t\tconst start = deepMemory + ${_.length + 2}
\t\t\t\t\t\t\t\t\t\t\t\t\tif(first)
\t\t\t\t\t\t\t\t\t\t\t\t\t\tfirst = false
\t\t\t\t\t\t\t\t\t\t\t\t\telse
\t\t\t\t\t\t\t\t\t\t\t\t\t\tdeepMemory = url.indexOf('&', start)

\t\t\t\t\t\t\t\t\t\t\t\t\tlet value
\t\t\t\t\t\t\t\t\t\t\t\t\tif(deepMemory === -1) value = decodeURIComponent(url.slice(start).replace(/\\+/g, ' '))
\t\t\t\t\t\t\t\t\t\t\t\t\telse value = decodeURIComponent(url.slice(start, deepMemory).replace(/\\+/g, ' '))

\t\t\t\t\t\t\t\t\t\t\t\t\tconst vStart = value.charCodeAt(0)
\t\t\t\t\t\t\t\t\t\t\t\t\tconst vEnd = value.charCodeAt(value.length - 1)

\t\t\t\t\t\t\t\t\t\t\t\t\tif((vStart === 91 && vEnd === 93) || (vStart === 123 && vEnd === 125))
\t\t\t\t\t\t\t\t\t\t\t\t\t\ttry {
\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ta${H}.push(JSON.parse(value))
\t\t\t\t\t\t\t\t\t\t\t\t\t\t} catch {
\t\t\t\t\t\t\t\t\t\t\t\t\t\t \ta${H}.push(value)
\t\t\t\t\t\t\t\t\t\t\t\t\t\t}

\t\t\t\t\t\t\t\t\t\t\t\t\tif(deepMemory === -1) break
\t\t\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t\t\t\t` : ""}
\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t}`;
      }).join(`
`)}

\t\t\t\tc.query = {
\t\t\t\t\t${N.map(({ key: _ }, A) => `'${_}': a${A}`).join(", ")}
\t\t\t\t}
\t\t\t} else {
\t\t\t\tc.query = {}
\t\t\t}`;
  }
  if (F)
    Q += `
const id = c[ELYSIA_REQUEST_ID]
`;
  let R = R1({ trace: J.trace, addFn: (N) => {
    Q += N;
  } });
  Q += `
try {
`;
  let Y0 = typeof Y === "function" && k(Y), e = F || J.afterResponse.length > 0 ? "c.response = " : "", y0 = P || D || Y0 || J.parse.length > 0 || J.afterHandle.some(k) || J.beforeHandle.some(k) || J.transform.some(k) || J.mapResponse.some(k), L2 = (typeof Y === "function" ? B1(Y) : false) || J.beforeHandle.some(B1) || J.afterHandle.some(B1) || J.transform.some(B1), r0 = K.cookie || K.set || O || F || j.response || B && I || L2, s = ", c.request";
  Q += `c.route = \`${W}\`
`;
  let T2 = R("parse", { total: J.parse.length });
  if (D) {
    let N = J.parse.length || K.body || j.body;
    if (Q += `isParsing = true
`, J.type && !J.parse.length)
      switch (J.type) {
        case "json":
        case "application/json":
          if (t(j.body))
            Q += "try { c.body = await c.request.json() } catch {}";
          else
            Q += "c.body = await c.request.json()";
          break;
        case "text":
        case "text/plain":
          Q += `c.body = await c.request.text()
`;
          break;
        case "urlencoded":
        case "application/x-www-form-urlencoded":
          Q += `c.body = parseQuery(await c.request.text())
`;
          break;
        case "arrayBuffer":
        case "application/octet-stream":
          Q += `c.body = await c.request.arrayBuffer()
`;
          break;
        case "formdata":
        case "multipart/form-data":
          if (Q += `c.body = {}
`, t(j.body))
            Q += "let form; try { form = await c.request.formData() } catch {}";
          else
            Q += "const form = await c.request.formData()";
          Q += `
if(form)
\t\t\t\t\t\tfor (const key of form.keys()) {
\t\t\t\t\t\t\tif (c.body[key])
\t\t\t\t\t\t\t\tcontinue

\t\t\t\t\t\t\tconst value = form.getAll(key)
\t\t\t\t\t\t\tif (value.length === 1)
\t\t\t\t\t\t\t\tc.body[key] = value[0]
\t\t\t\t\t\t\telse c.body[key] = value
\t\t\t\t\t\t} else form = {}
`;
          break;
      }
    else if (N) {
      if (Q += `
`, Q += O ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", Q += `
\t\t\t\tif (contentType) {
\t\t\t\t\tconst index = contentType.indexOf(';')
\t\t\t\t\tif (index !== -1) contentType = contentType.substring(0, index)

\t\t\t\t\tc.contentType = contentType
`, J.parse.length) {
        Q += `let used = false
`;
        let _ = R("parse", { total: J.parse.length });
        for (let A = 0;A < J.parse.length; A++) {
          let S = _.resolveChild(J.parse[A].fn.name), C = `bo${A}`;
          if (A !== 0)
            Q += `if(!used) {
`;
          if (Q += `let ${C} = parse[${A}](c, contentType)
`, Q += `if(${C} instanceof Promise) ${C} = await ${C}
`, Q += `if(${C} !== undefined) { c.body = ${C}; used = true }
`, S(), A !== 0)
            Q += "}";
        }
        _.resolve();
      }
      if (Q += `
delete c.contentType
`, J.parse.length)
        Q += "if (!used) {";
      if (J.type && !Array.isArray(J.type))
        switch (J.type) {
          case "json":
          case "application/json":
            if (t(j.body))
              Q += "try { c.body = await c.request.json() } catch {}";
            else
              Q += "c.body = await c.request.json()";
            break;
          case "text":
          case "text/plain":
            Q += `c.body = await c.request.text()
`;
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            Q += `c.body = parseQuery(await c.request.text())
`;
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            Q += `c.body = await c.request.arrayBuffer()
`;
            break;
          case "formdata":
          case "multipart/form-data":
            Q += `c.body = {}

\t\t\t\t\t\t\tconst form = await c.request.formData()
\t\t\t\t\t\t\tfor (const key of form.keys()) {
\t\t\t\t\t\t\t\tif (c.body[key])
\t\t\t\t\t\t\t\t\tcontinue

\t\t\t\t\t\t\t\tconst value = form.getAll(key)
\t\t\t\t\t\t\t\tif (value.length === 1)
\t\t\t\t\t\t\t\t\tc.body[key] = value[0]
\t\t\t\t\t\t\t\telse c.body[key] = value
\t\t\t\t\t\t\t}
`;
            break;
        }
      else
        Q += `
\t\t\t\t\tswitch (contentType) {
\t\t\t\t\t\tcase 'application/json':
\t\t\t\t\t\t\t${t(j.body) ? "try { c.body = await c.request.json() } catch {}" : "c.body = await c.request.json()"}
\t\t\t\t\t\t\tbreak

\t\t\t\t\t\tcase 'text/plain':
\t\t\t\t\t\t\tc.body = await c.request.text()
\t\t\t\t\t\t\tbreak

\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':
\t\t\t\t\t\t\tc.body = parseQuery(await c.request.text())
\t\t\t\t\t\t\tbreak

\t\t\t\t\t\tcase 'application/octet-stream':
\t\t\t\t\t\t\tc.body = await c.request.arrayBuffer();
\t\t\t\t\t\t\tbreak

\t\t\t\t\t\tcase 'multipart/form-data':
\t\t\t\t\t\t\tc.body = {}

\t\t\t\t\t\t\tconst form = await c.request.formData()
\t\t\t\t\t\t\tfor (const key of form.keys()) {
\t\t\t\t\t\t\t\tif (c.body[key])
\t\t\t\t\t\t\t\t\tcontinue

\t\t\t\t\t\t\t\tconst value = form.getAll(key)
\t\t\t\t\t\t\t\tif (value.length === 1)
\t\t\t\t\t\t\t\t\tc.body[key] = value[0]
\t\t\t\t\t\t\t\telse c.body[key] = value
\t\t\t\t\t\t\t}

\t\t\t\t\t\t\tbreak
\t\t\t\t\t}`;
      if (J.parse.length)
        Q += "}";
      Q += `}
`;
    }
    Q += `
isParsing = false
`;
  }
  if (T2.resolve(), J?.transform) {
    let N = R("transform", { total: J.transform.length });
    if (J.transform.length)
      Q += `
let transformed
`;
    for (let _ = 0;_ < J.transform.length; _++) {
      let A = J.transform[_], S = N.resolveChild(A.fn.name);
      if (Q += k(A) ? `transformed = await transform[${_}](c)
` : `transformed = transform[${_}](c)
`, A.subType === "mapDerive")
        Q += `if(transformed instanceof ElysiaCustomStatusResponse)
\t\t\t\t\tthrow transformed
\t\t\t\telse {
\t\t\t\t\ttransformed.request = c.request
\t\t\t\t\ttransformed.store = c.store
\t\t\t\t\ttransformed.qi = c.qi
\t\t\t\t\ttransformed.path = c.path
\t\t\t\t\ttransformed.url = c.url
\t\t\t\t\ttransformed.redirect = c.redirect
\t\t\t\t\ttransformed.set = c.set
\t\t\t\t\ttransformed.error = c.error

\t\t\t\t\tc = transformed
\t\t\t}`;
      else
        Q += `if(transformed instanceof ElysiaCustomStatusResponse)
\t\t\t\t\tthrow transformed
\t\t\t\telse
\t\t\t\t\tObject.assign(c, transformed)
`;
      S();
    }
    N.resolve();
  }
  if (j) {
    if (Q += `
`, j.headers) {
      if (r && "Clean" in j.headers && !j0(j.headers))
        Q += `c.headers = validator.headers.Clean(c.headers);
`;
      if (V0("default", j.headers.schema))
        for (let [N, _] of Object.entries(exports_value2.Default(j.headers.schema, {}))) {
          let A = typeof _ === "object" ? JSON.stringify(_) : typeof _ === "string" ? `'${_}'` : _;
          if (A !== undefined)
            Q += `c.headers['${N}'] ??= ${A}
`;
        }
      if (t(j.headers))
        Q += "if(isNotEmpty(c.headers)) {";
      if (Q += `if(validator.headers.Check(c.headers) === false) {
\t\t\t\t${L("headers")}
\t\t\t}`, S0(j.headers.schema))
        Q += `c.headers = validator.headers.Decode(c.headers)
`;
      if (t(j.headers))
        Q += "}";
    }
    if (j.params) {
      if (V0("default", j.params.schema))
        for (let [N, _] of Object.entries(exports_value2.Default(j.params.schema, {}))) {
          let A = typeof _ === "object" ? JSON.stringify(_) : typeof _ === "string" ? `'${_}'` : _;
          if (A !== undefined)
            Q += `c.params['${N}'] ??= ${A}
`;
        }
      if (Q += `if(validator.params.Check(c.params) === false) {
\t\t\t\t${L("params")}
\t\t\t}`, S0(j.params.schema))
        Q += `
c.params = validator.params.Decode(c.params)
`;
    }
    if (j.query) {
      if (r && "Clean" in j.query && !j0(j.query))
        Q += `c.query = validator.query.Clean(c.query);
`;
      if (V0("default", j.query.schema))
        for (let [N, _] of Object.entries(exports_value2.Default(j.query.schema, {}))) {
          let A = typeof _ === "object" ? JSON.stringify(_) : typeof _ === "string" ? `'${_}'` : _;
          if (A !== undefined)
            Q += `if(c.query['${N}'] === undefined) c.query['${N}'] = ${A}
`;
        }
      if (t(j.query))
        Q += "if(isNotEmpty(c.query)) {";
      if (Q += `if(validator.query.Check(c.query) === false) {
          \t\t${L("query")}
\t\t\t}`, S0(j.query.schema))
        Q += `
c.query = validator.query.Decode(Object.assign({}, c.query))
`;
      if (t(j.query))
        Q += "}";
    }
    if (j.body) {
      if (r && "Clean" in j.body && !j0(j.body))
        Q += `c.body = validator.body.Clean(c.body);
`;
      let N = S0(j.body.schema);
      if (N || t(j.body))
        Q += `
const isNotEmptyObject = c.body && (typeof c.body === "object" && isNotEmpty(c.body))
`;
      if (V0("default", j.body.schema)) {
        let _ = exports_value2.Default(j.body.schema, j.body.schema.type === "object" ? {} : undefined), A = typeof _ === "object" ? JSON.stringify(_) : typeof _ === "string" ? `'${_}'` : _;
        if (Q += `if(validator.body.Check(c.body) === false) {
\t\t\t\t\tif (typeof c.body === 'object') {
\t\t\t\t\t\tc.body = Object.assign(${A}, c.body)
\t\t\t\t\t} else { c.body = ${A} }`, t(j.body))
          Q += `
\t\t\t\t\t    if(isNotEmptyObject && validator.body.Check(c.body) === false) {
            \t\t\t\t${L("body")}
             \t\t\t}
                    }`;
        else
          Q += `
    \t\t\t\tif(validator.body.Check(c.body) === false) {
        \t\t\t\t${L("body")}
         \t\t\t}
                }`;
      } else if (t(j.body))
        Q += `if(isNotEmptyObject && validator.body.Check(c.body) === false) {
         \t\t\t${L("body")}
          \t\t}`;
      else
        Q += `if(validator.body.Check(c.body) === false) {
         \t\t\t${L("body")}
          \t\t}`;
      if (N)
        Q += `
if(isNotEmptyObject) c.body = validator.body.Decode(c.body)
`;
    }
    if (c(b?.schema?.properties ?? b?.schema?.schema ?? {})) {
      if (Q += `const cookieValue = {}
    \t\t\tfor(const [key, value] of Object.entries(c.cookie))
    \t\t\t\tcookieValue[key] = value.value
`, V0("default", b.schema))
        for (let [N, _] of Object.entries(exports_value2.Default(b.schema, {})))
          Q += `cookieValue['${N}'] = ${typeof _ === "object" ? JSON.stringify(_) : _}
`;
      if (t(j.cookie))
        Q += "if(isNotEmpty(c.cookie)) {";
      if (Q += `if(validator.cookie.Check(cookieValue) === false) {
\t\t\t\t${L("cookie", "cookieValue")}
\t\t\t}`, S0(j.cookie.schema))
        Q += `
for(const [key, value] of Object.entries(validator.cookie.Decode(cookieValue)))
\t\t\t\t\tc.cookie[key].value = value
`;
      if (t(j.cookie))
        Q += "}";
    }
  }
  if (J?.beforeHandle) {
    let N = R("beforeHandle", { total: J.beforeHandle.length }), _ = false;
    for (let A = 0;A < J.beforeHandle.length; A++) {
      let S = J.beforeHandle[A], C = N.resolveChild(S.fn.name), a = E0(S);
      if (S.subType === "resolve" || S.subType === "mapResolve") {
        if (!_)
          _ = true, Q += `
let resolved
`;
        if (Q += k(S) ? `resolved = await beforeHandle[${A}](c);
` : `resolved = beforeHandle[${A}](c);
`, S.subType === "mapResolve")
          Q += `if(resolved instanceof ElysiaCustomStatusResponse)
\t\t\t\t\t\tthrow resolved
\t\t\t\t\telse {
\t\t\t\t\t\tresolved.request = c.request
\t\t\t\t\t\tresolved.store = c.store
\t\t\t\t\t\tresolved.qi = c.qi
\t\t\t\t\t\tresolved.path = c.path
\t\t\t\t\t\tresolved.url = c.url
\t\t\t\t\t\tresolved.redirect = c.redirect
\t\t\t\t\t\tresolved.set = c.set
\t\t\t\t\t\tresolved.error = c.error

\t\t\t\t\t\tc = resolved
\t\t\t\t\t}`;
        else
          Q += `if(resolved instanceof ElysiaCustomStatusResponse)
\t\t\t\t\t\tthrow resolved
\t\t\t\t\telse
\t\t\t\t\t\tObject.assign(c, resolved)
`;
      } else if (!a)
        Q += k(S) ? `await beforeHandle[${A}](c);
` : `beforeHandle[${A}](c);
`, C();
      else {
        if (Q += k(S) ? `be = await beforeHandle[${A}](c);
` : `be = beforeHandle[${A}](c);
`, C("be"), Q += `if(be !== undefined) {
`, N.resolve(), J.afterHandle?.length) {
          R("handle", { name: B ? Y.name : undefined }).resolve();
          let u = R("afterHandle", { total: J.afterHandle.length });
          for (let G0 = 0;G0 < J.afterHandle.length; G0++) {
            let L0 = J.afterHandle[G0], E2 = E0(L0), q2 = u.resolveChild(L0.fn.name);
            if (Q += `c.response = be
`, !E2)
              Q += k(L0.fn) ? `await afterHandle[${G0}](c, be)
` : `afterHandle[${G0}](c, be)
`;
            else
              Q += k(L0.fn) ? `af = await afterHandle[${G0}](c)
` : `af = afterHandle[${G0}](c)
`, Q += `if(af !== undefined) { c.response = be = af }
`;
            q2("af");
          }
          u.resolve();
        }
        if (j.response)
          Q += f("be");
        let U0 = R("mapResponse", { total: J.mapResponse.length });
        if (J.mapResponse.length) {
          Q += `
c.response = be
`;
          for (let u = 0;u < J.mapResponse.length; u++) {
            let G0 = J.mapResponse[u], L0 = U0.resolveChild(G0.fn.name);
            Q += `
if(mr === undefined) {
\t\t\t\t\t\t\tmr = ${C0(G0) ? "await" : ""} onMapResponse[${u}](c)
\t\t\t\t\t\t\tif(mr !== undefined) be = c.response = mr
\t\t\t\t\t\t}
`, L0();
          }
        }
        U0.resolve(), Q += E, Q += `return mapEarlyResponse(${e} be, c.set ${s})}
`;
      }
    }
    N.resolve();
  }
  if (J?.afterHandle.length) {
    let N = R("handle", { name: B ? Y.name : undefined });
    if (J.afterHandle.length)
      Q += Y0 ? `let r = c.response = await ${U};
` : `let r = c.response = ${U};
`;
    else
      Q += Y0 ? `let r = await ${U};
` : `let r = ${U};
`;
    N.resolve();
    let _ = R("afterHandle", { total: J.afterHandle.length });
    for (let S = 0;S < J.afterHandle.length; S++) {
      let C = J.afterHandle[S], a = E0(C), H = _.resolveChild(C.fn.name);
      if (!a)
        Q += k(C.fn) ? `await afterHandle[${S}](c)
` : `afterHandle[${S}](c)
`, H();
      else if (Q += k(C.fn) ? `af = await afterHandle[${S}](c)
` : `af = afterHandle[${S}](c)
`, H("af"), j.response)
        Q += "if(af !== undefined) {", _.resolve(), Q += f("af"), Q += "c.response = af }";
      else
        Q += "if(af !== undefined) {", _.resolve(), Q += `c.response = af}
`;
    }
    if (_.resolve(), Q += `r = c.response
`, j.response)
      Q += f();
    Q += E;
    let A = R("mapResponse", { total: J.mapResponse.length });
    if (J.mapResponse.length)
      for (let S = 0;S < J.mapResponse.length; S++) {
        let C = J.mapResponse[S], a = A.resolveChild(C.fn.name);
        Q += `
mr = ${C0(C) ? "await" : ""} onMapResponse[${S}](c)
\t\t\t\tif(mr !== undefined) r = c.response = mr
`, a();
      }
    if (A.resolve(), r0)
      Q += `return mapResponse(${e} r, c.set ${s})
`;
    else
      Q += `return mapCompactResponse(${e} r ${s})
`;
  } else {
    let N = R("handle", { name: B ? Y.name : undefined });
    if (j.response || J.mapResponse.length) {
      if (Q += Y0 ? `let r = await ${U};
` : `let r = ${U};
`, N.resolve(), j.response)
        Q += f();
      R("afterHandle").resolve();
      let _ = R("mapResponse", { total: J.mapResponse.length });
      if (J.mapResponse.length) {
        Q += `
c.response = r
`;
        for (let A = 0;A < J.mapResponse.length; A++) {
          let S = J.mapResponse[A], C = _.resolveChild(S.fn.name);
          Q += `
if(mr === undefined) {
\t\t\t\t\t\tmr = ${C0(S) ? "await" : ""} onMapResponse[${A}](c)
    \t\t\t\t\tif(mr !== undefined) r = c.response = mr
\t\t\t\t\t}
`, C();
        }
      }
      if (_.resolve(), Q += E, Y instanceof Response)
        Q += K.set ? `if(
\t\t\t\t\tisNotEmpty(c.set.headers) ||
\t\t\t\t\tc.set.status !== 200 ||
\t\t\t\t\tc.set.redirect ||
\t\t\t\t\tc.set.cookie
\t\t\t\t)
\t\t\t\t\treturn mapResponse(${e} ${U}.clone(), c.set ${s})
\t\t\t\telse
\t\t\t\t\treturn ${U}.clone()` : `return ${U}.clone()`, Q += `
`;
      else if (r0)
        Q += `return mapResponse(${e} r, c.set ${s})
`;
      else
        Q += `return mapCompactResponse(${e} r ${s})
`;
    } else if (P || F) {
      Q += Y0 ? `let r = await ${U};
` : `let r = ${U};
`, N.resolve(), R("afterHandle").resolve();
      let _ = R("mapResponse", { total: J.mapResponse.length });
      if (J.mapResponse.length) {
        Q += `
c.response = r
`;
        for (let A = 0;A < J.mapResponse.length; A++) {
          let S = J.mapResponse[A], C = _.resolveChild(S.fn.name);
          Q += `
if(mr === undefined) {
\t\t\t\t\t\t\tmr = ${C0(S) ? "await" : ""} onMapResponse[${A}](c)
    \t\t\t\t\t\tif(mr !== undefined) r = c.response = mr
\t\t\t\t\t\t}
`, C();
        }
      }
      if (_.resolve(), Q += E, r0)
        Q += `return mapResponse(${e} r, c.set ${s})
`;
      else
        Q += `return mapCompactResponse(${e} r ${s})
`;
    } else {
      N.resolve();
      let _ = Y0 ? `await ${U}` : U;
      if (R("afterHandle").resolve(), Y instanceof Response)
        Q += K.set ? `if(
\t\t\t\t\tisNotEmpty(c.set.headers) ||
\t\t\t\t\tc.set.status !== 200 ||
\t\t\t\t\tc.set.redirect ||
\t\t\t\t\tc.set.cookie
\t\t\t\t)
\t\t\t\t\treturn mapResponse(${e} ${U}.clone(), c.set ${s})
\t\t\t\telse
\t\t\t\t\treturn ${U}.clone()` : `return ${U}.clone()`, Q += `
`;
      else if (r0)
        Q += `return mapResponse(${e} ${_}, c.set ${s})
`;
      else
        Q += `return mapCompactResponse(${e} ${_} ${s})
`;
    }
  }
  if (Q += `
} catch(error) {`, D)
    Q += `
if(isParsing) error = new ParseError()
`;
  if (!y0)
    Q += `
return (async () => {
`;
  if (Q += `
const set = c.set
if (!set.status || set.status < 300) set.status = error?.status || 500
`, F)
    for (let N = 0;N < J.trace.length; N++)
      Q += `report${N}?.resolve(error);reportChild${N}?.(error);
`;
  let K1 = R("error", { total: J.error.length });
  if (J.error.length) {
    Q += `
\t\t\t\tc.error = error
\t\t\t\tif(error instanceof TypeBoxError) {
\t\t\t\t\tc.code = "VALIDATION"
\t\t\t\t\tc.set.status = 422
\t\t\t\t} else
\t\t\t\t\tc.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
\t\t\t\tlet er
\t\t\t`;
    for (let N = 0;N < J.error.length; N++) {
      let _ = K1.resolveChild(J.error[N].fn.name);
      if (k(J.error[N]))
        Q += `
er = await handleErrors[${N}](c)
`;
      else
        Q += `
er = handleErrors[${N}](c)
if (er instanceof Promise) er = await er
`;
      _();
      let A = R("mapResponse", { total: J.mapResponse.length });
      if (J.mapResponse.length)
        for (let S = 0;S < J.mapResponse.length; S++) {
          let C = J.mapResponse[S], a = A.resolveChild(C.fn.name);
          Q += `
c.response = er

\t\t\t\t\t\t\ter = ${C0(C) ? "await" : ""} onMapResponse[${S}](c)
\t\t\t\t\t\t\tif(er instanceof Promise) er = await er
`, a();
        }
      if (A.resolve(), Q += `er = mapEarlyResponse(er, set ${s})
`, Q += "if (er) {", F) {
        for (let S = 0;S < J.trace.length; S++)
          Q += `
report${S}.resolve()
`;
        K1.resolve();
      }
      Q += `return er
}
`;
    }
  }
  if (K1.resolve(), Q += `return handleError(c, error, true)
`, !y0)
    Q += "})()";
  if (Q += "}", w || F) {
    if (Q += " finally { ", !y0)
      Q += ";(async () => {";
    let N = R("afterResponse", { total: J.afterResponse.length });
    if (w)
      for (let _ = 0;_ < J.afterResponse.length; _++) {
        let A = N.resolveChild(J.afterResponse[_].fn.name);
        Q += `
await afterResponse[${_}](c);
`, A();
      }
    if (N.resolve(), !y0)
      Q += "})();";
    Q += "}";
  }
  Q = `const {
\t\thandler,
\t\thandleError,
\t\thooks: {
\t\t\ttransform,
\t\t\tresolve,
\t\t\tbeforeHandle,
\t\t\tafterHandle,
\t\t\tmapResponse: onMapResponse,
\t\t\tparse,
\t\t\terror: handleErrors,
\t\t\tafterResponse,
\t\t\ttrace: _trace
\t\t},
\t\tvalidator,
\t\tutils: {
\t\t\tmapResponse,
\t\t\tmapCompactResponse,
\t\t\tmapEarlyResponse,
\t\t\tparseQuery,
\t\t\tparseQueryFromURL,
\t\t\tisNotEmpty
\t\t},
\t\terror: {
\t\t\tNotFoundError,
\t\t\tValidationError,
\t\t\tInternalServerError,
\t\t\tParseError
\t\t},
\t\tschema,
\t\tdefinitions,
\t\tERROR_CODE,
\t\tparseCookie,
\t\tsignCookie,
\t\tdecodeURIComponent,
\t\tElysiaCustomStatusResponse,
\t\tELYSIA_TRACE,
\t\tELYSIA_REQUEST_ID,
\t\tgetServer,
\t\tTypeBoxError
\t} = hooks

\tconst trace = _trace.map(x => typeof x === 'function' ? x : x.fn)

\treturn ${y0 ? "async" : ""} function handle(c) {
\t\t${J.beforeHandle.length ? "let be" : ""}
\t\t${J.afterHandle.length ? "let af" : ""}
\t\t${J.mapResponse.length ? "let mr" : ""}

\t\t${G ? "c.schema = schema; c.defs = definitions" : ""}
\t\t${Q}
\t}`;
  try {
    return Function("hooks", Q)({ handler: Y, hooks: L1(J), validator: j, handleError: $.handleError, utils: { mapResponse: x, mapCompactResponse: Z0, mapEarlyResponse: g, parseQuery: i0, parseQueryFromURL: G1, isNotEmpty: c }, error: { NotFoundError: A0, ValidationError: q, InternalServerError: Q1, ParseError: Y1 }, schema: $.router.history, definitions: $.definitions.type, ERROR_CODE: I0, parseCookie: e0, signCookie: x0, decodeURIComponent: O2.default, ElysiaCustomStatusResponse: l, ELYSIA_TRACE: n0, ELYSIA_REQUEST_ID: P0, getServer: () => $.getServer(), TypeBoxError });
  } catch {
    let N = L1(J);
    console.log("[Composer] failed to generate optimized handler"), console.log("Please report the following to SaltyAom privately as it may include sensitive information about your codebase:"), console.log("---"), console.log({ handler: typeof Y === "function" ? Y.toString() : Y, hooks: { ...N, transform: N?.transform?.map?.((_) => _.toString()), resolve: N?.resolve?.map?.((_) => _.toString()), beforeHandle: N?.beforeHandle?.map?.((_) => _.toString()), afterHandle: N?.afterHandle?.map?.((_) => _.toString()), mapResponse: N?.mapResponse?.map?.((_) => _.toString()), parse: N?.parse?.map?.((_) => _.toString()), error: N?.error?.map?.((_) => _.toString()), afterResponse: N?.afterResponse?.map?.((_) => _.toString()), stop: N?.stop?.map?.((_) => _.toString()) }, validator: j, definitions: $.definitions.type }), console.log("---"), process.exit(1);
  }
};
var b1 = ($) => {
  let W = $.config.handler?.standardHostname ?? true, X = "", Z = "", J = $.setHeaders;
  for (let D of Object.keys($.singleton.decorator))
    X += `,${D}: app.singleton.decorator.${D}`;
  let j = $.router, Y = $.event.trace.length > 0, G = `
\tconst route = router.find(request.method, path) ${j.http.root.ALL ? '?? router.find("ALL", path)' : ""}

\tif (route === null)
\t\treturn ${$.event.error.length ? "app.handleError(ctx, notFound)" : $.event.request.length ? `new Response(error404Message, {
\t\t\t\t\tstatus: ctx.set.status === 200 ? 404 : ctx.set.status,
\t\t\t\t\theaders: ctx.set.headers
\t\t\t\t})` : "error404.clone()"}

\tctx.params = route.params
`;
  G += `if(route.store.handler) return route.store.handler(ctx)
\treturn (route.store.handler = route.store.compile())(ctx)
`;
  let K = "";
  for (let [D, { code: z, all: I, static: O }] of Object.entries(j.static.http.map)) {
    if (O)
      K += `case '${D}':
switch(request.method) {
${z}
${I ?? "default: break map"}}

`;
    K += `case '${D}':
switch(request.method) {
${z}
${I ?? "default: break map"}}

`;
  }
  let B = $.event.request.some(k);
  if (Z += `const {
\t\tapp,
\t\tmapEarlyResponse,
\t\tNotFoundError,
\t\trandomId,
\t\thandleError,
\t\terror,
\t\tredirect,
\t\tELYSIA_TRACE,
\t\tELYSIA_REQUEST_ID,
\t\tgetServer
\t} = data

\tconst store = app.singleton.store
\tconst staticRouter = app.router.static.http
\tconst st = staticRouter.handlers
\tconst wsRouter = app.router.ws
\tconst router = app.router.http
\tconst trace = app.event.trace.map(x => typeof x === 'function' ? x : x.fn)

\tconst notFound = new NotFoundError()
\tconst hoc = app.extender.higherOrderFunctions.map(x => x.fn)

\t${$.event.request.length ? "const onRequest = app.event.request.map(x => x.fn)" : ""}
\t${$.event.error.length ? "" : `
const error404Message = notFound.message.toString()
\tconst error404 = new Response(error404Message, { status: 404 });
`}

\t${$.event.trace.length ? `const ${$.event.trace.map((D, z) => `tr${z} = app.event.trace[${z}].fn`).join(",")}` : ""}

\t${B ? "async" : ""} function map(request) {
`, $.event.request.length)
    Z += "let re";
  if (Z += `
const url = request.url
\t\tconst s = url.indexOf('/', ${W ? 11 : 7})
\t\tconst qi = url.indexOf('?', s + 1)
\t\tlet path
\t\tif(qi === -1)
\t\t\tpath = url.substring(s)
\t\telse
\t\t\tpath = url.substring(s, qi)
`, Z += `${Y ? "const id = randomId()" : ""}
\t\tconst ctx = {
\t\t\trequest,
\t\t\tstore,
\t\t\tqi,
\t\t\tpath,
\t\t\turl,
\t\t\tredirect,
\t\t\tset: {
\t\t\t\theaders: ${Object.keys(J ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
\t\t\t\tstatus: 200
\t\t\t},
\t\t\terror
\t\t\t${$.inference.server ? `, get server() {
\t\t\t\t\t\t\treturn getServer()
\t\t\t\t\t\t}` : ""}
\t\t\t${Y ? ",[ELYSIA_REQUEST_ID]: id" : ""}
\t\t\t${X}
\t\t}
`, $.event.trace.length)
    Z += `
ctx[ELYSIA_TRACE] = [${$.event.trace.map((D, z) => `tr${z}(ctx)`).join(",")}]
`;
  let w = R1({ context: "ctx", trace: $.event.trace, addFn(D) {
    Z += D;
  } })("request", { attribute: "ctx", total: $.event.request.length });
  if ($.event.request.length) {
    Z += `
 try {
`;
    for (let D = 0;D < $.event.request.length; D++) {
      let z = $.event.request[D], I = E0(z), O = k(z), P = w.resolveChild($.event.request[D].fn.name);
      if (I)
        Z += `re = mapEarlyResponse(
\t\t\t\t\t${O ? "await" : ""} onRequest[${D}](ctx),
\t\t\t\t\tctx.set,
\t\t\t\t\trequest
\t\t\t\t)
`, P("re"), Z += `if(re !== undefined) return re
`;
      else
        Z += `${O ? "await" : ""} onRequest[${D}](ctx)
`, P();
    }
    Z += `} catch (error) {
\t\t\treturn app.handleError(ctx, error)
\t\t}`;
  }
  w.resolve();
  let F = $.router.static.ws, Q = $.router.ws;
  if (Object.keys(F).length || Q.history.length) {
    Z += `
\t\t\tif(request.method === 'GET') {
\t\t\t\tswitch(path) {`;
    for (let [D, z] of Object.entries(F))
      Z += `
\t\t\t\t\tcase '${D}':
\t\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket')
\t\t\t\t\t\t\treturn st[${z}](ctx)

\t\t\t\t\t\tbreak`;
    Z += `
\t\t\t\tdefault:
\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket') {
\t\t\t\t\t\tconst route = wsRouter.find('ws', path)

\t\t\t\t\t\tif(route) {
\t\t\t\t\t\t\tctx.params = route.params

\t\t\t\t\t\t\tif(route.store.handler)
\t\t\t\t\t\t\t    return route.store.handler(ctx)

\t\t\t\t\t\t\treturn (route.store.handler = route.store.compile())(ctx)
\t\t\t\t\t\t}
\t\t\t\t\t}

\t\t\t\t\tbreak
\t\t\t}
\t\t}
`;
  }
  if (Z += `
\t\tmap: switch(path) {
\t\t\t${K}

\t\t\tdefault:
\t\t\t\tbreak
\t\t}

\t\t${G}
\t}
`, $.extender.higherOrderFunctions.length) {
    let D = "map";
    for (let z = 0;z < $.extender.higherOrderFunctions.length; z++)
      D = `hoc[${z}](${D}, request)`;
    Z += `return function hocMap(request) { return ${D}(request) }`;
  } else
    Z += "return map";
  let M = x1($);
  return $.handleError = M, Function("data", Z)({ app: $, mapEarlyResponse: g, NotFoundError: A0, randomId: J1, handleError: M, error: T1, redirect: c0, ELYSIA_TRACE: n0, ELYSIA_REQUEST_ID: P0, getServer: () => $.getServer() });
};
var x1 = ($) => {
  let W = $.event, X = "";
  X += `const {
\t\tapp: { event: { error: onErrorContainer, afterResponse: resContainer, mapResponse: _onMapResponse, trace: _trace } },
\t\tmapResponse,
\t\tERROR_CODE,
\t\tElysiaCustomStatusResponse,
\t\tELYSIA_TRACE,
\t\tELYSIA_REQUEST_ID
\t} = inject

\tconst trace = _trace.map(x => typeof x === 'function' ? x : x.fn)
\tconst onMapResponse = []

\tfor(let i = 0; i < _onMapResponse.length; i++)
\t\tonMapResponse.push(_onMapResponse[i].fn ?? _onMapResponse[i])

\tdelete _onMapResponse

\tconst onError = onErrorContainer.map(x => x.fn)
\tconst res = resContainer.map(x => x.fn)

\treturn ${$.event.error.find(k) || $.event.mapResponse.find(k) ? "async" : ""} function(context, error, skipGlobal) {`;
  let Z = $.event.trace.length > 0;
  if (Z)
    X += `
const id = context[ELYSIA_REQUEST_ID]
`;
  let J = R1({ context: "context", trace: W.trace, addFn: (G) => {
    X += G;
  } });
  X += `
\t\tconst set = context.set
\t\tlet r

\t\tif(!context.code)
\t\t\tcontext.code = error.code ?? error[ERROR_CODE]

\t\tif(!(context.error instanceof Error))
\t\t\tcontext.error = error

\t\tif(error instanceof ElysiaCustomStatusResponse) {
\t\t\terror.status = error.code
\t\t\terror.message = error.response
\t\t}
`;
  let j = Z || W.afterResponse.length > 0 || W.afterResponse.length > 0 ? "context.response = " : "";
  for (let G = 0;G < $.event.error.length; G++) {
    let K = $.event.error[G], B = `${k(K) ? "await " : ""}onError[${G}](context)`;
    if (X += `
if(skipGlobal !== true) {
`, E0(K)) {
      X += `r = ${B}; if(r !== undefined) {
\t\t\t\tif(r instanceof Response) return r

\t\t\t\tif(r instanceof ElysiaCustomStatusResponse) {
\t\t\t\t\terror.status = error.code
\t\t\t\t\terror.message = error.response
\t\t\t\t}

\t\t\t\tif(set.status === 200) set.status = error.status
`;
      let U = J("mapResponse", { total: W.mapResponse.length, name: "context" });
      if (W.mapResponse.length)
        for (let w = 0;w < W.mapResponse.length; w++) {
          let F = W.mapResponse[w], Q = U.resolveChild(F.fn.name);
          X += `
context.response = r
\t\t\t\t\t\tr = ${C0(F) ? "await" : ""} onMapResponse[${w}](context)
`, Q();
        }
      U.resolve(), X += `return mapResponse(${j} r, set, context.request)}
`;
    } else
      X += B + `
`;
    X += `
}
`;
  }
  X += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
\t    const reportedError = error.error ?? error
\t\tset.status = reportedError.status ?? 422
\t\treturn new Response(
\t\t\treportedError.message,
\t\t\t{
\t\t\t\theaders: Object.assign(
\t\t\t\t\t{ 'content-type': 'application/json'},
\t\t\t\t\tset.headers
\t\t\t\t),
\t\t\t\tstatus: set.status
\t\t\t}
\t\t)
\t} else {
\t\tif(error.code && typeof error.status === "number")
\t\t\treturn new Response(
\t\t\t\terror.message,
\t\t\t\t{ headers: set.headers, status: error.status }
\t\t\t)
`;
  let Y = J("mapResponse", { total: W.mapResponse.length, name: "context" });
  if (W.mapResponse.length)
    for (let G = 0;G < W.mapResponse.length; G++) {
      let K = W.mapResponse[G], B = Y.resolveChild(K.fn.name);
      X += `
context.response = error
\t\t\terror = ${C0(K) ? "await" : ""} onMapResponse[${G}](context)
`, B();
    }
  return Y.resolve(), X += `
return mapResponse(${j} error, set, context.request)
}
}`, Function("inject", X)({ app: $, mapResponse: x, ERROR_CODE: I0, ElysiaCustomStatusResponse: l, ELYSIA_TRACE: n0, ELYSIA_REQUEST_ID: P0 });
};
var g1 = ($) => async (W) => {
  let X = W.url, Z = X.indexOf("/", 11), J = X.indexOf("?", Z + 1), j = J === -1 ? X.substring(Z) : X.substring(Z, J), Y = { cookie: {}, status: 200, headers: {} }, G = Object.assign({}, $.singleton.decorator, { set: Y, store: $.singleton.store, request: W, path: j, qi: J, redirect: c0 });
  try {
    for (let I = 0;I < $.event.request.length; I++) {
      let O = $.event.request[I].fn, P = O(G);
      if (P instanceof Promise)
        P = await P;
      if (P = g(P, Y), P)
        return G.response = P;
    }
    let K = $.router.dynamic.find(W.method, j) ?? $.router.dynamic.find("ALL", j);
    if (!K)
      throw new A0;
    let { handle: B, hooks: U, validator: w, content: F } = K.store, Q;
    if (W.method !== "GET" && W.method !== "HEAD")
      if (F)
        switch (F) {
          case "application/json":
            Q = await W.json();
            break;
          case "text/plain":
            Q = await W.text();
            break;
          case "application/x-www-form-urlencoded":
            Q = i0(await W.text());
            break;
          case "application/octet-stream":
            Q = await W.arrayBuffer();
            break;
          case "multipart/form-data":
            Q = {};
            let I = await W.formData();
            for (let O of I.keys()) {
              if (Q[O])
                continue;
              let P = I.getAll(O);
              if (P.length === 1)
                Q[O] = P[0];
              else
                Q[O] = P;
            }
            break;
        }
      else {
        let I = W.headers.get("content-type");
        if (I) {
          let O = I.indexOf(";");
          if (O !== -1)
            I = I.slice(0, O);
          G.contentType = I;
          for (let P = 0;P < U.parse.length; P++) {
            let b = U.parse[P].fn, T = b(G, I);
            if (T instanceof Promise)
              T = await T;
            if (T) {
              Q = T;
              break;
            }
          }
          if (delete G.contentType, Q === undefined)
            switch (I) {
              case "application/json":
                Q = await W.json();
                break;
              case "text/plain":
                Q = await W.text();
                break;
              case "application/x-www-form-urlencoded":
                Q = i0(await W.text());
                break;
              case "application/octet-stream":
                Q = await W.arrayBuffer();
                break;
              case "multipart/form-data":
                Q = {};
                let P = await W.formData();
                for (let b of P.keys()) {
                  if (Q[b])
                    continue;
                  let T = P.getAll(b);
                  if (T.length === 1)
                    Q[b] = T[0];
                  else
                    Q[b] = T;
                }
                break;
            }
        }
      }
    G.body = Q, G.params = K?.params || undefined, G.query = J === -1 ? {} : G1(X.substring(J + 1)), G.headers = {};
    for (let [I, O] of W.headers.entries())
      G.headers[I] = O;
    let M = Object.assign({}, $.config?.cookie, w?.cookie?.config), D = W.headers.get("cookie");
    G.cookie = await e0(G.set, D, M ? { secrets: M.secrets !== undefined ? typeof M.secrets === "string" ? M.secrets : M.secrets.join(",") : undefined, sign: M.sign === true ? true : M.sign !== undefined ? typeof M.sign === "string" ? M.sign : M.sign.join(",") : undefined } : undefined);
    for (let I = 0;I < U.transform.length; I++) {
      let O = U.transform[I], P = O.fn(G);
      if (O.subType === "derive")
        if (P instanceof Promise)
          Object.assign(G, await P);
        else
          Object.assign(G, P);
      else if (P instanceof Promise)
        await P;
    }
    if (w) {
      if (w.createHeaders?.()) {
        let I = {};
        for (let O in W.headers)
          I[O] = W.headers.get(O);
        if (w.headers.Check(I) === false)
          throw new q("header", w.headers, I);
      } else if (w.headers?.Decode)
        G.headers = w.headers.Decode(G.headers);
      if (w.createParams?.()?.Check(G.params) === false)
        throw new q("params", w.params, G.params);
      else if (w.params?.Decode)
        G.params = w.params.Decode(G.params);
      if (w.createQuery?.()?.Check(G.query) === false)
        throw new q("query", w.query, G.query);
      else if (w.query?.Decode)
        G.query = w.query.Decode(G.query);
      if (w.createCookie?.()) {
        let I = {};
        for (let [O, P] of Object.entries(G.cookie))
          I[O] = P.value;
        if (w.cookie.Check(I) === false)
          throw new q("cookie", w.cookie, I);
        else if (w.cookie?.Decode)
          I = w.cookie.Decode(I);
      }
      if (w.createBody?.()?.Check(Q) === false)
        throw new q("body", w.body, Q);
      else if (w.body?.Decode)
        G.body = w.body.Decode(Q);
    }
    for (let I = 0;I < U.beforeHandle.length; I++) {
      let O = U.beforeHandle[I], P = O.fn(G);
      if (O.subType === "resolve") {
        if (P instanceof Promise)
          Object.assign(G, await P);
        else
          Object.assign(G, P);
        continue;
      } else if (P instanceof Promise)
        P = await P;
      if (P !== undefined) {
        G.response = P;
        for (let T = 0;T < U.afterHandle.length; T++) {
          let E = U.afterHandle[T].fn(G);
          if (E instanceof Promise)
            E = await E;
          if (E)
            P = E;
        }
        let b = g(P, G.set);
        if (b)
          return G.response = b;
      }
    }
    let z = B(G);
    if (z instanceof Promise)
      z = await z;
    if (!U.afterHandle.length) {
      let I = z instanceof l ? z.code : Y.status ? typeof Y.status === "string" ? _0[Y.status] : Y.status : 200, O = w?.createResponse?.()?.[I];
      if (O?.Check(z) === false)
        throw new q("response", O, z);
      else if (O?.Decode)
        z = O.Decode(z);
    } else {
      G.response = z;
      for (let I = 0;I < U.afterHandle.length; I++) {
        let O = U.afterHandle[I].fn(G);
        if (O instanceof Promise)
          O = await O;
        let P = g(O, G.set);
        if (P !== undefined) {
          let b = w?.response?.[P.status];
          if (b?.Check(P) === false)
            throw new q("response", b, P);
          else if (b?.Decode)
            z = b.Decode(z);
          return G.response = P;
        }
      }
    }
    if (G.set.cookie && M?.sign) {
      let I = !M.secrets ? undefined : typeof M.secrets === "string" ? M.secrets : M.secrets[0];
      if (M.sign === true)
        for (let [O, P] of Object.entries(G.set.cookie))
          G.set.cookie[O].value = await x0(P.value, "${secret}");
      else {
        let O = w?.cookie?.schema?.properties;
        for (let P of M.sign) {
          if (!(P in O))
            continue;
          if (G.set.cookie[P]?.value)
            G.set.cookie[P].value = await x0(G.set.cookie[P].value, I);
        }
      }
    }
    return G.response = x(z, G.set);
  } catch (K) {
    let B = K instanceof TransformDecodeError && K.error ? K.error : K;
    if (B.status)
      Y.status = B.status;
    return $.handleError(G, B);
  } finally {
    for (let K of $.event.afterResponse)
      await K.fn(G);
  }
};
var C2 = ($) => async (W, X) => {
  let Z = Object.assign(W, { error: X, code: X.code });
  Z.set = W.set;
  for (let J = 0;J < $.event.error.length; J++) {
    let Y = $.event.error[J].fn(Z);
    if (Y instanceof Promise)
      Y = await Y;
    if (Y !== undefined && Y !== null)
      return W.response = x(Y, W.set);
  }
  return new Response(typeof X.cause === "string" ? X.cause : X.message, { headers: W.set.headers, status: X.status ?? 500 });
};

class Q0 {
  config;
  server = null;
  dependencies = {};
  _routes = {};
  _types = { Prefix: "", Scoped: false, Singleton: {}, Definitions: {}, Metadata: {} };
  _ephemeral = {};
  _volatile = {};
  static version = q1;
  version = q1;
  singleton = { decorator: {}, store: {}, derive: {}, resolve: {} };
  get store() {
    return this.singleton.store;
  }
  get decorator() {
    return this.singleton.decorator;
  }
  get _scoped() {
    return this.config.scoped;
  }
  definitions = { type: {}, error: {} };
  extender = { macros: [], higherOrderFunctions: [] };
  validator = { global: null, scoped: null, local: null, getCandidate() {
    return b0(b0(this.global, this.scoped), this.local);
  } };
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], mapResponse: [], afterResponse: [], trace: [], error: [], stop: [] };
  telemetry = { stack: undefined };
  router = { http: new z0, ws: new z0, dynamic: new z0, static: { http: { static: {}, handlers: [], map: {}, all: "" }, ws: {} }, history: [] };
  routeTree = new Map;
  get routes() {
    return this.router.history;
  }
  getGlobalRoutes() {
    return this.router.history;
  }
  inference = { body: false, cookie: false, headers: false, query: false, set: false, server: false };
  getServer() {
    return this.server;
  }
  _promisedModules;
  get promisedModules() {
    if (!this._promisedModules)
      this._promisedModules = new C1;
    return this._promisedModules;
  }
  constructor($ = {}) {
    if ($.tags)
      if (!$.detail)
        $.detail = { tags: $.tags };
      else
        $.detail.tags = $.tags;
    if ($.nativeStaticResponse === undefined)
      $.nativeStaticResponse = true;
    if (this.config = {}, this.applyConfig($ ?? {}), $?.analytic && ($?.name || $?.seed !== undefined))
      this.telemetry.stack = new Error().stack;
  }
  env($, W = Bun?.env ?? process.env) {
    if (m($, { dynamic: true, additionalProperties: true, coerce: true }).Check(W) === false) {
      let Z = new q("env", $, W);
      throw new Error(Z.all.map((J) => J.summary).join(`
`));
    }
    return this;
  }
  wrap($) {
    return this.extender.higherOrderFunctions.push({ checksum: N0(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: $.toString() })), fn: $ }), this;
  }
  applyMacro($) {
    if (this.extender.macros.length) {
      let W = N2({ globalHook: this.event, localHook: $ }), X = { events: { global: this.event, local: $ }, onParse: W("parse"), onTransform: W("transform"), onBeforeHandle: W("beforeHandle"), onAfterHandle: W("afterHandle"), mapResponse: W("mapResponse"), onAfterResponse: W("afterResponse"), onError: W("error") };
      for (let Z of this.extender.macros)
        D2(Z.fn(X), $);
    }
  }
  applyConfig($) {
    return this.config = { prefix: "", aot: true, strictPath: false, global: false, analytic: false, normalize: true, ...$, cookie: { path: "/", ...$?.cookie }, experimental: $?.experimental ?? {}, seed: $?.seed === undefined ? "" : $?.seed }, this;
  }
  get models() {
    let $ = {};
    for (let [W, X] of Object.entries(this.definitions.type))
      $[W] = m(X);
    return $;
  }
  add($, W, X, Z, { allowMeta: J = false, skipPrefix: j = false } = { allowMeta: false, skipPrefix: false }) {
    if (Z = P2(Z), W !== "" && W.charCodeAt(0) !== 47)
      W = "/" + W;
    if (this.config.prefix && !j && !this.config.scoped)
      W = this.config.prefix + W;
    if (Z?.type)
      switch (Z.type) {
        case "text":
          Z.type = "text/plain";
          break;
        case "json":
          Z.type = "application/json";
          break;
        case "formdata":
          Z.type = "multipart/form-data";
          break;
        case "urlencoded":
          Z.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          Z.type = "application/octet-stream";
          break;
        default:
          break;
      }
    let Y = this.definitions.type, G = !this.config.aot, K = { ...this.validator.getCandidate() }, B = { body: Z?.body ?? K?.body, headers: Z?.headers ?? K?.headers, params: Z?.params ?? K?.params, query: Z?.query ?? K?.query, cookie: Z?.cookie ?? K?.cookie, response: Z?.response ?? K?.response }, U = () => B.cookie ? W1({ validator: B.cookie, defaultConfig: this.config.cookie, config: B.cookie?.config ?? {}, dynamic: G, models: Y }) : undefined, w = this.config.normalize, F = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.schema === true ? { body: m(B.body, { dynamic: G, models: Y, normalize: w, additionalCoerce: O1() }), headers: m(B.headers, { dynamic: G, models: Y, additionalProperties: !this.config.normalize, coerce: true, additionalCoerce: D0() }), params: m(B.params, { dynamic: G, models: Y, coerce: true, additionalCoerce: D0() }), query: m(B.query, { dynamic: G, models: Y, normalize: w, coerce: true, additionalCoerce: D0() }), cookie: U(), response: $1(B.response, { dynamic: G, models: Y, normalize: w }) } : { createBody() {
      if (this.body)
        return this.body;
      return this.body = m(B.body, { dynamic: G, models: Y, normalize: w, additionalCoerce: O1() });
    }, createHeaders() {
      if (this.headers)
        return this.headers;
      return this.headers = m(B.headers, { dynamic: G, models: Y, additionalProperties: !w, coerce: true, additionalCoerce: D0() });
    }, createParams() {
      if (this.params)
        return this.params;
      return this.params = m(B.params, { dynamic: G, models: Y, coerce: true, additionalCoerce: D0() });
    }, createQuery() {
      if (this.query)
        return this.query;
      return this.query = m(B.query, { dynamic: G, models: Y, coerce: true, additionalCoerce: D0() });
    }, createCookie() {
      if (this.cookie)
        return this.cookie;
      return this.cookie = U();
    }, createResponse() {
      if (this.response)
        return this.response;
      return this.response = $1(B.response, { dynamic: G, models: Y, normalize: w });
    } }, Q = W.endsWith("/") ? W.slice(0, W.length - 1) : W + "/";
    if (Z = i(Z, K), Z.tags)
      if (!Z.detail)
        Z.detail = { tags: Z.tags };
      else
        Z.detail.tags = Z.tags;
    if (c(this.config.detail))
      Z.detail = d(Object.assign({}, this.config.detail), Z.detail);
    this.applyMacro(Z);
    let M = i(this.event, Z);
    if (this.config.aot === false) {
      if (this.router.dynamic.add($, W, { validator: F, hooks: M, content: Z?.type, handle: X }), this.config.strictPath === false)
        this.router.dynamic.add($, Q, { validator: F, hooks: M, content: Z?.type, handle: X });
      this.router.history.push({ method: $, path: W, composed: null, handler: X, hooks: M });
      return;
    }
    let D = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true, z = d0(this.inference), I = typeof X !== "function" ? K2(X, M, this.setHeaders) : undefined, O = typeof X !== "function" ? U2(X, M, this.setHeaders) : undefined;
    if (this.config.nativeStaticResponse === true && O && ($ === "GET" || $ === "ALL"))
      this.router.static.http.static[W] = O();
    let P = () => S2({ app: this, path: W, method: $, localHook: i(Z), hooks: M, validator: F, handler: X, allowMeta: J, inference: z }), b = D ? P() : (L) => {
      return P()(L);
    }, T = this.router.history.length;
    if (this.routeTree.has($ + W))
      for (let L = 0;L < this.router.history.length; L++) {
        let f = this.router.history[L];
        if (f.path === W && f.method === $) {
          let R = this.router.history.splice(L, 1)[0];
          if (R && this.routeTree.has(R?.method + R?.path))
            this.routeTree.delete(R.method + R.path);
        }
      }
    else
      this.routeTree.set($ + W, T);
    this.router.history.push({ method: $, path: W, composed: b, handler: X, hooks: M });
    let E = this.router.static.http, r = { handler: D ? b : undefined, compile: P };
    if ($ === "$INTERNALWS") {
      let L = this.config.strictPath ? undefined : W.endsWith("/") ? W.slice(0, W.length - 1) : W + "/";
      if (W.indexOf(":") === -1 && W.indexOf("*") === -1) {
        let f = E.handlers.length;
        if (E.handlers.push((R) => (E.handlers[f] = P())(R)), this.router.static.ws[W] = f, L)
          this.router.static.ws[L] = f;
      } else if (this.router.ws.add("ws", W, r), L)
        this.router.ws.add("ws", L, r);
      return;
    }
    if (W.indexOf(":") === -1 && W.indexOf("*") === -1) {
      let L = E.handlers.length;
      if (E.handlers.push(I ?? ((R) => (E.handlers[L] = P())(R))), !E.map[W])
        E.map[W] = { code: "" };
      let f = I ? "" : "ctx";
      if ($ === "ALL")
        E.map[W].all = `default: return st[${L}](${f})
`;
      else
        E.map[W].code = `case '${$}': return st[${L}](${f})
${E.map[W].code}`;
      if (!this.config.strictPath) {
        if (!E.map[Q])
          E.map[Q] = { code: "" };
        if (this.config.nativeStaticResponse === true && O && ($ === "GET" || $ === "ALL"))
          this.router.static.http.static[Q] = O();
        if ($ === "ALL")
          E.map[Q].all = `default: return st[${L}](${f})
`;
        else
          E.map[Q].code = `case '${$}': return st[${L}](${f})
${E.map[Q].code}`;
      }
    } else if (this.router.http.add($, W, r), !this.config.strictPath) {
      let L = W.endsWith("/") ? W.slice(0, W.length - 1) : W + "/";
      if (this.config.nativeStaticResponse === true && I && ($ === "GET" || $ === "ALL"))
        this.router.static.http.static[L] = I();
      this.router.http.add($, L, r);
    }
  }
  setHeaders;
  headers($) {
    if (!$)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    return this.setHeaders = d(this.setHeaders, $), this;
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($, W) {
    if (!W)
      return this.on("parse", $);
    return this.on($, "parse", W);
  }
  onTransform($, W) {
    if (!W)
      return this.on("transform", $);
    return this.on($, "transform", W);
  }
  resolve($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    let X = { subType: "resolve", fn: W };
    return this.onBeforeHandle($, X);
  }
  mapResolve($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    let X = { subType: "mapResolve", fn: W };
    return this.onBeforeHandle($, X);
  }
  onBeforeHandle($, W) {
    if (!W)
      return this.on("beforeHandle", $);
    return this.on($, "beforeHandle", W);
  }
  onAfterHandle($, W) {
    if (!W)
      return this.on("afterHandle", $);
    return this.on($, "afterHandle", W);
  }
  mapResponse($, W) {
    if (!W)
      return this.on("mapResponse", $);
    return this.on($, "mapResponse", W);
  }
  onAfterResponse($, W) {
    if (!W)
      return this.on("afterResponse", $);
    return this.on($, "afterResponse", W);
  }
  trace($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    if (!Array.isArray(W))
      W = [W];
    for (let X of W)
      this.on($, "trace", A2(X));
    return this;
  }
  error($, W) {
    switch (typeof $) {
      case "string":
        return W.prototype[I0] = $, this.definitions.error[$] = W, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [X, Z] of Object.entries($))
      Z.prototype[I0] = X, this.definitions.error[X] = Z;
    return this;
  }
  onError($, W) {
    if (!W)
      return this.on("error", $);
    return this.on($, "error", W);
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, W, X) {
    let Z;
    switch (typeof $) {
      case "string":
        Z = $, X = W;
        break;
      case "object":
        if (Z = W, !Array.isArray(W) && typeof W === "object")
          X = W;
        break;
    }
    if (Array.isArray(X))
      X = n(X);
    else if (typeof X === "function")
      X = [{ fn: X }];
    else
      X = [X];
    let J = X;
    for (let j of J)
      j.scope = typeof $ === "string" ? "local" : $?.as ?? "local";
    if (Z !== "trace")
      s0({ [Z]: J.map((j) => j.fn) }, this.inference);
    for (let j of J) {
      let Y = M2(j, "global", { skipIfHasType: true });
      switch (Z) {
        case "start":
          this.event.start.push(Y);
          break;
        case "request":
          this.event.request.push(Y);
          break;
        case "parse":
          this.event.parse.push(Y);
          break;
        case "transform":
          this.event.transform.push(Y);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(Y);
          break;
        case "afterHandle":
          this.event.afterHandle.push(Y);
          break;
        case "mapResponse":
          this.event.mapResponse.push(Y);
          break;
        case "afterResponse":
          this.event.afterResponse.push(Y);
          break;
        case "trace":
          this.event.trace.push(Y);
          break;
        case "error":
          this.event.error.push(Y);
          break;
        case "stop":
          this.event.stop.push(Y);
          break;
      }
    }
    return this;
  }
  propagate() {
    return v(this.event.parse), v(this.event.transform), v(this.event.beforeHandle), v(this.event.afterHandle), v(this.event.mapResponse), v(this.event.afterResponse), v(this.event.trace), v(this.event.error), this;
  }
  as($) {
    let W = { plugin: "scoped", global: "global" }[$];
    if (v(this.event.parse, W), v(this.event.transform, W), v(this.event.beforeHandle, W), v(this.event.afterHandle, W), v(this.event.mapResponse, W), v(this.event.afterResponse, W), v(this.event.trace, W), v(this.event.error, W), $ === "plugin")
      this.validator.scoped = b0(this.validator.scoped, this.validator.local), this.validator.local = null;
    else if ($ === "global")
      this.validator.global = b0(this.validator.global, b0(this.validator.scoped, this.validator.local)), this.validator.scoped = null, this.validator.local = null;
    return this;
  }
  group($, W, X) {
    let Z = new Q0({ ...this.config, prefix: "" });
    Z.singleton = { ...this.singleton }, Z.definitions = { ...this.definitions }, Z.getServer = () => this.getServer(), Z.inference = d0(this.inference), Z.extender = { ...this.extender };
    let J = typeof W === "object", j = (J ? X : W)(Z);
    if (this.singleton = d(this.singleton, Z.singleton), this.definitions = d(this.definitions, Z.definitions), j.event.request.length)
      this.event.request = [...this.event.request || [], ...j.event.request || []];
    if (j.event.mapResponse.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...j.event.mapResponse || []];
    return this.model(j.definitions.type), Object.values(Z.router.history).forEach(({ method: Y, path: G, handler: K, hooks: B }) => {
      if (G = (J ? "" : this.config.prefix) + $ + G, J) {
        let U = W, w = B;
        this.add(Y, G, K, i(U, { ...w || {}, error: !w.error ? j.event.error : Array.isArray(w.error) ? [...w.error || {}, ...j.event.error || {}] : [w.error, ...j.event.error || {}] }));
      } else
        this.add(Y, G, K, i(B, { error: j.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, W) {
    if (!W) {
      if (typeof $ === "object") {
        this.applyMacro($);
        let J = $.as ?? "local";
        if (this.validator[J] = { body: $.body ?? this.validator[J]?.body, headers: $.headers ?? this.validator[J]?.headers, params: $.params ?? this.validator[J]?.params, query: $.query ?? this.validator[J]?.query, response: $.response ?? this.validator[J]?.response, cookie: $.cookie ?? this.validator[J]?.cookie }, $.parse)
          this.on({ as: J }, "parse", $.parse);
        if ($.transform)
          this.on({ as: J }, "transform", $.transform);
        if ($.beforeHandle)
          this.on({ as: J }, "beforeHandle", $.beforeHandle);
        if ($.afterHandle)
          this.on({ as: J }, "afterHandle", $.afterHandle);
        if ($.mapResponse)
          this.on({ as: J }, "mapResponse", $.mapResponse);
        if ($.afterResponse)
          this.on({ as: J }, "afterResponse", $.afterResponse);
        if ($.error)
          this.on({ as: J }, "error", $.error);
        if ($.detail)
          if (this.config.detail)
            this.config.detail = d(Object.assign({}, this.config.detail), $.detail);
          else
            this.config.detail = $.detail;
        if ($?.tags)
          if (!this.config.detail)
            this.config.detail = { tags: $.tags };
          else
            this.config.detail.tags = $.tags;
        return this;
      }
      return this.guard({}, $);
    }
    let X = new Q0({ ...this.config, prefix: "" });
    X.singleton = { ...this.singleton }, X.definitions = { ...this.definitions }, X.inference = d0(this.inference), X.extender = { ...this.extender };
    let Z = W(X);
    if (this.singleton = d(this.singleton, X.singleton), this.definitions = d(this.definitions, X.definitions), Z.getServer = () => this.server, Z.event.request.length)
      this.event.request = [...this.event.request || [], ...Z.event.request || []];
    if (Z.event.mapResponse.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...Z.event.mapResponse || []];
    return this.model(Z.definitions.type), Object.values(X.router.history).forEach(({ method: J, path: j, handler: Y, hooks: G }) => {
      this.add(J, j, Y, i($, { ...G || {}, error: !G.error ? Z.event.error : Array.isArray(G.error) ? [...G.error || {}, ...Z.event.error || []] : [G.error, ...Z.event.error || []] }));
    }), this;
  }
  use($, W) {
    if (W?.scoped)
      return this.guard({}, (X) => X.use($));
    if (Array.isArray($)) {
      let X = this;
      for (let Z of $)
        X = this.use(Z);
      return X;
    }
    if ($ instanceof Promise)
      return this.promisedModules.add($.then((X) => {
        if (typeof X === "function")
          return X(this);
        if (X instanceof Q0)
          return this._use(X).compile();
        if (typeof X.default === "function")
          return X.default(this);
        if (X.default instanceof Q0)
          return this._use(X.default);
        throw new Error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.');
      }).then((X) => X.compile())), this;
    return this._use($);
  }
  _use($) {
    if (typeof $ === "function") {
      let J = $(this);
      if (J instanceof Promise)
        return this.promisedModules.add(J.then((j) => {
          if (j instanceof Q0) {
            j.getServer = () => this.getServer(), j.getGlobalRoutes = () => this.getGlobalRoutes(), j.model(this.definitions.type), j.error(this.definitions.error);
            for (let { method: Y, path: G, handler: K, hooks: B } of Object.values(j.router.history))
              this.add(Y, G, K, i(B, { error: j.event.error }));
            return j.compile(), j;
          }
          if (typeof j === "function")
            return j(this);
          if (typeof j.default === "function")
            return j.default(this);
          return this._use(j);
        }).then((j) => j.compile())), this;
      return J;
    }
    let { name: W, seed: X } = $.config;
    $.getServer = () => this.getServer(), $.getGlobalRoutes = () => this.getGlobalRoutes(), $.model(this.definitions.type), $.error(this.definitions.error);
    let Z = $.config.scoped;
    if (Z) {
      if (W) {
        if (!(W in this.dependencies))
          this.dependencies[W] = [];
        let j = X !== undefined ? N0(W + JSON.stringify(X)) : 0;
        if (this.dependencies[W].some(({ checksum: Y }) => j === Y))
          return this;
        this.dependencies[W].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: j, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: j, dependencies: $.dependencies, stack: $.telemetry.stack, routes: $.router.history, decorators: $.singleton.decorator, store: $.singleton.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((Y) => Y.subType === "derive").map((Y) => ({ fn: Y.fn.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((Y) => Y.subType === "derive").map((Y) => ({ fn: Y.fn.toString(), stack: new Error().stack ?? "" })) });
      }
      $.extender.macros = this.extender.macros.concat($.extender.macros);
      let J = [];
      for (let j = 0;j < $.extender.macros.length; j++) {
        let Y = this.extender.macros[j];
        if (J.includes(Y.checksum))
          $.extender.macros.splice(j, 1), j--;
        J.push(Y.checksum);
      }
      if ($.onRequest((j) => {
        Object.assign(j, this.singleton.decorator), Object.assign(j.store, this.singleton.store);
      }), $.event.trace.length)
        $.event.trace.push(...$.event.trace);
      if (!$.config.prefix)
        console.warn("It's recommended to use scoped instance with a prefix to prevent collision routing with other instance.");
      if ($.event.error.length)
        $.event.error.push(...this.event.error);
      if ($.config.aot)
        $.compile();
      if (Z === true && $.config.prefix) {
        this.mount($.config.prefix + "/", $.fetch);
        for (let j of $.router.history)
          this.routeTree.set(j.method + `${$.config.prefix}${j.path}`, this.router.history.length), this.router.history.push({ ...j, path: `${$.config.prefix}${j.path}`, hooks: i(j.hooks, { error: this.event.error }) });
      } else {
        this.mount($.fetch);
        for (let j of $.router.history)
          this.routeTree.set(j.method + `${$.config.prefix}${j.path}`, this.router.history.length), this.router.history.push({ ...j, path: `${$.config.prefix}${j.path}`, hooks: i(j.hooks, { error: this.event.error }) });
      }
      return this;
    } else {
      if (this.headers($.setHeaders), W) {
        if (!(W in this.dependencies))
          this.dependencies[W] = [];
        let j = X !== undefined ? N0(W + JSON.stringify(X)) : 0;
        if (!this.dependencies[W].some(({ checksum: Y }) => j === Y))
          this.extender.macros = this.extender.macros.concat($.extender.macros), this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat($.extender.higherOrderFunctions);
      } else
        this.extender.macros = this.extender.macros.concat($.extender.macros), this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat($.extender.higherOrderFunctions);
      j1(this.extender.macros), j1(this.extender.higherOrderFunctions);
      let J = [];
      for (let j = 0;j < this.extender.higherOrderFunctions.length; j++) {
        let Y = this.extender.higherOrderFunctions[j];
        if (Y.checksum) {
          if (J.includes(Y.checksum))
            this.extender.higherOrderFunctions.splice(j, 1), j--;
          J.push(Y.checksum);
        }
      }
      this.inference = { body: this.inference.body || $.inference.body, cookie: this.inference.cookie || $.inference.cookie, headers: this.inference.headers || $.inference.headers, query: this.inference.query || $.inference.query, set: this.inference.set || $.inference.set, server: this.inference.server || $.inference.server };
    }
    this.decorate($.singleton.decorator), this.state($.singleton.store), this.model($.definitions.type), this.error($.definitions.error), $.extender.macros = this.extender.macros.concat($.extender.macros);
    for (let { method: J, path: j, handler: Y, hooks: G } of Object.values($.router.history))
      this.add(J, j, Y, i(G, { error: $.event.error }));
    if (!Z)
      if (W) {
        if (!(W in this.dependencies))
          this.dependencies[W] = [];
        let J = X !== undefined ? N0(W + JSON.stringify(X)) : 0;
        if (this.dependencies[W].some(({ checksum: j }) => J === j))
          return this;
        this.dependencies[W].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: J, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: J, dependencies: $.dependencies, stack: $.telemetry.stack, routes: $.router.history, decorators: $.singleton, store: $.singleton.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((j) => j?.subType === "derive").map((j) => ({ fn: j.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((j) => j?.subType === "resolve").map((j) => ({ fn: j.toString(), stack: new Error().stack ?? "" })) }), this.event = V1(this.event, S1($.event), J);
      } else
        this.event = V1(this.event, S1($.event));
    return this.validator.global = i(this.validator.global, { ...$.validator.global }), this.validator.local = i(this.validator.local, { ...$.validator.scoped }), this;
  }
  macro($) {
    let W = { checksum: N0(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: $.toString() })), fn: $ };
    return this.extender.macros.push(W), this;
  }
  mount($, W) {
    if ($ instanceof Q0 || typeof $ === "function" || $.length === 0 || $ === "/") {
      let J = typeof $ === "function" ? $ : $ instanceof Q0 ? $.compile().fetch : W instanceof Q0 ? W.compile().fetch : W, j = async ({ request: Y, path: G }) => {
        if (Y.method === "GET" || Y.method === "HEAD" || !Y.headers.get("content-type"))
          return J(new Request(R0(Y.url, G || "/"), Y));
        return J(new Request(R0(Y.url, G || "/"), { ...Y, body: await Y.arrayBuffer() }));
      };
      return this.all("/*", j, { type: "none" }), this;
    }
    let X = $.length;
    if (W instanceof Q0)
      W = W.compile().fetch;
    let Z = async ({ request: J, path: j }) => {
      if (J.method === "GET" || J.method === "HEAD" || !J.headers.get("content-type"))
        return W(new Request(R0(J.url, j.slice(X) || "/"), J));
      return W(new Request(R0(J.url, j.slice(X) || "/"), { ...J, body: await J.arrayBuffer() }));
    };
    return this.all($, Z, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), Z, { type: "none" }), this;
  }
  get($, W, X) {
    return this.add("GET", $, W, X), this;
  }
  post($, W, X) {
    return this.add("POST", $, W, X), this;
  }
  put($, W, X) {
    return this.add("PUT", $, W, X), this;
  }
  patch($, W, X) {
    return this.add("PATCH", $, W, X), this;
  }
  delete($, W, X) {
    return this.add("DELETE", $, W, X), this;
  }
  options($, W, X) {
    return this.add("OPTIONS", $, W, X), this;
  }
  all($, W, X) {
    return this.add("ALL", $, W, X), this;
  }
  head($, W, X) {
    return this.add("HEAD", $, W, X), this;
  }
  connect($, W, X) {
    return this.add("CONNECT", $, W, X), this;
  }
  route($, W, X, Z) {
    return this.add($.toUpperCase(), W, X, Z, Z?.config), this;
  }
  ws($, W) {
    let X = W.transformMessage ? Array.isArray(W.transformMessage) ? W.transformMessage : [W.transformMessage] : undefined, Z = null, J = m(W?.body, { models: this.definitions.type, normalize: this.config.normalize }), j = m(W?.response, { models: this.definitions.type, normalize: this.config.normalize }), Y = (G) => {
      if (typeof G === "string") {
        let K = G?.charCodeAt(0);
        if (K === 47 || K === 123)
          try {
            G = JSON.parse(G);
          } catch {
          }
        else if (Z1(G))
          G = +G;
      }
      if (X?.length)
        for (let K = 0;K < X.length; K++) {
          let B = X[K](G);
          if (B !== undefined)
            G = B;
        }
      return G;
    };
    return this.route("$INTERNALWS", $, (G) => {
      let { set: K, path: B, qi: U, headers: w, query: F, params: Q } = G;
      if (Z === null)
        Z = this.getServer();
      if (Z?.upgrade(G.request, { headers: typeof W.upgrade === "function" ? W.upgrade(G) : W.upgrade, data: { validator: j, open(M) {
        W.open?.(new g0(M, G));
      }, message: (M, D) => {
        let z = Y(D);
        if (J?.Check(z) === false)
          return void M.send(new q("message", J, z).message);
        W.message?.(new g0(M, G), z);
      }, drain(M) {
        W.drain?.(new g0(M, G));
      }, close(M, D, z) {
        W.close?.(new g0(M, G), D, z);
      } } }))
        return;
      return K.status = 400, "Expected a websocket connection";
    }, { beforeHandle: W.beforeHandle, transform: W.transform, headers: W.headers, params: W.params, query: W.query }), this;
  }
  state($, W, X) {
    if (W === undefined)
      X = $, $ = { as: "append" }, W = "";
    else if (X === undefined) {
      if (typeof $ === "string")
        X = W, W = $, $ = { as: "append" };
      else if (typeof $ === "object")
        X = W, W = "";
    }
    let { as: Z } = $;
    if (typeof W !== "string")
      return this;
    switch (typeof X) {
      case "object":
        if (W) {
          if (W in this.singleton.store)
            this.singleton.store[W] = d(this.singleton.store[W], X, { override: Z === "override" });
          else
            this.singleton.store[W] = X;
          return this;
        }
        if (X === null)
          return this;
        return this.singleton.store = d(this.singleton.store, X, { override: Z === "override" }), this;
      case "function":
        if (W) {
          if (Z === "override" || !(W in this.singleton.store))
            this.singleton.store[W] = X;
        } else
          this.singleton.store = X(this.singleton.store);
        return this;
      default:
        if (Z === "override" || !(W in this.singleton.store))
          this.singleton.store[W] = X;
        return this;
    }
  }
  decorate($, W, X) {
    if (W === undefined)
      X = $, $ = { as: "append" }, W = "";
    else if (X === undefined) {
      if (typeof $ === "string")
        X = W, W = $, $ = { as: "append" };
      else if (typeof $ === "object")
        X = W, W = "";
    }
    let { as: Z } = $;
    if (typeof W !== "string")
      return this;
    switch (typeof X) {
      case "object":
        if (W) {
          if (W in this.singleton.decorator)
            this.singleton.decorator[W] = d(this.singleton.decorator[W], X, { override: Z === "override" });
          else
            this.singleton.decorator[W] = X;
          return this;
        }
        if (X === null)
          return this;
        return this.singleton.decorator = d(this.singleton.decorator, X, { override: Z === "override" }), this;
      case "function":
        if (W) {
          if (Z === "override" || !(W in this.singleton.decorator))
            this.singleton.decorator[W] = X;
        } else
          this.singleton.decorator = X(this.singleton.decorator);
        return this;
      default:
        if (Z === "override" || !(W in this.singleton.decorator))
          this.singleton.decorator[W] = X;
        return this;
    }
  }
  derive($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    let X = { subType: "derive", fn: W };
    return this.onTransform($, X);
  }
  model($, W) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([X, Z]) => {
          if (!(X in this.definitions.type))
            this.definitions.type[X] = Z;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = W, this;
  }
  mapDerive($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    let X = { subType: "mapDerive", fn: W };
    return this.onTransform($, X);
  }
  affix($, W, X) {
    if (X === "")
      return this;
    let Z = ["_", "-", " "], J = (K) => K[0].toUpperCase() + K.slice(1), j = $ === "prefix" ? (K, B) => Z.includes(K.at(-1) ?? "") ? K + B : K + J(B) : Z.includes(X.at(-1) ?? "") ? (K, B) => B + K : (K, B) => B + J(K), Y = (K) => {
      let B = {};
      switch (K) {
        case "decorator":
          for (let U in this.singleton.decorator)
            B[j(X, U)] = this.singleton.decorator[U];
          this.singleton.decorator = B;
          break;
        case "state":
          for (let U in this.singleton.store)
            B[j(X, U)] = this.singleton.store[U];
          this.singleton.store = B;
          break;
        case "model":
          for (let U in this.definitions.type)
            B[j(X, U)] = this.definitions.type[U];
          this.definitions.type = B;
          break;
        case "error":
          for (let U in this.definitions.error)
            B[j(X, U)] = this.definitions.error[U];
          this.definitions.error = B;
          break;
      }
    }, G = Array.isArray(W) ? W : [W];
    for (let K of G.some((B) => B === "all") ? ["decorator", "state", "model", "error"] : G)
      Y(K);
    return this;
  }
  prefix($, W) {
    return this.affix("prefix", $, W);
  }
  suffix($, W) {
    return this.affix("suffix", $, W);
  }
  compile() {
    if (this.fetch = this.config.aot ? b1(this) : g1(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server || {}, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => {
    return (this.fetch = this.config.aot ? b1(this) : g1(this))($);
  };
  handleError = async ($, W) => (this.handleError = this.config.aot ? x1(this) : C2(this))($, W);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, W) => {
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.compile(), typeof $ === "string") {
      if (!Z1($))
        throw new Error("Port must be a numeric value");
      $ = parseInt($);
    }
    let X = this.fetch, Z = typeof $ === "object" ? { development: !p0, reusePort: true, ...this.config.serve || {}, ...$ || {}, static: this.router.static.http.static, websocket: { ...this.config.websocket || {}, ...E1 || {} }, fetch: X, error: this.outerErrorHandler } : { development: !p0, reusePort: true, ...this.config.serve || {}, static: this.router.static.http.static, websocket: { ...this.config.websocket || {}, ...E1 || {} }, port: $, fetch: X, error: this.outerErrorHandler };
    this.server = Bun?.serve(Z);
    for (let J = 0;J < this.event.start.length; J++)
      this.event.start[J].fn(this);
    if (W)
      W(this.server);
    return process.on("beforeExit", () => {
      if (this.server) {
        this.server.stop(), this.server = null;
        for (let J = 0;J < this.event.stop.length; J++)
          this.event.stop[J].fn(this);
      }
    }), this.promisedModules.then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async ($) => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server) {
      if (this.server.stop($), this.server = null, this.event.stop.length)
        for (let W = 0;W < this.event.stop.length; W++)
          this.event.stop[W].fn(this);
    }
  };
  get modules() {
    return Promise.all(this.promisedModules.promises);
  }
}

// node_modules/drizzle-orm/mysql-core/unique-constraint.js
function uniqueKeyName3(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}

// node_modules/drizzle-orm/mysql-core/columns/common.js
class MySqlColumn extends Column {
  constructor(table, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName3(table, [config.name]);
    }
    super(table, config);
    this.table = table;
  }
  static [entityKind] = "MySqlColumn";
}
class MySqlColumnWithAutoIncrement extends MySqlColumn {
  static [entityKind] = "MySqlColumnWithAutoIncrement";
  autoIncrement = this.config.autoIncrement;
}

// node_modules/drizzle-orm/mysql-core/columns/char.js
class MySqlChar extends MySqlColumn {
  static [entityKind] = "MySqlChar";
  length = this.config.length;
  enumValues = this.config.enum;
  getSQLType() {
    return this.length === undefined ? `char` : `char(${this.length})`;
  }
}

// node_modules/drizzle-orm/mysql-core/columns/varbinary.js
class MySqlVarBinary extends MySqlColumn {
  static [entityKind] = "MySqlVarBinary";
  length = this.config.length;
  getSQLType() {
    return this.length === undefined ? `varbinary` : `varbinary(${this.length})`;
  }
}

// node_modules/drizzle-orm/mysql-core/columns/varchar.js
class MySqlVarChar extends MySqlColumn {
  static [entityKind] = "MySqlVarChar";
  length = this.config.length;
  enumValues = this.config.enum;
  getSQLType() {
    return this.length === undefined ? `varchar` : `varchar(${this.length})`;
  }
}

// node_modules/drizzle-typebox/index.mjs
var f = Type.Union([Type.String(), Type.Number(), Type.Boolean(), Type.Null()]);
var c3 = Type.Union([f, Type.Array(Type.Any()), Type.Record(Type.String(), Type.Any())]);
var u = (t3) => Type.Union([t3, Type.Null()]);
function p(n3, r) {
  const o3 = getTableColumns(n3), i3 = Object.entries(o3);
  let a = Object.fromEntries(i3.map(([e, t3]) => [e, d3(t3)]));
  r && (a = Object.assign(a, Object.fromEntries(Object.entries(r).map(([e, t3]) => [e, typeof t3 == "function" ? t3(a) : t3]))));
  for (const [t3, n4] of i3)
    n4.notNull ? n4.hasDefault && (a[t3] = Type.Optional(a[t3])) : a[t3] = Type.Optional(u(a[t3]));
  return Type.Object(a);
}
function y4(n3, r) {
  const o3 = getTableColumns(n3), i3 = Object.entries(o3);
  let a = Object.fromEntries(i3.map(([e, t3]) => [e, d3(t3)]));
  r && (a = Object.assign(a, Object.fromEntries(Object.entries(r).map(([e, t3]) => [e, typeof t3 == "function" ? t3(a) : t3]))));
  for (const [e, t3] of i3)
    t3.notNull || (a[e] = u(a[e]));
  return Type.Object(a);
}
var b = /^[\dA-Fa-f]{8}(?:-[\dA-Fa-f]{4}){3}-[\dA-Fa-f]{12}$/;
function d3(t3) {
  let f4;
  if (function(e) {
    return "enumValues" in e && Array.isArray(e.enumValues) && e.enumValues.length > 0;
  }(t3) && (f4 = t3.enumValues?.length ? Type.Union(t3.enumValues.map((t4) => Type.Literal(t4))) : Type.String()), !f4)
    if (t3.dataType === "custom")
      f4 = Type.Any();
    else if (t3.dataType === "json")
      f4 = c3;
    else if (t3.dataType === "array")
      f4 = Type.Array(d3(t3.baseColumn));
    else if (t3.dataType === "number")
      f4 = Type.Number();
    else if (t3.dataType === "bigint")
      f4 = Type.BigInt();
    else if (t3.dataType === "boolean")
      f4 = Type.Boolean();
    else if (t3.dataType === "date")
      f4 = Type.Date();
    else if (t3.dataType === "string") {
      const s = Type.String();
      (is(t3, PgChar) || is(t3, PgVarchar) || is(t3, MySqlVarChar) || is(t3, MySqlVarBinary) || is(t3, MySqlChar) || is(t3, SQLiteText)) && typeof t3.length == "number" && (s.maxLength = t3.length), f4 = s;
    } else
      is(t3, PgUUID) && (f4 = Type.RegEx(b));
  return f4 || (f4 = Type.Any()), f4;
}

// node_modules/nanoid/index.js
import { webcrypto as crypto2 } from "crypto";

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.js
var POOL_SIZE_MULTIPLIER = 128;
var pool;
var poolOffset;
function fillPool(bytes) {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
    crypto2.getRandomValues(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    crypto2.getRandomValues(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
}
function nanoid(size = 21) {
  fillPool(size -= 0);
  let id = "";
  for (let i3 = poolOffset - size;i3 < poolOffset; i3++) {
    id += urlAlphabet[pool[i3] & 63];
  }
  return id;
}

// src/schema.ts
var scopesSufficient = (has2, want) => has2.includes("*") || has2.includes(want) || want.split(".").length > 1 && scopesSufficient(has2, want.split(".").slice(0, -1).join(".") + ".*");
var buildConflictUpdateColumns = (table, columns) => {
  const cls = getTableColumns(table);
  return columns.reduce((acc, column) => {
    const colName = cls[column].name;
    acc[column] = sql.raw(`excluded.${colName}`);
    return acc;
  }, {});
};
var id = text().notNull().$defaultFn(() => nanoid()).primaryKey();
var createdAt = integer({ mode: "timestamp_ms" }).notNull().$defaultFn(() => sql`CURRENT_TIMESTAMP`);
var roles = sqliteTable("role", {
  id,
  createdAt,
  token: text().$defaultFn(() => "sct" + nanoid()),
  scope: text({ mode: "json" }).$type().notNull().$default(() => [])
});
var _getRole = y4(roles);
var getRole = V.Omit(_getRole, []);
var links = sqliteTable("link", {
  createdAt,
  shortcode: text().notNull().primaryKey(),
  destination: text().notNull(),
  group: text().references(() => groups.id),
  creator: text().notNull().references(() => roles.id)
});
var _createLink = p(links, {
  shortcode: V.String({ minLength: 1 })
});
var createLink = V.Omit(_createLink, ["id", "createdAt", "creator"]);
var groups = sqliteTable("group", {
  id,
  createdAt,
  owner: text().notNull().references(() => roles.id),
  name: text().notNull().unique(),
  protected: text({ enum: ["readonly"] })
});
var _createGroup = p(groups, {
  name: V.String({ minLength: 1 })
});
var createGroup = V.Omit(_createGroup, ["id", "createdAt", "owner"]);
var schema3 = {
  roles,
  groups,
  links
};

// node_modules/pathe/dist/shared/pathe.ff20891b.mjs
var _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
}
var _UNC_REGEX = /^[/\\]{2}/;
var _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
var _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
var normalize2 = function(path) {
  if (path.length === 0) {
    return ".";
  }
  path = normalizeWindowsPath(path);
  const isUNCPath = path.match(_UNC_REGEX);
  const isPathAbsolute = isAbsolute(path);
  const trailingSeparator = path[path.length - 1] === "/";
  path = normalizeString(path, !isPathAbsolute);
  if (path.length === 0) {
    if (isPathAbsolute) {
      return "/";
    }
    return trailingSeparator ? "./" : ".";
  }
  if (trailingSeparator) {
    path += "/";
  }
  if (_DRIVE_LETTER_RE.test(path)) {
    path += "/";
  }
  if (isUNCPath) {
    if (!isPathAbsolute) {
      return `//./${path}`;
    }
    return `//${path}`;
  }
  return isPathAbsolute && !isAbsolute(path) ? `/${path}` : path;
};
function normalizeString(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0;index <= path.length; ++index) {
    if (index < path.length) {
      char = path[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1)
        ;
      else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path.slice(lastSlash + 1, index)}`;
        } else {
          res = path.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var isAbsolute = function(p3) {
  return _IS_ABSOLUTE_RE.test(p3);
};
// node_modules/@elysiajs/swagger/dist/index.mjs
function isSchemaObject(schema4) {
  return "type" in schema4 || "properties" in schema4 || "items" in schema4;
}
function isDateTimeProperty(key, schema4) {
  return (key === "createdAt" || key === "updatedAt") && "anyOf" in schema4 && Array.isArray(schema4.anyOf);
}
function transformDateProperties(schema4) {
  if (!isSchemaObject(schema4) || typeof schema4 !== "object" || schema4 === null) {
    return schema4;
  }
  const newSchema = { ...schema4 };
  Object.entries(newSchema).forEach(([key, value2]) => {
    if (isSchemaObject(value2)) {
      if (isDateTimeProperty(key, value2)) {
        const dateTimeFormat = value2.anyOf?.find((item) => isSchemaObject(item) && item.format === "date-time");
        if (dateTimeFormat) {
          const dateTimeSchema = {
            type: "string",
            format: "date-time",
            default: dateTimeFormat.default
          };
          newSchema[key] = dateTimeSchema;
        }
      } else {
        newSchema[key] = transformDateProperties(value2);
      }
    }
  });
  return newSchema;
}
var SwaggerUIRender = (info, version2, theme, stringifiedSwaggerOptions, autoDarkMode) => {
  const swaggerOptions = JSON.parse(stringifiedSwaggerOptions);
  if (swaggerOptions.components && swaggerOptions.components.schemas) {
    swaggerOptions.components.schemas = Object.fromEntries(Object.entries(swaggerOptions.components.schemas).map(([key, schema4]) => [
      key,
      transformDateProperties(schema4)
    ]));
  }
  const transformedStringifiedSwaggerOptions = JSON.stringify(swaggerOptions);
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    ${autoDarkMode && typeof theme === "string" ? `
    <style>
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #222;
                color: #faf9a;
            }
            .swagger-ui {
                filter: invert(92%) hue-rotate(180deg);
            }

            .swagger-ui .microlight {
                filter: invert(100%) hue-rotate(180deg);
            }
        }
    </style>` : ""}
    ${typeof theme === "string" ? `<link rel="stylesheet" href="${theme}" />` : `<link rel="stylesheet" media="(prefers-color-scheme: light)" href="${theme.light}" />
<link rel="stylesheet" media="(prefers-color-scheme: dark)" href="${theme.dark}" />`}
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@${version2}/swagger-ui-bundle.js" crossorigin></script>
    <script>
        window.onload = () => {
            window.ui = SwaggerUIBundle(${transformedStringifiedSwaggerOptions});
        };
    </script>
</body>
</html>`;
};
var theme_default = `
/* basic theme */
.light-mode {
  --theme-color-1: #2a2f45;
  --theme-color-2: #757575;
  --theme-color-3: #8e8e8e;
  --theme-color-accent: #f06292;

  --theme-background-1: #fff;
  --theme-background-2: #f6f6f6;
  --theme-background-3: #e7e7e7;
  --theme-background-accent: #f062921f;

  --theme-border-color: rgba(0, 0, 0, 0.1);
}
.dark-mode {
  --theme-color-1: rgba(255, 255, 255, 0.9);
  --theme-color-2: rgba(156, 163, 175, 1);
  --theme-color-3: rgba(255, 255, 255, 0.44);
  --theme-color-accent: #f06292;

  --theme-background-1: #111728;
  --theme-background-2: #1e293b;
  --theme-background-3: #334155;
  --theme-background-accent: #f062921f;

  --theme-border-color: rgba(255, 255, 255, 0.1);
}
/* Document Sidebar */
.light-mode .sidebar,
.dark-mode .sidebar {
  --sidebar-background-1: var(--theme-background-1);
  --sidebar-item-hover-color: currentColor;
  --sidebar-item-hover-background: var(--theme-background-2);
  --sidebar-item-active-background: var(--theme-background-accent);
  --sidebar-border-color: transparent;
  --sidebar-color-1: var(--theme-color-1);
  --sidebar-color-2: var(--theme-color-2);
  --sidebar-color-active: var(--theme-color-accent);
  --sidebar-search-background: transparent;
  --sidebar-search-border-color: var(--theme-border-color);
  --sidebar-search--color: var(--theme-color-3);
}
/* Document header only shows on mobile*/
.dark-mode .t-doc__header,
.light-mode .t-doc__header {
  --header-background-1: rgba(255, 255, 255, 0.85);
  --header-border-color: transparent;
  --header-color-1: var(--theme-color-1);
  --header-color-2: var(--theme-color-2);
  --header-background-toggle: var(--theme-color-3);
  --header-call-to-action-color: var(--theme-color-accent);
}

.dark-mode .t-doc__header {
  --header-background-1: rgba(17, 23, 40, 0.75);
}

/* advanced */
.light-mode {
  --theme-button-1: rgb(49 53 56);
  --theme-button-1-color: #fff;
  --theme-button-1-hover: rgb(28 31 33);

  --theme-color-green: #069061;
  --theme-color-red: #ef0006;
  --theme-color-yellow: #edbe20;
  --theme-color-blue: #0082d0;
  --theme-color-orange: #fb892c;
  --theme-color-purple: #5203d1;

  --theme-scrollbar-color: rgba(0, 0, 0, 0.18);
  --theme-scrollbar-color-active: rgba(0, 0, 0, 0.36);
}
.dark-mode {
  --theme-button-1: #f6f6f6;
  --theme-button-1-color: #000;
  --theme-button-1-hover: #e7e7e7;

  --theme-color-green: #a3ffa9;
  --theme-color-red: #ffa3a3;
  --theme-color-yellow: #fffca3;
  --theme-color-blue: #a5d6ff;
  --theme-color-orange: #e2ae83;
  --theme-color-purple: #d2a8ff;

  --theme-scrollbar-color: rgba(255, 255, 255, 0.24);
  --theme-scrollbar-color-active: rgba(255, 255, 255, 0.48);
}
/* Elysia Specific */
.scalar-api-client__send-request-button,
.show-api-client-button {
  background: #3c82f6 !important;
}
.show-api-client-button:before {
  display: none;
}

.sidebar-search:hover {
  transition: all 0.15s ease-in-out;
  --sidebar-search-border-color: var(--theme-color-accent) !important;
  color: var(--sidebar-color-1) !important;
}
.scalar-api-client__container .sidebar {
  --sidebar-border-color: var(--theme-border-color);
}
@media (min-width: 1150px) {
  .section-container:has( ~ .footer):before,
  .tag-section-container:before {
    content: "";
    position: absolute;
    top: -5px;
    left: 0;
    width: 100%;
    height: 10px;
    background: linear-gradient(90deg, var(--theme-background-1) 3%,transparent 10%);
  }
}
.section-flare {
  position: absolute;
  width: 100vw;
  height: 300px;
  --stripes: repeating-linear-gradient(
    100deg,
    #fff 0%,
    #fff 7%,
    transparent 10%,
    transparent 12%,
    #fff 16%
  );
  --stripesDark: repeating-linear-gradient(
    100deg,
    #000 0%,
    #000 7%,
    transparent 10%,
    transparent 12%,
    #000 16%
  );
  --rainbow: repeating-linear-gradient(
    100deg,
    #60a5fa 10%,
    #e879f9 16%,
    #5eead4 22%,
    #60a5fa 30%
  );
  background-image: var(--stripes), var(--rainbow);
  background-size: 300%, 200%;
  background-position: 50% 50%, 50% 50%;
  filter: invert(100%);
  -webkit-mask-image: radial-gradient(
    ellipse at 100% 0%,
    black 40%,
    transparent 70%
  );
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  pointer-events: none;
  opacity: 0.15;
}
.dark-mode .section-flare {
  background-image: var(--stripesDark), var(--rainbow);
  filter: opacity(50%) saturate(200%);
  opacity: 0.25;
}
.section-flare:after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-image: var(--stripes), var(--rainbow);
  background-size: 200%, 100%;
  background-attachment: fixed;
  mix-blend-mode: difference;
}
.dark-mode .section-flare:after {
  background-image: var(--stripesDark), var(--rainbow);
}
@keyframes headerbackground {
  from {
    background: transparent;
    backdrop-filter: none;
  }
  to {
    background: var(--header-background-1);
    backdrop-filter: blur(12px);
  }
}
.light-mode .t-doc__header,
.dark-mode .t-doc__header {
  animation: headerbackground forwards;
  animation-timeline: scroll();
  animation-range: 0px 200px;
  --header-border-color: transparent;
}
`;
var ScalarRender = (info, version2, config, cdn) => `<!doctype html>
<html>
  <head>
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
      }
    </style>
    <style>
      ${config.customCss ?? theme_default}
    </style>
  </head>
  <body>
    <script
      id="api-reference"
      data-url="${config.spec?.url}"
      data-configuration='${JSON.stringify(config)}'
    >
    </script>
    <script src="${cdn ? cdn : `https://cdn.jsdelivr.net/npm/@scalar/api-reference@${version2}/dist/browser/standalone.min.js`}" crossorigin></script>
  </body>
</html>`;
var TransformKind2 = Symbol.for("TypeBox.Transform");
var ReadonlyKind2 = Symbol.for("TypeBox.Readonly");
var OptionalKind2 = Symbol.for("TypeBox.Optional");
var Hint2 = Symbol.for("TypeBox.Hint");
var Kind2 = Symbol.for("TypeBox.Kind");
var PatternBoolean2 = "(true|false)";
var PatternNumber2 = "(0|[1-9][0-9]*)";
var PatternString2 = "(.*)";
var PatternBooleanExact2 = `^${PatternBoolean2}$`;
var PatternNumberExact2 = `^${PatternNumber2}$`;
var PatternStringExact2 = `^${PatternString2}$`;
var ExtendsResult2;
(function(ExtendsResult22) {
  ExtendsResult22[ExtendsResult22["Union"] = 0] = "Union";
  ExtendsResult22[ExtendsResult22["True"] = 1] = "True";
  ExtendsResult22[ExtendsResult22["False"] = 2] = "False";
})(ExtendsResult2 || (ExtendsResult2 = {}));
var toOpenAPIPath = (path2) => path2.split("/").map((x3) => {
  if (x3.startsWith(":")) {
    x3 = x3.slice(1, x3.length);
    if (x3.endsWith("?"))
      x3 = x3.slice(0, -1);
    x3 = `{${x3}}`;
  }
  return x3;
}).join("/");
var mapProperties = (name, schema4, models) => {
  if (schema4 === undefined)
    return [];
  if (typeof schema4 === "string")
    if (schema4 in models)
      schema4 = models[schema4];
    else
      throw new Error(`Can't find model ${schema4}`);
  return Object.entries(schema4?.properties ?? []).map(([key, value2]) => {
    const {
      type: valueType = undefined,
      description,
      examples,
      ...schemaKeywords
    } = value2;
    return {
      description,
      examples,
      schema: { type: valueType, ...schemaKeywords },
      in: name,
      name: key,
      required: schema4.required?.includes(key) ?? false
    };
  });
};
var mapTypesResponse = (types, schema4) => {
  if (typeof schema4 === "object" && ["void", "undefined", "null"].includes(schema4.type))
    return;
  const responses = {};
  for (const type3 of types) {
    responses[type3] = {
      schema: typeof schema4 === "string" ? {
        $ref: `#/components/schemas/${schema4}`
      } : { ...schema4 }
    };
  }
  return responses;
};
var capitalize2 = (word) => word.charAt(0).toUpperCase() + word.slice(1);
var generateOperationId = (method, paths) => {
  let operationId = method.toLowerCase();
  if (paths === "/")
    return operationId + "Index";
  for (const path2 of paths.split("/")) {
    if (path2.charCodeAt(0) === 123) {
      operationId += "By" + capitalize2(path2.slice(1, -1));
    } else {
      operationId += capitalize2(path2);
    }
  }
  return operationId;
};
var cloneHook = (hook) => {
  if (!hook)
    return;
  return { ...hook };
};
var registerSchemaPath = ({
  schema: schema4,
  path: path2,
  method,
  hook,
  models
}) => {
  hook = cloneHook(hook);
  const contentType = hook?.type ?? [
    "application/json",
    "multipart/form-data",
    "text/plain"
  ];
  path2 = toOpenAPIPath(path2);
  const contentTypes = typeof contentType === "string" ? [contentType] : contentType ?? ["application/json"];
  const bodySchema = cloneHook(hook?.body);
  const paramsSchema = cloneHook(hook?.params);
  const headerSchema = cloneHook(hook?.headers);
  const querySchema = cloneHook(hook?.query);
  let responseSchema = cloneHook(hook?.response);
  if (typeof responseSchema === "object") {
    if (Kind2 in responseSchema) {
      const {
        type: type3,
        properties,
        required: required3,
        additionalProperties,
        patternProperties,
        ...rest3
      } = responseSchema;
      responseSchema = {
        "200": {
          ...rest3,
          description: rest3.description,
          content: mapTypesResponse(contentTypes, type3 === "object" || type3 === "array" ? {
            type: type3,
            properties,
            patternProperties,
            items: responseSchema.items,
            required: required3
          } : responseSchema)
        }
      };
    } else {
      Object.entries(responseSchema).forEach(([key, value2]) => {
        if (typeof value2 === "string") {
          if (!models[value2])
            return;
          const {
            type: type3,
            properties,
            required: required3,
            additionalProperties: _12,
            patternProperties: _22,
            ...rest3
          } = models[value2];
          responseSchema[key] = {
            ...rest3,
            description: rest3.description,
            content: mapTypesResponse(contentTypes, value2)
          };
        } else {
          const {
            type: type3,
            properties,
            required: required3,
            additionalProperties,
            patternProperties,
            ...rest3
          } = value2;
          responseSchema[key] = {
            ...rest3,
            description: rest3.description,
            content: mapTypesResponse(contentTypes, type3 === "object" || type3 === "array" ? {
              type: type3,
              properties,
              patternProperties,
              items: value2.items,
              required: required3
            } : value2)
          };
        }
      });
    }
  } else if (typeof responseSchema === "string") {
    if (!(responseSchema in models))
      return;
    const {
      type: type3,
      properties,
      required: required3,
      additionalProperties: _12,
      patternProperties: _22,
      ...rest3
    } = models[responseSchema];
    responseSchema = {
      "200": {
        ...rest3,
        content: mapTypesResponse(contentTypes, responseSchema)
      }
    };
  }
  const parameters3 = [
    ...mapProperties("header", headerSchema, models),
    ...mapProperties("path", paramsSchema, models),
    ...mapProperties("query", querySchema, models)
  ];
  schema4[path2] = {
    ...schema4[path2] ? schema4[path2] : {},
    [method.toLowerCase()]: {
      ...headerSchema || paramsSchema || querySchema || bodySchema ? { parameters: parameters3 } : {},
      ...responseSchema ? {
        responses: responseSchema
      } : {},
      operationId: hook?.detail?.operationId ?? generateOperationId(method, path2),
      ...hook?.detail,
      ...bodySchema ? {
        requestBody: {
          required: true,
          content: mapTypesResponse(contentTypes, typeof bodySchema === "string" ? {
            $ref: `#/components/schemas/${bodySchema}`
          } : bodySchema)
        }
      } : null
    }
  };
};
var filterPaths = (paths, docsPath, {
  excludeStaticFile = true,
  exclude: exclude3 = []
}) => {
  const newPaths = {};
  const excludePaths = [`/${docsPath}`, `/${docsPath}/json`].map((p3) => normalize2(p3));
  for (const [key, value2] of Object.entries(paths))
    if (!exclude3.some((x3) => {
      if (typeof x3 === "string")
        return key === x3;
      return x3.test(key);
    }) && !excludePaths.includes(key) && !key.includes("*") && (excludeStaticFile ? !key.includes(".") : true)) {
      Object.keys(value2).forEach((method) => {
        const schema4 = value2[method];
        if (key.includes("{")) {
          if (!schema4.parameters)
            schema4.parameters = [];
          schema4.parameters = [
            ...key.split("/").filter((x3) => x3.startsWith("{") && !schema4.parameters.find((params) => params.in === "path" && params.name === x3.slice(1, x3.length - 1))).map((x3) => ({
              schema: { type: "string" },
              in: "path",
              name: x3.slice(1, x3.length - 1),
              required: true
            })),
            ...schema4.parameters
          ];
        }
        if (!schema4.responses)
          schema4.responses = {
            200: {}
          };
      });
      newPaths[key] = value2;
    }
  return newPaths;
};
var swagger = async ({
  provider = "scalar",
  scalarVersion = "latest",
  scalarCDN = "",
  scalarConfig = {},
  documentation = {},
  version: version2 = "5.9.0",
  excludeStaticFile = true,
  path: path2 = "/swagger",
  exclude: exclude3 = [],
  swaggerOptions = {},
  theme = `https://unpkg.com/swagger-ui-dist@${version2}/swagger-ui.css`,
  autoDarkMode = true,
  excludeMethods = ["OPTIONS"],
  excludeTags = []
} = {
  provider: "scalar",
  scalarVersion: "latest",
  scalarCDN: "",
  scalarConfig: {},
  documentation: {},
  version: "5.9.0",
  excludeStaticFile: true,
  path: "/swagger",
  exclude: [],
  swaggerOptions: {},
  autoDarkMode: true,
  excludeMethods: ["OPTIONS"],
  excludeTags: []
}) => {
  const schema4 = {};
  let totalRoutes = 0;
  if (!version2)
    version2 = `https://unpkg.com/swagger-ui-dist@${version2}/swagger-ui.css`;
  const info = {
    title: "Elysia Documentation",
    description: "Development documentation",
    version: "0.0.0",
    ...documentation.info
  };
  const relativePath = path2.startsWith("/") ? path2.slice(1) : path2;
  const app = new Q0({ name: "@elysiajs/swagger" });
  app.get(path2, function documentation2() {
    const combinedSwaggerOptions = {
      url: `/${relativePath}/json`,
      dom_id: "#swagger-ui",
      ...swaggerOptions
    };
    const stringifiedSwaggerOptions = JSON.stringify(combinedSwaggerOptions, (key, value2) => {
      if (typeof value2 == "function")
        return;
      return value2;
    });
    const scalarConfiguration = {
      spec: {
        ...scalarConfig.spec,
        url: `/${relativePath}/json`
      },
      ...scalarConfig
    };
    return new Response(provider === "swagger-ui" ? SwaggerUIRender(info, version2, theme, stringifiedSwaggerOptions, autoDarkMode) : ScalarRender(info, scalarVersion, scalarConfiguration, scalarCDN), {
      headers: {
        "content-type": "text/html; charset=utf8"
      }
    });
  }).get(path2 === "/" ? "/json" : `${path2}/json`, function openAPISchema() {
    const routes = app.getGlobalRoutes();
    if (routes.length !== totalRoutes) {
      const ALLOWED_METHODS = ["GET", "PUT", "POST", "DELETE", "OPTIONS", "HEAD", "PATCH", "TRACE"];
      totalRoutes = routes.length;
      routes.forEach((route) => {
        if (route.hooks?.detail?.hide === true)
          return;
        if (excludeMethods.includes(route.method))
          return;
        if (ALLOWED_METHODS.includes(route.method) === false && route.method !== "ALL")
          return;
        if (route.method === "ALL") {
          ALLOWED_METHODS.forEach((method) => {
            registerSchemaPath({
              schema: schema4,
              hook: route.hooks,
              method,
              path: route.path,
              models: app.definitions?.type,
              contentType: route.hooks.type
            });
          });
          return;
        }
        registerSchemaPath({
          schema: schema4,
          hook: route.hooks,
          method: route.method,
          path: route.path,
          models: app.definitions?.type,
          contentType: route.hooks.type
        });
      });
    }
    return {
      openapi: "3.0.3",
      ...{
        ...documentation,
        tags: documentation.tags?.filter((tag) => !excludeTags?.includes(tag?.name)),
        info: {
          title: "Elysia Documentation",
          description: "Development documentation",
          version: "0.0.0",
          ...documentation.info
        }
      },
      paths: {
        ...filterPaths(schema4, relativePath, {
          excludeStaticFile,
          exclude: Array.isArray(exclude3) ? exclude3 : [exclude3]
        }),
        ...documentation.paths
      },
      components: {
        ...documentation.components,
        schemas: {
          ...app.definitions?.type,
          ...documentation.components?.schemas
        }
      }
    };
  });
  return app;
};
var src_default = swagger;

// node_modules/@elysiajs/bearer/dist/index.mjs
var bearer = ({
  extract: {
    body = "access_token",
    query: queryName = "access_token",
    header = "Bearer"
  } = {
    body: "access_token",
    query: "access_token",
    header: "Bearer"
  }
} = {
  extract: {
    body: "access_token",
    query: "access_token",
    header: "Bearer"
  }
}) => new Q0({
  name: "@elysiajs/bearer",
  seed: {
    body,
    query: queryName,
    header
  }
}).derive({ as: "global" }, function deriveBearer({ query, headers: { authorization } }) {
  return {
    get bearer() {
      if (authorization?.startsWith(header))
        return authorization.slice(header.length + 1);
      const q2 = query[queryName];
      if (Array.isArray(q2))
        return q2[0];
      if (q2)
        return q2;
    }
  };
});
var src_default2 = bearer;

// src/serve.ts
var tlApp = new Q0;
async function serve({ listen, db: dbPath }) {
  const db = drizzle(new Database2(dbPath), { schema: schema3 });
  const app = tlApp;
  const api = new Q0({ prefix: "/_shortcat", name: "api" }).use(src_default2()).derive(async ({ bearer: bearer2 }) => {
    if (!bearer2)
      return {};
    return {
      role: await db.query.roles.findFirst({ where: eq(roles.token, bearer2) })
    };
  }).derive(({ role }) => ({
    hasScope: (scope) => scopesSufficient(role?.scope ?? [], scope)
  })).macro(({ onBeforeHandle }) => ({
    needsScopes(requires) {
      if (!requires)
        return;
      onBeforeHandle(async ({ role, hasScope, error: error3 }) => {
        if (!role)
          return error3(401);
        if (!requires.every((required3) => hasScope(required3)))
          return error3(401, `Role ${role?.id} has scope '${role.scope}', needed '${requires.join("|")}'`);
      });
    }
  })).get("/ip", ({ server, request }) => server?.requestIP(request) ?? "awoo").group("/roles", (app2) => app2.get("me", ({ role }) => ({ role: role ?? null }), {
    detail: { description: "get yourself" },
    response: V.Object({ role: V.Nullable(getRole) })
  }).guard({ needsScopes: ["admin"] }).put("", async () => {
    return {
      role: await db.insert(roles).values({ scope: ["*"] }).returning().then((r) => r[0])
    };
  }, {
    detail: {
      description: "upsert a role"
    },
    response: V.Object({ role: getRole })
  })).group("/links", (app2) => app2.guard({ needsScopes: ["user"] }).get("", async ({ role }) => {
    return db.query.links.findMany();
  }).put("", async ({ body, role }) => await db.transaction(async (tx) => {
    await tx.delete(links).where(inArray(links.group, body.declaresGroups));
    return await tx.insert(links).values(body.links.map((o3) => ({ ...o3, creator: role.id }))).onConflictDoUpdate({
      target: links.shortcode,
      set: { destination: sql.raw(`excluded.${links.destination.name}`) }
    }).returning();
  }), {
    body: V.Object({
      declaresGroups: V.Array(V.String()),
      links: V.Array(createLink)
    }),
    detail: {
      description: "upsert links, atomically replacing declarative groups if provided"
    }
  })).group("/groups", (app2) => app2.guard({ needsScopes: ["user"] }).get("", async ({ role, hasScope }) => ({
    groups: await db.query.groups.findMany({
      where: hasScope("admin") ? undefined : eq(groups.owner, role.id)
    })
  })).get("/:nameOrId", async ({ role, params, error: error3, hasScope }) => {
    const group = await db.query.groups.findFirst({
      where: and(or(eq(groups.name, params.nameOrId), eq(groups.id, params.nameOrId)), hasScope("admin") ? undefined : eq(groups.owner, role.id))
    });
    return !group ? error3(404) : { group };
  }).put("", async ({ body, role }) => await db.insert(groups).values({ ...body.group, owner: role.id }).onConflictDoUpdate({
    target: groups.name,
    set: buildConflictUpdateColumns(groups, ["protected", "name"])
  }).returning(), {
    body: V.Object({
      group: createGroup
    }),
    detail: {
      description: "create a new group, owned by the authenticated role"
    }
  }));
  app.use(src_default({
    documentation: {
      components: {
        securitySchemes: {
          roleToken: {
            type: "http",
            scheme: "bearer"
          }
        }
      }
    }
  })).use(api).get("/", () => "shortcat").get("/*", async ({ params, redirect, error: error3 }) => {
    const short = params["*"];
    const link = await db.query.links.findFirst({
      where: eq(links.shortcode, short)
    });
    if (!link)
      return error3(404);
    return redirect(link.destination, 302);
  }).listen(!+listen ? JSON.parse(listen) : parseInt(listen));
  console.log(`listening on ${app.server?.hostname}:${app.server?.port} (in ${app.server?.development ? "dev mode" : "production"})`);
}

// src/admin.ts
async function admin({ db: dbPath }) {
  const db = drizzle(dbPath);
  const role = await db.insert(roles).values({ scope: ["*"] }).returning().then((a) => a[0]);
  process.stderr.write(`created new role '${role.id}' with scope '${role.scope.join("|")}'
token: `);
  console.log(role.token);
}

// src/index.ts
var a = await yargs_default(hideBin(process.argv)).alias("h", "help").alias("V", "version").demandCommand().command("serve [listen]", "start the server", (t3) => t3.demandOption("db-path").positional("listen", {
  describe: `what to bind on: a port or a JSON-encoded instance of bun.ServeOptions.
see https://elysiajs.com/patterns/configuration.html#serve`,
  default: "1312",
  type: "string"
}), (a3) => serve({
  listen: a3.listen,
  db: a3.dbPath
})).command("admin", "manage the server", (t3) => t3.demandOption("db-path"), (a3) => admin({ db: a3["db-path"] })).option("db-path", {
  alias: "d",
  type: "string",
  description: "path to sqlite db file"
}).parse();
